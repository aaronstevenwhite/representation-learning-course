[
  {
    "objectID": "index.html",
    "href": "index.html",
    "title": "About",
    "section": "",
    "text": "This site contains materials for a course on Representation Learning for Syntactic and Semantic Theory given by Aaron Steven White at the 2023 Linguistic Society of America Institute, held at the University of Massachusetts, Amherst from June 19–July 14, 2023."
  },
  {
    "objectID": "index.html#about-the-course",
    "href": "index.html#about-the-course",
    "title": "About",
    "section": "About the course",
    "text": "About the course\nExperimental methods and corpus annotation are becoming increasingly important tools in the development of syntactic and semantic theories. And while regression-based approaches to the analysis of experimental and corpus data are widely known, methods for inducing expressive syntactic and semantic representations from such data remain relatively underused. Such methods have only recently become feasible due to advances in machine learning and the availability of large-scale datasets of acceptability and inference judgments; and they hold promise because they allow theoreticians (i) to design analyses directly in terms of the theoretical constructs of interest and (ii) to synthesize multiple sources and types of data within a single model.\nThe broad area of machine learning that techniques for syntactic and semantic representation induction come from is known as representation learning; and while such techniques are now common in the natural language processing (NLP) literature, their use is largely confined either to models focused on particular NLP tasks, such as question answering or information extraction, or to ‘probing’ the representations of existing NLP models. As such, it remains difficult to see this literature’s relevance for theoreticians. This course aims to demonstrate that relevance by focusing on the use of representation learning for developing syntactic and semantic theories."
  },
  {
    "objectID": "index.html#about-the-instructor",
    "href": "index.html#about-the-instructor",
    "title": "About",
    "section": "About the instructor",
    "text": "About the instructor\nAaron Steven White is an Associate Professor of Linguistics and Computer Science at the University of Rochester, where he directs the Formal and Computational Semantics lab (FACTS.lab). His research investigates the relationship between linguistic expressions and conceptual categories that undergird the human ability to convey information about possible past, present, and future configurations of things in the world.\nIn addition to being a principal investigator on numerous federally funded grants and contracts, White is the recipient of a National Science Foundation Faculty Early Career Development (CAREER) award. His work has appeared in a variety linguistics, cognitive science, and natural language processing venues, including Semantics & Pragmatics, Glossa, Language Acquisition, Cognitive Science, Cognitive Psychology, Transactions of the Association for Computational Linguistics, and Empirical Methods in Natural Language Processing."
  },
  {
    "objectID": "index.html#about-the-site",
    "href": "index.html#about-the-site",
    "title": "About",
    "section": "About the site",
    "text": "About the site\nThe site itself is built using Quarto. The source files for this site are available on github at aaronstevenwhite/representation-learning-course. See Installation for information on how to run the code documented here."
  },
  {
    "objectID": "index.html#acknowledgments",
    "href": "index.html#acknowledgments",
    "title": "About",
    "section": "Acknowledgments",
    "text": "Acknowledgments\nThe development of these course materials builds on collaborations between Aaron Steven White and a variety of other researchers:\n\nModule 1 of this course builds on unpublished collaborative research with Jon Sprouse. A version of this work was presented as a poster at WCCFL34.\nModule 2 builds on unpublished collaborative research with Julian Grove, who led the development of the models covered in that module.\nModule 3 builds on collaborative research with Kyle Rawlins as well as the rest of the MegaAttitude Project team.\nModule 4 builds on work with Kyle Rawlins and Ben Van Durme as well as the rest of the Decompositional Semantics Initiative team–with specific acknowledgment of Will Gantt and Elias Stengel-Eskin for their work on the decomp toolkit.\n\nIt was additionally supported by multiple National Science Foundation grants:\n\nThe MegaAttitude Project: Investigating selection and polysemy at the scale of the lexicon (BCS-1748969/BCS-1749025)\nComputational Modeling of the Internal Structure of Events (BCS-2040831/BCS-2040820)\nThe typology of subordinate clauses: A case study (BCS-2214933)\nCAREER: Logical Form Induction (BCS/IIS-2237175)"
  },
  {
    "objectID": "index.html#license",
    "href": "index.html#license",
    "title": "About",
    "section": "License ",
    "text": "License \nRepresentation Learning for Syntactic and Semantic Theory by Aaron Steven White is licensed under a Creative Commons Attribution-ShareAlike 4.0 International License. Based on a work at https://github.com/aaronstevenwhite/representation-learning-course."
  },
  {
    "objectID": "installation.html",
    "href": "installation.html",
    "title": "Installation",
    "section": "",
    "text": "The site itself is built using Quarto. The source files for this site are available on github at aaronstevenwhite/representation-learning-course. You can obtain the files by cloning this repo.\nAll further code on this page assumes that you are inside of this cloned repo."
  },
  {
    "objectID": "installation.html#installing-quarto-and-extensions",
    "href": "installation.html#installing-quarto-and-extensions",
    "title": "Installation",
    "section": "Installing Quarto and extensions",
    "text": "Installing Quarto and extensions\nTo build this site, you will need to install Quarto as well as its include-code-files extension.\nquarto add quarto-ext/include-code-files\nThis extension is mainly used for including external STAN files."
  },
  {
    "objectID": "installation.html#building-the-docker-container",
    "href": "installation.html#building-the-docker-container",
    "title": "Installation",
    "section": "Building the Docker container",
    "text": "Building the Docker container\nAll pages that have executed code blocks are generated from jupyter notebooks, which were run within a Docker container constructed using the Dockerfile contained in this repo.\nFROM jupyter/datascience-notebook:notebook-6.5.4\n\n\n\nRUN pip install --upgrade pip cmdstanpy==1.1.0 arviz==0.15.1 torch==2.0.1 'transformers[torch]' &&\\\n\n    python -c \"from cmdstanpy import install_cmdstan; install_cmdstan(version='2.32.2')\"\nAssuming you have Docker installed, the image can be built using:\ndocker build -t representation-learning-course .\nA container based on this image can then be constructed using:\ndocker run -it --rm -p 8888:8888 -v \"${PWD}\":/home/jovyan/work representation-learning-course\nTo access jupyter, simply copy the link provided when running this command. You can change the port that docker forwards to by changing the first 8888 in the -p 8888:8888 option. Just remember to correspondingly change the port you attempt to access in your browser."
  },
  {
    "objectID": "motivations.html",
    "href": "motivations.html",
    "title": "Motivations",
    "section": "",
    "text": "At their core, syntactic and semantic theories are (at least) explanations of judgments about strings–i.e. elements of the set \\(\\Sigma^* = \\bigcup_{i=0}^\\infty \\Sigma^i\\) for some vocabulary \\(\\Sigma\\).1 One kind of judgment we are often concerned with is acceptability (see Schütze 2016 and references therein): introspective judgments of strings’ well-formedness relative to a language, context of use, etc.   For example, in a context where a host is asking a guest what they would like in addition to coffee, (1) is clearly well-formed (or acceptable), while (2) is clearly not (Ross 1967; see Sprouse and Villata 2021 and references therein).\nAnother kind of judgment we are often concerned with–particularly in semantic theory–is about inferential relationships between strings (see Davis and Gillon 2004, Ch. 4 and references therein).   For example, in a context where someone uses (3) and their addressee both trusts the user and doesn’t know that (4), the addressee will tend to infer that (4)–i.e. the content of the subordinate clause in (3) (see White 2019 and references therein).\nOne important property we want syntactic and semantic theories to have is observational adequacy (Chomsky 1964): for any string \\(s \\in \\Sigma^*\\), we can predict how acceptable someone who knows the language will find \\(s\\) relative to a particular context; and for any pair of strings \\(s, s' \\in \\Sigma^*\\) that person judges acceptable, we can predict whether that person judges \\(s'\\) to be inferable from \\(s\\) and vice versa–again, relative to a particular context.2\nIn addition to observational adequacy, we tend to want theories that are parsimonious. A common way of moving forward in this respect is to posit methods for mapping vocabulary elements and strings to a more or less constrained set of abstractions for use in predicting the relationship between a string and judgments of its acceptability or inferential relationships to other strings.3\nThese abstractions may take a wide variety of forms:\nThis course covers techniques both for learning such abstractions (or representations) from experimental and/or corpus data–with a focus on acceptability and inference judgment data–and for quantitatively assessing the observational adequacy and parsimony of some set of assumptions about the nature of those representations.\nThis approach is motivated by the mutually supportive goals of enabling syntacticians and semanticists to:\nMy aim in this course is to give you the conceptual and practical tools to understand (what I take to be) the theoretically relevant portions of the computational modeling literature and to provide you with a jumping off point from which to begin your research journey into it. You should not expect the course to provide you with a comprehensive overview of the literature in a particular area–even the areas that we will use as case studies. For example, I am not going to cover all the ways that researchers have modeled island effects. Rather, I will demonstrate how to incrementally develop hypothesis-driven models that can help us answer particular theoretical questions."
  },
  {
    "objectID": "motivations.html#footnotes",
    "href": "motivations.html#footnotes",
    "title": "Motivations",
    "section": "Footnotes",
    "text": "Footnotes\n\n\nDepending on your persuasion, the vocabulary \\(\\Sigma\\) might be a set of words; or it might be a set of morphemes. Nothing’s going to hinge on this distinction in this course.↩︎\nWe may furthermore want explanations that handle inference judgements between strings that are judged to be degraded in some sense (Higginbotham 1985; Berwick et al. 2011).↩︎\nDefinition of a set of vocabulary elements and segmentation of a string into those elements is already a highly nontrivial form of abstraction. This course will generally presuppose that the correct segmentations are given.↩︎"
  },
  {
    "objectID": "methodological-approach.html",
    "href": "methodological-approach.html",
    "title": "Methodological Approach",
    "section": "",
    "text": "This course is highly methodologically opinionated in taking a hypothesis-driven approach to representation learning, rather than the now common analysis-driven approach seen in much work at the intersection of computational linguistics and natural language processing (see Baroni 2022; Pavlick 2023 and references therein). Hypothesis-driven approaches to representation learning are distinguished from analysis-driven approaches in that they aim to finely delineate hypotheses about the nature of a phenomenon in terms of the constraints they place on the representations to be learned. In contrast, analysis-driven approaches aim to learn highly expressive representations and then extract generalizations about those representations post hoc.\nThis methodological distinction is roughly analogous to one observed in the theoretical syntax literature–a distinction classically exemplified by work in transformational grammar in the 1970s and 1980s. For background: transformational grammars are extremely expressive–generating the recursively enumerable languages (Peters and Ritchie 1973). But it is relatively well accepted that natural languages are a subset of a much smaller class of languages–itself a strict subset of the context sensitive languages (Joshi, Shanker, and Weir 1990). Insofar as one is merely interested in observational adequacy, there isn’t really a reason not to use a highly expressive formalism, like a transformational grammar; but insofar as one is interested in specifying “…the observed data…in terms of significant generalizations that express underlying regularities in the language” (Chomsky 1964, 63)–e.g. to obtain descriptive adequacy–then it is necessary to go beyond simply specifying an observationally adequate transformational grammar.\nOn the one hand, one might implement this idea by stating metaanalytical generalizations about the observationally adequate analyses in the too-expressive formalism, with the ultimate goal of reifying those generalizations as constraints on the formalism (see Chomsky 1973 et seq). This approach is similar to what I refer to above as analysis-driven representation learning.\nOn the other hand, one might attempt to take a more constrained formalism–e.g. some mildly context sensitive formalism, such as combinatory categorial grammars (Steedman 1996) or minimalist grammars (Stabler 1997)–and ask how well that formalism can cover the data. This approach is similar to what I refer to above as hypothesis-driven representation learning–the approach taken in this course.\n\n\n\n\nReferences\n\nBaroni, Marco. 2022. “On the Proper Role of Linguistically Oriented Deep Net Analysis in Linguistic Theorising.” In Algebraic Structures in Natural Language. CRC Press.\n\n\nChomsky, Noam. 1964. “Current Issues in Linguistic Theory.” Edited by J. Fodor and J. Katz. The Structure of Language. New York: Prentice Hall.\n\n\n———. 1973. “Conditions on Transformations.” In A Festschrift for Morris Halle, edited by S. Anderson and P. Kiparsky, 232–86. New York: Holt, Rinehart, & Winston.\n\n\nJoshi, Aravind, Vijay K. Shanker, and David Weir. 1990. “The Convergence of Mildly Context-Sensitive Grammar Formalisms.” MS-CIS-90-01. Philadelphia: Department of Computer; Information Science, University of Pennsylvania. https://repository.upenn.edu/cis_reports/539.\n\n\nPavlick, Ellie. 2023. “Symbols and Grounding in Large Language Models.” Philosophical Transactions of the Royal Society A: Mathematical, Physical and Engineering Sciences 381 (2251). https://doi.org/10.1098/rsta.2022.0041.\n\n\nPeters, P. Stanley, and R. W. Ritchie. 1973. “On the Generative Power of Transformational Grammars.” Information Sciences 6 (January): 49–83. https://doi.org/10.1016/0020-0255(73)90027-3.\n\n\nStabler, Edward. 1997. “Derivational Minimalism.” In Logical Aspects of Computational Linguistics, edited by Christian Retoré, 68–95. Lecture Notes in Computer Science. Berlin, Heidelberg: Springer. https://doi.org/10.1007/BFb0052152.\n\n\nSteedman, Mark. 1996. Surface Structure and Interpretation. Cambridge, MA: MIT Press."
  },
  {
    "objectID": "course-structure-and-content.html",
    "href": "course-structure-and-content.html",
    "title": "Course Structure and Content",
    "section": "",
    "text": "This course is partitioned into four modules, each structured around a case study of an empirical phenomenon that has proven important in developing syntactic and semantic theories. As the course progresses, we will develop and implement increasingly more expressive statistical models that encode interpretable assumptions about the constructs (representations) that might explain these phenomena. We will begin in Module 1 with models that minimally extend standard generalized linear mixed effects models and end in Module 4 with models that integrate large language models as a subcomponent."
  },
  {
    "objectID": "course-structure-and-content.html#module-1-island-effects",
    "href": "course-structure-and-content.html#module-1-island-effects",
    "title": "Course Structure and Content",
    "section": "Module 1: Island Effects",
    "text": "Module 1: Island Effects\nIn Module 1, we will focus on island effects. Island effects are modulations of acceptability that arise when a dependency crosses into particular kinds of constitutents. We classify these constitutents as islands.   For example, one type of island effect is observed when a WH dependency crosses into a coordinate structure, as in (2) from Motivations. Compare (2) with (1), which would be used to express the same question and is much better.\n\nWhat would you like with your coffee?\nWhat would you like and your coffee?\n\nOur main question will be whether–once we adjust for various potential sources of noise in judgments to sentences like (1) and (2)–there is clear evidence one way or another for whether islands are the product of a discrete or continuous representation and/or process."
  },
  {
    "objectID": "course-structure-and-content.html#module-2-projective-content",
    "href": "course-structure-and-content.html#module-2-projective-content",
    "title": "Course Structure and Content",
    "section": "Module 2: Projective Content",
    "text": "Module 2: Projective Content\nIn Module 2, we will focus on projective content. Projective content is propositional content associated with a linguistic expression that a comprehender infers a user of some containing expression to be committed to irrespective of inference-modifying linguistic operators, such as negation (not, no, none, etc.), found in that containing expression.    For instance, from uses of both (3) and (4)—which both contain (5) as a subexpression—comprehenders tend to infer that (5), even though (4) contains negation.\n\nJo liked that Bo left.\nJo didn’t like that Bo left.\nBo left.\n\nIn these cases, we say that the content of the clause embedding under like projects. Our main question will be whether inferences about projective content are undergirded by some discrete representation and/or process–as has been classically assumed–or whether they are better modeled as fundamentally continuous in nature."
  },
  {
    "objectID": "course-structure-and-content.html#module-3-argument-selection",
    "href": "course-structure-and-content.html#module-3-argument-selection",
    "title": "Course Structure and Content",
    "section": "Module 3: Argument Selection",
    "text": "Module 3: Argument Selection\nIn Module 3, we will focus on argument selection.     Our aim will be to explain why certain predicates are acceptable when paired with certain kinds of arguments but not others. For example, (7) and (6), are generally judged acceptable, suggesting that think and see are compatible with finite declarative subordinate clauses, such as that Bo left.\n\nJo saw that Bo left.\nJo thought that Bo left.\n\nBut while (8) is generally judged acceptable, suggesting that that see is additionally compatible with bare infinitive subordinate clauses, (9) is generally judged unacceptable, suggesting that think is not.\n\nJo saw Bo leave.\nJo thought Bo leave.\n\nAt least two things are generally assumed to determine the arguments a predicate is compatible with: the kind of meaning it has and idiosyncratic knowledge about the predicate. We will compare classes of models that constrain kinds of meanings in various ways."
  },
  {
    "objectID": "course-structure-and-content.html#module-4-thematic-roles",
    "href": "course-structure-and-content.html#module-4-thematic-roles",
    "title": "Course Structure and Content",
    "section": "Module 4: Thematic Roles",
    "text": "Module 4: Thematic Roles\nIn Module 4, we will focus on thematic roles–investigating, in particular, different theories of generalized thematic roles. Generalized thematic roles–such as AGENT and PATIENT–contrast with individual thematic roles–such as BREAKER and BREAKEE–and are often posited in order to explain how individual thematic roles are linked to particular syntactic positions.   For instance, in expressing that a BREAKER caused a BREAKEE to be broken, we find predicates like break in (10), which realize the BREAKER in subject position and BREAKEE in object position, but not predicates like shbreak that do the inverse–i.e. such that (11) means the same thing as (10)?\n\nThe boy broke the vase.\nThe vase shbroke the boy.\n\nOne kind of explanation posited in the literature is that individual thematic roles are grouped into generalized thematic roles and that the generalized thematic role an individual thematic role falls into determines which syntactic position that individual thematic role is associated with. Theories differ as to what generalized thematic roles exist, how they ar related to each other, and how they determine the association of individual thematic roles with syntactic positions."
  },
  {
    "objectID": "course-structure-and-content.html#preliminaries",
    "href": "course-structure-and-content.html#preliminaries",
    "title": "Course Structure and Content",
    "section": "Preliminaries",
    "text": "Preliminaries\nBefore starting on the main content of the course, it will be useful to cover an array of foundational concepts in probability and statistics. These notes will be excessively formal and pedantic–taking you from the definition of a probability space in terms of the the Kolmogorov axioms, through the formal definition of a random variable and probability distribution, up to the implementation of simple Metropolis-Hastings-based samplers.\nI do not expect you to know most of this stuff to this level of formality already; and for the most part, I will not stay at the level of formality found in this section anywhere else in the course. The purpose of these notes is mainly to act as a reference for cases where including a more formal explanation of a concept in the main body of the course notes would detract from the flow."
  },
  {
    "objectID": "foundational-concepts-in-probability-and-statistics/index.html",
    "href": "foundational-concepts-in-probability-and-statistics/index.html",
    "title": "What is a probability?",
    "section": "",
    "text": "A probability is a measurement of a possibility (relative to a range of possibilities). Probability theory is a way of formalizing this idea. The most common such formalization–the Kolmogorov axioms–can be thought of as defining: (i) what it means to be a possibility; and (ii) what it means to measure a possibility.1"
  },
  {
    "objectID": "foundational-concepts-in-probability-and-statistics/index.html#what-it-means-to-be-a-possibility",
    "href": "foundational-concepts-in-probability-and-statistics/index.html#what-it-means-to-be-a-possibility",
    "title": "What is a probability?",
    "section": "What it means to be a possibility",
    "text": "What it means to be a possibility\nThe Kolmogorov axioms start by specifying a set \\(\\Omega\\) that contains all and only the things that can possibly happen. This set is known as the sample space. So what it means to be a possibility is a brute fact: it’s all and only the things in \\(\\Omega\\).\nThat’s very abstract, so let’s consider a few examples relevant to this class:\n\n\\(\\Omega\\) could the set of all phonemes in a language (or some subset thereof)–e.g. the English vowels \\(\\Omega = \\{\\text{e, i, o, u, æ, ɑ, ɔ, ə, ɛ, ɪ, ʊ}\\}\\).\n\\(\\Omega\\) could be the set of all pairs of first and second formants–represented as all pairs of positive real numbers \\(\\mathbb{R}_+^2\\).2\n\\(\\Omega\\) could be the set of all strings of phonemes in a language–e.g. if \\(\\Sigma\\) is the set of phonemes, then \\(\\Omega = \\Sigma^* = \\bigcup_{i=0}^\\infty \\Sigma^i\\).\n\\(\\Omega\\) could be the set of all strings of morphemes in a language–e.g. if \\(\\Sigma\\) is the set of morphemes, then \\(\\Omega = \\Sigma^* = \\bigcup_{i=0}^\\infty \\Sigma^i\\).\n\\(\\Omega\\) could be the set of all grammatical derivations for a grammar \\(G\\)–e.g. if \\(G = \\langle \\Sigma, V, R, S \\rangle\\) (with \\(R \\subseteq V \\times (V \\cup \\Sigma \\cup \\{\\epsilon\\})^+\\)) is a context free grammar, then \\(\\Omega = \\bigcup_{s \\in L_G} P_G(s)\\), where \\(L_G\\) is the language generated by \\(G\\) and \\(P_G\\) is a parser for \\(G\\).\n\nThe axioms then move forward by defining classes of possibilities \\(F \\subseteq \\Omega\\), which together form a classification of possibilities \\(\\mathcal{F} \\subseteq 2^\\Omega\\). These classes of possibilities are known as events and the classification of possibilities is known as the event space. It is events, which can contain just a single possibility, that we measure the probability of.3\n\nTwo event spaces for (a subset of) English pronouns\nThe event space is where interesting linguistic structure enters the picture. Let’s look at a few examples of event spaces that assume that the sample space is the following set of pronouns of English: \\(\\Omega = \\{\\text{I}, \\text{me}, \\text{you}, \\text{they}, \\text{them}, \\text{it}, \\text{she}, \\text{her}, \\text{he}, \\text{him}, \\text{we}, \\text{us}\\}\\).\n\nemptyset = frozenset()\npronouns = frozenset({\n    \"I\", \"me\", \n    \"you\", \n    \"they\", \"them\", \n    \"it\", \n    \"she\", \"her\", \n    \"he\", \"him\", \n    \"we\", \"us\",\n})\n\n\nThe person event space\nOne possible event space distinguishes these pronouns with respect to third v. non-third: \\(\\mathcal{F}_\\text{person} = \\{F_\\text{[+third]}, F_\\text{[-third]}, \\Omega, \\emptyset\\}\\), with \\(F_\\text{[+third]} = \\{\\text{they}, \\text{them}, \\text{it}, \\text{she}, \\text{her}, \\text{he}, \\text{him}\\}\\) and \\(F_\\text{[-third]} = \\Omega - F_\\text{[+third]}\\).\n\nthird = frozenset({\"they\", \"them\", \"it\", \"she\", \"her\", \"he\", \"him\",})\nnonthird = pronouns - third\n\nf_person = frozenset({\n    frozenset(emptyset), \n    frozenset(third), frozenset(nonthird), \n    frozenset(pronouns)\n})\n\nYou’ll notice that beyond having just the set of third v. non-third pronouns in the event space, we also have the entire set of pronouns \\(\\Omega\\) itself alongside the empty set \\(\\emptyset\\). The reasons for this are technical: to make certain aspects of the formalization of what it means to measure possibilities work out nicely, we need the event space \\(\\mathcal{F}\\) to form what is known as a \\(\\sigma\\)-algebra on the sample space \\(\\Omega\\). All this means is that:\n\n\\(\\mathcal{F} \\subseteq 2^\\Omega\\)\n\\(E \\in \\mathcal{F}\\) iff \\(\\Omega - E \\in \\mathcal{F}\\) (closure under complement)\n\\(\\bigcup \\mathcal{E} \\in \\mathcal{F}\\) for all countable \\(\\mathcal{E} \\subseteq \\mathcal{F}\\) (closure under countable union)\n\\(\\bigcap \\mathcal{E} \\in \\mathcal{F}\\) for all countable \\(\\mathcal{E} \\subseteq \\mathcal{F}\\) (closure under countable intersection)\n\nYou can check that all of these conditions are satisfied for \\(\\mathcal{F}_\\text{person}\\) only if \\(\\Omega\\) and \\(\\emptyset\\) are both in \\(\\mathcal{F}\\). When \\(\\mathcal{F} \\subseteq 2^\\Omega\\) is a \\(\\sigma\\)-algebra, the pair \\(\\langle \\Omega, \\mathcal{F} \\rangle\\) is referred to as a measurable space. When \\(\\Omega\\) is finite–as it is here–we say that \\(\\langle \\Omega, \\mathcal{F} \\rangle\\) is more specifically a finite measurable space.\n\nfrom typing import Set, FrozenSet, Iterable\nfrom itertools import chain, combinations\nfrom functools import reduce\n\nSampleSpace = FrozenSet[str]\nEvent = FrozenSet[str]\nSigmaAlgebra = FrozenSet[Event]\n\ndef powerset(iterable: Iterable) -&gt; Iterable:\n    \"\"\"The power set of a set\n\n    See https://docs.python.org/3/library/itertools.html#itertools-recipes\n\n    Parameters\n    ----------\n    iterable\n        The set to take the power set of\n    \"\"\"\n    s = list(iterable)\n    return chain.from_iterable(combinations(s, r) for r in range(len(s)+1))\n\nclass FiniteMeasurableSpace:\n    \"\"\"A finite measurable space\n    \n    Parameters\n    ----------\n    atoms\n        The atoms of the space\n    sigma_algebra\n        The σ-algebra of the space    \n    \"\"\"\n    def __init__(self, atoms: SampleSpace, sigma_algebra: SigmaAlgebra):\n        self._atoms = atoms\n        self._sigma_algebra = sigma_algebra\n\n        self._validate()\n\n    def _validate(self):\n        for subset in self._sigma_algebra:\n            # check powerset condition\n            if not subset &lt;= self._atoms:\n                raise ValueError(\n                    \"All events must be a subset of the atoms. \"\n                    f\"{set(subset)} is an event but not a subset.\"\n                )\n\n            # check closure under complement\n            if not (self._atoms - subset) in self._sigma_algebra:\n                raise ValueError(\n                    \"The σ-algebra must be closed under complements. \"\n                    f\"{set(self._atoms - subset)} is the complement of {set(subset)}, \"\n                    \"which is an event, but it is not an event.\"\n                )\n\n        for subsets in powerset(self._sigma_algebra):\n            subsets = list(subsets)\n\n            # python doesn't like to reduce empty iterables\n            if not subsets:\n                continue\n\n            # check closure under finite union\n            union = frozenset(reduce(frozenset.union, subsets))\n            if union not in self._sigma_algebra:\n                raise ValueError(\n                    \"The σ-algebra must be closed under countable union. \"\n                    f\"{union} is a union of events {subsets} but not an event.\"\n                )\n\n            # check closure under finite intersection\n            intersection = frozenset(reduce(frozenset.intersection, subsets))\n            if intersection not in self._sigma_algebra:\n                raise ValueError(\n                    \"The σ-algebra must be closed under finite intersection. \"\n                    f\"{set(intersection)} is the intersection of events {subsets} but \"\n                    \"not an event.\"\n                )\n                \n        print(\"This pair is a finite measurable space.\")\n\n    @property\n    def atoms(self) -&gt; SampleSpace: \n        return self._atoms\n\n    @property\n    def sigma_algebra(self) -&gt; SigmaAlgebra:\n        return self._sigma_algebra\n\nThe \\(\\sigma\\)-algebra conditions are checked as part of initializing the implementation of FiniteMeasurableSpace, and so we see that \\(\\langle \\Omega, \\mathcal{F}_\\text{person}\\rangle\\) is a measurable space.\n\nperson_space = FiniteMeasurableSpace(pronouns, f_person)\n\nThis pair is a finite measurable space.\n\n\n\n\nThe case event space\nAnother possible event space that is slightly more interesting distinguishes pronouns with respect to case: \\(\\mathcal{F}_\\text{case} = \\{F_\\text{[+acc]}, F_\\text{[-acc]}, F_\\text{[+acc]} \\cap F_\\text{[-acc]}, \\Omega - F_\\text{[+acc]}, \\Omega - F_\\text{[-acc]}, \\Omega - [F_\\text{[+acc]} \\cap F_\\text{[-acc]}], \\Omega, \\emptyset\\}\\), with \\(F_\\text{[+acc]} = \\{\\text{me}, \\text{you}, \\text{them}, \\text{her}, \\text{him}, \\text{it}, \\text{us}\\}\\) and \\(F_\\text{[-acc]} = \\{\\text{I}, \\text{you}, \\text{they}, \\text{she}, \\text{he}, \\text{it}, \\text{we}\\}\\). Beyond the set of pronouns \\(\\Omega\\), the empty set \\(\\emptyset\\), the set of accusative pronouns \\(F_\\text{[+acc]}\\) and the set of non-accusative pronouns \\(F_\\text{[-acc]}\\), we additionally need:\n\nThe set of pronouns that can be either accusative or non-accusative \\(F_\\text{[+acc]} \\cap F_\\text{[-acc]} = \\{\\text{you}, \\text{it}\\}\\).\nThe set of non-accusatives that cannot be accusative \\(\\Omega - F_\\text{[+acc]} = \\{\\text{I}, \\text{they}, \\text{he}, \\text{she}, \\text{we}\\}\\)\nThe set of accusatives that cannot be non-accusative \\(\\Omega - F_\\text{[-acc]} = \\{{\\text{me}, \\text{them}, \\text{her}, \\text{us}, \\text{him}}\\}\\)\nThe set of pronouns that cannot be both accusative and non-accusative \\(\\Omega - [F_\\text{[+acc]} \\cap F_\\text{[-acc]}]\\).\n\nThe first set is required to be in \\(\\mathcal{F}_\\text{case}\\) according to condition 4 of being a \\(\\sigma\\)-algebra.4 The other three sets are required to be in \\(\\mathcal{F}_\\text{case}\\) according to condition 2 of being a \\(\\sigma\\)-algebra.5\n\nacc = frozenset({\"me\", \"you\", \"them\", \"her\", \"him\", \"it\", \"us\"})\nnonacc = frozenset({\"I\", \"you\", \"they\", \"she\", \"he\", \"it\", \"we\"})\n\nf_case = frozenset({\n    frozenset(emptyset), \n    frozenset(acc), frozenset(nonacc),\n    frozenset(acc & nonacc),\n    frozenset(pronouns - acc),\n    frozenset(pronouns - nonacc),\n    frozenset(pronouns - (acc & nonacc)),\n    frozenset(pronouns)\n})\n\ncase_space = FiniteMeasurableSpace(pronouns, f_case)\n\nThis pair is a finite measurable space.\n\n\n\n\n\nCombining event spaces\nGiven two measurable spaces with the same sample space, such as \\(\\mathcal{F}_\\text{person}\\) and \\(\\mathcal{F}_\\text{case}\\), we might want to combine them to create a measurable space \\(\\mathcal{F}_\\text{person-case}\\) that contains events such as \\(F_\\text{[+third,+acc]}\\).\n\n\n\n\n\n\nQuestion\n\n\n\nCan we define \\(\\mathcal{F}_\\text{person-case} \\equiv \\mathcal{F}_\\text{person} \\cup \\mathcal{F}_\\text{case}\\). If not, why not?\n\n\n\n\n\n\n\n\nAnswer\n\n\n\n\n\nWe cannot define \\(\\mathcal{F}_\\text{person-case} \\equiv \\mathcal{F}_\\text{person} \\cup \\mathcal{F}_\\text{case}\\). While Condition 1 above would be satisfied (that’s easy), we would be missing quite a few sets that Conditions 2-4 require. For instance, the third person accusative pronouns \\(F_\\text{[+third,+acc]} \\equiv F_\\text{[+third]} \\cap F_\\text{[+acc]}\\) would not be an event.\n\n\n\n\ntry:\n    person_space = FiniteMeasurableSpace(pronouns, f_person.union(f_case))\nexcept ValueError as e:\n    print(f\"ValueError: {e}\")\n\nValueError: The σ-algebra must be closed under countable union. frozenset({'he', 'me', 'we', 'I', 'they', 'it', 'she', 'you', 'us'}) is a union of events [frozenset({'they', 'he', 'it', 'she', 'you', 'we', 'I'}), frozenset({'me', 'we', 'I', 'you', 'us'})] but not an event.\n\n\nThis point demonstrates an important fact about \\(\\sigma\\)-algebras: if you design a classification based on some (countable) set of features like person and case, the constraint that \\(\\mathcal{F}\\) be a \\(\\sigma\\)-algebra on \\(\\Omega\\) implies that \\(\\mathcal{F}\\) contains events corresponding to all possible conjunctions (e.g. third and accusative) and disjunctions (e.g. third and/or accusative) of those features. So we need to extend \\(\\mathcal{F}_\\text{person} \\cup \\mathcal{F}_\\text{case}\\) with additional sets. We call this extension the \\(\\sigma\\)-algebra generated by the family of sets \\(\\mathcal{F}_\\text{person} \\cup \\mathcal{F}_\\text{case}\\), denoted \\(\\sigma\\left(\\mathcal{F}_\\text{person} \\cup \\mathcal{F}_\\text{case}\\right)\\).\n\ndef generate_sigma_algebra(family: SigmaAlgebra) -&gt; SigmaAlgebra:\n    \"\"\"Generate a σ-algebra from a family of sets\n    \n    Parameters\n    ----------\n    family\n        The family of sets from which to generate the σ-algebra\n    \"\"\"\n\n    sigma_algebra = set(family)\n    old_sigma_algebra = set(family)\n    \n    complete = False\n\n    while not complete:\n        for subsets in powerset(old_sigma_algebra):\n            subsets = list(subsets)\n\n            if not subsets:\n                continue\n\n            union = reduce(frozenset.union, subsets)\n            sigma_algebra.add(union)\n\n            intersection = reduce(frozenset.intersection, subsets)\n            sigma_algebra.add(intersection)\n\n        complete = sigma_algebra == old_sigma_algebra\n        old_sigma_algebra = set(sigma_algebra)\n\n    return frozenset(sigma_algebra)\n\nOne challenge is that generating this \\(\\sigma\\)-algebra for even relatively small families of sets can take a non-trivial amount of time. So for the remainder of this review, I’m going to cheat a bit and artificially distinguish the pronouns whose accusative and non-accusative variants are the same.\n\npronouns = frozenset({\n    \"I\", \"me\", \n    \"you_nonacc\", \"you_acc\", \n    \"they\", \"them\", \n    \"it_nonacc\", \"it_acc\", \n    \"she\", \"her\", \n    \"he\", \"him\", \n    \"we\", \"us\",\n})\n\nThis move allows us to define the event space more simply.\n\nacc = frozenset({\"me\", \"you_acc\", \"them\", \"her\", \"him\", \"it_acc\", \"us\"})\nnonacc = frozenset({\"I\", \"you_nonacc\", \"they\", \"she\", \"he\", \"it_nonacc\", \"we\"})\n\nf_case = frozenset({\n    frozenset(emptyset), \n    frozenset(acc), frozenset(nonacc),\n    frozenset(pronouns)\n})\n\ncase_space = FiniteMeasurableSpace(pronouns, f_case)\n\nThis pair is a finite measurable space.\n\n\nTo ensure that the person and case spaces have the same sample space, we will similarly need to redefine the person space.\n\nthird = frozenset({\"they\", \"them\", \"it_acc\", \"it_nonacc\", \"she\", \"her\", \"he\", \"him\"})\nnonthird = pronouns - third\n\nf_person = frozenset({\n    frozenset(emptyset), \n    frozenset(third), frozenset(nonthird), \n    frozenset(pronouns)\n})\n\nperson_space = FiniteMeasurableSpace(pronouns, f_person)\n\nThis pair is a finite measurable space.\n\n\nFinally, we can generate the \\(\\sigma\\)-algebra for our person-case space and check that it’s valid.\n\nf_person_case = generate_sigma_algebra(f_person | f_case)\n\nperson_case_space = FiniteMeasurableSpace(pronouns, f_person_case)\n\nThis pair is a finite measurable space.\n\n\n\n\nConsiderations around defining event spaces\nThis way of setting up sample spaces is useful when we have strong a priori assumptions we want to inject into our probability models. We’ll see cases of this assumption injection as we move through the course. In many cases, however, we want an event space that makes fewer assumptions. So when the sample space is finite–as it is here–we’ll often just default to \\(\\mathcal{F} \\equiv 2^\\Omega\\), which is the “finest” event space on \\(\\Omega\\) we can muster–i.e. it is a superset of all other possible event spaces. This sort of event space, which is often referred to as the discrete event space on \\(\\Omega\\), will tend to ignore potentially useful prior knowledge we have about the sample space–e.g. morphosyntactic features that pronouns have–though it is possible to represent that knowledge “in the measurement”, as we’ll see.\nWhen the sample space is infinite, things get a bit trickier: the powerset is uncountable for even a countably infinite sample space–something that we need to consider in the context of working with strings and derivations.6 This property can be a problem for reasons I’ll gesture at when we discuss continuous probability distributions. So in general, we won’t work with event spaces that are power sets of their corresponding sample space in this context. We’ll instead work with what are called Borel \\(\\sigma\\)-algebras. It’s not important to understand the intricacies of what a Borel \\(\\sigma\\)-algebra is; I’ll try to give you an intuition below."
  },
  {
    "objectID": "foundational-concepts-in-probability-and-statistics/index.html#what-it-means-to-measure-a-possibility",
    "href": "foundational-concepts-in-probability-and-statistics/index.html#what-it-means-to-measure-a-possibility",
    "title": "What is a probability?",
    "section": "What it means to measure a possibility",
    "text": "What it means to measure a possibility\nI said that a probability is a measurement of a possibility. We’ve now formalized what a possibility is in this context. Now let’s turn to the measurement part.\nThe Kolmogorov axioms build the notion of a probability measure from the more general concept of a measure. All a probability measure \\(\\mathbb{P}\\) is going to do is to map from some event in the event space (e.g. third pronoun, accusative pronoun, etc.) to a non-negative real value–with values corresponding to higher probabilities. So it is a function \\(\\mathbb{P}: \\mathcal{F} \\rightarrow \\mathbb{R}_+\\). This condition is the first of the Kolmogorov axioms.\n\n\\(\\mathbb{P}: \\mathcal{F} \\rightarrow \\mathbb{R}_+\\)\n\nYou might be used to thinking of probabilities as being between \\([0, 1]\\). This property is a consequence of the two other axioms:\n\nThe probability of the entire sample space \\(\\mathbb{P}(\\Omega) = 1\\) (the assumption of unit measure)\nGiven a countable collection of events \\(E_1, E_2, \\ldots \\in \\mathcal{F}\\) that is pairwise disjoint–i.e. \\(E_i \\cap E_j = \\emptyset\\) for all \\(i \\neq j\\)–\\(\\mathbb{P}\\left(\\bigcup_i E_i\\right) = \\sum_i \\mathbb{P}(E_i)\\) (the assumption of \\(\\sigma\\)-additivity)\n\n\nfrom typing import Dict\n\nclass ProbabilityMeasure:\n    \"\"\"A probability measure with finite support\n\n    Parameters\n    ----------\n    domain\n        The domain of the probability measure\n    measure\n        The graph of the measure\n    \"\"\"\n\n    def __init__(self, domain: FiniteMeasurableSpace, measure: Dict[Event, float]):\n        self._domain = domain\n        self._measure = measure\n\n        self._validate()\n\n    def __call__(self, event: Event) -&gt; float:\n        return self._measure[event]\n\n    def _validate(self):\n        # check that the measure covers the domain\n        for event in self._domain.sigma_algebra:\n            if event not in self._measure:\n                raise ValueError(\n                    \"Probability measure must be defined for all events.\"\n                )\n\n        # check the assumption of unit measure\n        if self._measure[frozenset(self._domain.atoms)] != 1:\n            raise ValueError(\n                \"The probability of the sample space must be 1.\"\n            )\n\n        # check assumption of 𝜎-additivity\n        for events in powerset(self._domain.sigma_algebra):\n            events = list(events)\n\n            if not events:\n                continue\n\n            if not any(e1.intersection(e2) for e1, e2 in combinations(events, 2)):\n                prob_union = self._measure[reduce(frozenset.union, events)]\n                prob_sum = sum(self._measure[e] for e in events)\n\n            if round(prob_union, 4) != round(prob_sum, 4):\n                raise ValueError(\n                    \"The measure does not satisfy 𝜎-additivity.\"\n                )\n                \n        print(\"This probability measure is valid for the given measurable space.\")\n\nOne example of a probability measure for our measurable space \\(\\langle \\Omega, \\mathcal{F}_\\text{person-case}\\rangle\\) is the uniform measure: \\(\\mathbb{P}(E) = \\frac{|E|}{|\\Omega|}\\).\n\nmeasure_person_case = ProbabilityMeasure(\n    person_case_space,\n    {e: len(e)/len(person_case_space.atoms) \n     for e in person_case_space.sigma_algebra} \n)\n\nThis probability measure is valid for the given measurable space.\n\n\nThese axioms imply that the range of \\(\\mathbb{P}\\) is \\([0, 1]\\), even if its codomain is \\(\\mathbb{R}_+\\); otherwise, it would have to be the case that \\(\\mathbb{P}(E) &gt; 1\\) for some \\(E \\subset \\Omega\\). (\\(E\\) would have to be a strict subset of \\(\\Omega\\), since \\(\\Omega \\supseteq E\\) for all \\(E \\in \\mathcal{F}\\) and \\(\\mathbb{P}(\\Omega) = 1\\) by definition.) But \\(\\mathbb{P}(E) &gt; 1\\) cannot hold, since \\(\\mathbb{P}(\\Omega - E)\\)–which must be defined, given that \\(\\mathcal{F}\\) is closed under complementation–is nonnegative; and thus \\(\\mathbb{P}(E) + \\mathbb{P}(\\Omega - E) &gt; \\mathbb{P}(\\Omega) = 1\\) contradicts the third axiom \\(\\mathbb{P}(E) + \\mathbb{P}(\\Omega - E) = \\mathbb{P}(E \\cup [\\Omega - E]) = \\mathbb{P}(\\Omega) = 1\\).\n(One reason the codomain of \\(\\mathbb{P}\\) is often specified as the more general \\(\\mathbb{R}_+\\)–rather than \\([0, 1]\\) is to make salient the fact that probabilities are analogous to other kinds of measurements, like weight, height, temperature, etc.)\nThese axioms also imply that \\(\\mathbb{P}(\\emptyset) = 0\\), since \\(\\mathbb{P}(\\Omega) = \\mathbb{P}(\\Omega \\cup \\emptyset) = \\mathbb{P}(\\Omega) + \\mathbb{P}(\\emptyset) = 1\\), and so \\(\\mathbb{P}(\\emptyset) = 1 - \\mathbb{P}(\\Omega) = 0\\)."
  },
  {
    "objectID": "foundational-concepts-in-probability-and-statistics/index.html#summing-up",
    "href": "foundational-concepts-in-probability-and-statistics/index.html#summing-up",
    "title": "What is a probability?",
    "section": "Summing up",
    "text": "Summing up\nWe will formalize a probability space as a triple \\(\\langle \\Omega, \\mathcal{F}, \\mathbb{P} \\rangle\\) with:\n\nA set \\(\\Omega\\) (the sample space)\nA \\(\\sigma\\)-algebra \\(\\mathcal{F}\\) (the event space), where:\n\n\\(\\mathcal{F} \\subseteq 2^\\Omega\\)\n\\(E \\in \\mathcal{F}\\) iff \\(\\Omega - E \\in \\mathcal{F}\\) (closure under complement)\n\\(\\bigcup \\mathcal{E} \\in \\mathcal{F}\\) for all countable \\(\\mathcal{E} \\subseteq \\mathcal{F}\\) (closure under countable union)\n\\(\\bigcap \\mathcal{E} \\in \\mathcal{F}\\) for all countable \\(\\mathcal{E} \\subseteq \\mathcal{F}\\) (closure under countable intersection)\n\nA probability measure \\(\\mathbb{P}\\), where:\n\n\\(\\mathbb{P}: \\mathcal{F} \\rightarrow \\mathbb{R}_+\\)\nThe probability of the entire sample space \\(\\mathbb{P}(\\Omega) = 1\\) (the assumption of unit measure)\nGiven a countable collection of events \\(E_1, E_2, \\ldots \\in \\mathcal{F}\\) that is pairwise disjoint–i.e. \\(E_i \\cap E_j = \\emptyset\\) for all \\(i \\neq j\\)–\\(\\mathbb{P}\\left(\\bigcup_i E_i\\right) = \\sum_i \\mathbb{P}(E_i)\\) (the assumption of \\(\\sigma\\)-additivity)\n\n\nIt is this core that we build on in developing probabilistic models. To develop these models, it is useful to develop a few additional definitions and theorems.\n\nMutual exclusivity\nTwo events \\(A \\in \\mathcal{F}\\) and \\(B \\in \\mathcal{F}\\) are mutually exclusive if they are disjoint: \\(A \\cap B = \\emptyset\\). This implies that \\(\\mathbb{P}(A \\cap B) = \\mathbb{P}(\\emptyset) = 0\\) for all mutually exclusive events \\(A\\) and \\(B\\).\n\nclass ProbabilityMeasure(ProbabilityMeasure):\n\n    def are_mutually_exclusive(self, *events: Iterable[Event]):\n        self._validate_events(events)\n        return not any(e1.intersection(e2) for e1, e2 in combinations(events, 2))\n\n    def _validate_events(self, events: Iterable[Event]):\n        for i, event in enumerate(events):\n            if event not in self._domain.sigma_algebra:\n                raise ValueError(f\"event{i} is not in the event space.\")\n\nIn our running example, the set of third-person pronouns \\(F_\\text{[+third]}\\) and the set of non-third person pronouns \\(F_\\text{[-third]}\\) are mutually exclusive events because \\(F_\\text{[+third]} \\cap F_\\text{[-third]} = \\emptyset\\).\n\nmeasure_person_case = ProbabilityMeasure(\n    person_case_space,\n    {e: len(e)/len(person_case_space.atoms) \n     for e in person_case_space.sigma_algebra} \n)\n\nmeasure_person_case.are_mutually_exclusive(third, nonthird)\n\nTrue\n\n\n\n\nJoint probability\nThe joint probability \\(\\mathbb{P}(A, B)\\) of two events \\(A \\in \\mathcal{F}\\) and \\(B \\in \\mathcal{F}\\) is defined as the probability of the intersection of those two events \\(\\mathbb{P}(A, B) = \\mathbb{P}(A \\cap B)\\), which must be defined given that \\(\\mathcal{F}\\) is closed under countable intersection.\n\nfrom typing import List\n\nclass ProbabilityMeasure(ProbabilityMeasure):\n\n    def __call__(self, *events: Iterable[Event]) -&gt; float:\n        self._validate_events(events)\n\n        intersection = reduce(frozenset.intersection, events)\n\n        return self._measure[intersection]\n\nIn our running example, the probability of a third-person accusative pronoun is the joint probability \\(\\mathbb{P}\\left(F_\\text{[+third]}, F_\\text{[+acc]}\\right)\\).\n\nmeasure_person_case = ProbabilityMeasure(\n    person_case_space,\n    {e: len(e)/len(person_case_space.atoms) \n     for e in person_case_space.sigma_algebra} \n)\n\nmeasure_person_case(frozenset(third), frozenset(acc))\n\n0.2857142857142857\n\n\n\n\nConditional probability\nThe probability of an event \\(A \\in \\mathcal{F}\\) conditioned on (or given) an event \\(B \\in \\mathcal{F}\\) is defined as \\(\\mathbb{P}(A \\mid B) = \\frac{\\mathbb{P}(A, B)}{\\mathbb{P}(B)}\\). Note that \\(\\mathbb{P}(A \\mid B)\\) is undefined if \\(\\mathbb{P}(B) = 0\\).\n\nclass ProbabilityMeasure(ProbabilityMeasure):\n\n    def __or__(self, conditions: Iterable[Event]) -&gt; ProbabilityMeasure:\n        condition = reduce(frozenset.intersection, conditions)\n\n        self._validate_condition(condition)\n\n        measure = {\n            event: self(event, condition)/self(condition) \n            for event in self._domain.sigma_algebra\n        }\n\n        return ProbabilityMeasure(self._domain, measure)\n\n    def _validate_condition(self, condition: Event):\n        if condition not in self._domain.sigma_algebra:\n            raise ValueError(\"The conditions must be in the event space.\")\n\n        if self._measure[condition] == 0:\n            raise ZeroDivisionError(\"Conditions cannot have probability 0.\")\n\nIn our running example, the probability that a pronoun is third-person given that it is accusative is the conditional probability \\(\\mathbb{P}\\left(F_\\text{[+third]} \\mid F_\\text{[+acc]}\\right) = \\frac{\\mathbb{P}\\left(F_\\text{[+third]}, F_\\text{[+acc]}\\right)}{\\mathbb{P}\\left(F_\\text{[+acc]}\\right)}\\).\n\nperson_case_measure = {\n    event: len(event)/len(person_case_space.atoms) \n    for event in person_case_space.sigma_algebra\n}\n\nmeasure_person_case = ProbabilityMeasure(\n    person_case_space,\n    person_case_measure \n)\n\nmeasure_given_back = measure_person_case | [acc]\n\nmeasure_given_back(third)\n\n0.5714285714285714\n\n\nFrom this definition, it immediately follows that \\(\\mathbb{P}(A, B) = \\mathbb{P}(A \\mid B)\\mathbb{P}(B) = \\mathbb{P}(B \\mid A)\\mathbb{P}(A)\\), which in turn implies Bayes’ theorem.\n\\[\\mathbb{P}(A \\mid B) = \\frac{\\mathbb{P}(A, B)}{\\mathbb{P}(B)} = \\frac{\\mathbb{P}(B \\mid A)\\mathbb{P}(A)}{\\mathbb{P}(B)}\\]\nBayes’ theorem will be very important in this course.\nAnother important consequence of the definition of conditional probability is the chain rule:\n\\[\\begin{align*}\\mathbb{P}(E_1, E_2, E_3, \\ldots, E_N) &= \\mathbb{P}(E_1)\\mathbb{P}(E_2 \\mid E_1)\\mathbb{P}(E_3 \\mid E_1, E_2)\\ldots\\mathbb{P}(E_N \\mid E_1, E_2, \\ldots, E_{N-1})\\\\ &= \\mathbb{P}(E_1)\\prod_{i=2}^N \\mathbb{P}(E_i\\mid E_1, \\ldots, E_{i-1})\\end{align*}\\]\nThe chain rule will also be very important in this course.\n\n\nIndependence\nAn event \\(A \\in \\mathcal{F}\\) is independent of an event \\(B \\in \\mathcal{F}\\) (under \\(\\mathbb{P}\\)) if \\(\\mathbb{P}(A \\mid B) = \\mathbb{P}(A)\\). A theorem that immediately follows from this definition is that \\(A\\) and \\(B\\) are independent under \\(\\mathbb{P}\\) if and only if \\(\\mathbb{P}(A, B) = \\mathbb{P}(A \\mid B)\\mathbb{P}(B) = \\mathbb{P}(A)\\mathbb{P}(B)\\).\n\nclass ProbabilityMeasure(ProbabilityMeasure):\n\n    def are_independent(self, *events):\n        self._validate_events(events)\n\n        joint = self(*events)\n        product = reduce(lambda x, y: x * y, [self(e) for e in events])\n\n        return joint == product\n\nIn our running example of an event space structured by person and case, assuming all pronouns are equiprobable, none of the events are independent. In the discrete event space, many events will be independent.\n\nmeasure_person_case = ProbabilityMeasure(\n    person_case_space,\n    {e: len(e)/len(person_case_space.atoms) \n     for e in person_case_space.sigma_algebra} \n)\n\nmeasure_person_case.are_independent(frozenset(third), frozenset(acc))\n\nTrue\n\n\nNote that independence is not the same as mutual exclusivity; indeed, mutually exclusive events are not independent, since \\(\\mathbb{P}(A \\mid B) = \\frac{\\mathbb{P}(A, B)}{\\mathbb{P}(B)} = \\frac{0}{\\mathbb{P}(B)} = 0\\) (or is undefined if \\(\\mathbb{P}(B) = 0\\)) regardless of \\(\\mathbb{P}(A)\\), and therefore either \\(\\mathbb{P}(A \\mid B)\\) does not equal \\(\\mathbb{P}(A)\\) or \\(\\mathbb{P}(B \\mid A)\\) is undefined (because \\(\\mathbb{P}(A) = 0\\)), even when \\(\\mathbb{P}(B)\\) is."
  },
  {
    "objectID": "foundational-concepts-in-probability-and-statistics/index.html#footnotes",
    "href": "foundational-concepts-in-probability-and-statistics/index.html#footnotes",
    "title": "What is a probability?",
    "section": "Footnotes",
    "text": "Footnotes\n\n\nWhat it means for a quantity to be a probability is a surprisingly contentious topic. It’s an interesting topic–and I encourage you to read about the various possibilities–but for the purposes of this course, we will tend to think of probabilities as a quantification of a degree of belief. This interpretation is sometimes referred to as the subjective or Bayesian interpretation.↩︎\nIf you’ve taken a phonetics course, you know that this definition overgenerates possibilities, since the values that the first and second formats can take on are constrained by the structure of the human vocal tract.↩︎\nDon’t ask me why, but \\(\\mathcal{F}\\) is standard notation for the event space. Why we don’t use \\(\\mathcal{E}\\) is beyond me. It might be some convention from measure theory I’m not aware of; or it might have to do with not confusing the event space with the expectation \\(\\mathbb{E}\\), which we’ll review below.↩︎\nThe analogous set \\(F_\\text{[+third]} \\cap F_\\text{[-third]}\\) for \\(\\mathcal{F}_\\text{person}\\) is already accounted for, since \\(F_\\text{[+third]}\\) and \\(F_\\text{[-third]}\\) are disjoint and thus \\(F_\\text{[+third]} \\cap F_\\text{[-third]} = \\emptyset\\), which is in \\(\\mathcal{F}_\\text{person}\\).↩︎\nCondition 4 of being a \\(\\sigma\\)-algebra requires \\(F_\\text{[+acc]} \\cup F_\\text{[-acc]} \\in \\mathcal{F}_\\text{person}\\) (among other unions), but we do not need to explicitly say this, since \\(F_\\text{[+acc]} \\cup F_\\text{[-acc]} = \\Omega\\), which is already specified to be in \\(\\mathcal{F}_\\text{case}\\).↩︎\nRemember that \\(2^{\\Sigma^*}\\) is the set of all languages on \\(\\Sigma\\); and the set of all languages, even when \\(\\Sigma\\) is finite, is uncountable.↩︎"
  },
  {
    "objectID": "foundational-concepts-in-probability-and-statistics/random-variables-and-probability-distributions.html",
    "href": "foundational-concepts-in-probability-and-statistics/random-variables-and-probability-distributions.html",
    "title": "Random variables and probability distributions",
    "section": "",
    "text": "Random variables and probability distributions together provide a way of classifying probability spaces. One reason this classification is useful for our purposes is that it makes it straightforward to decompose probability spaces with complex event spaces–e.g. event spaces on strings or grammatical derivations–into a collection of simpler probability spaces.\nWhen actually working with random variables and probability distributions, the line between the two is often blurred. This fact is particularly apparent when we consider how popular libraries like scipy (and its dependents) model the two. For this reason, I’m going to walk through some technicalities before showing any code."
  },
  {
    "objectID": "foundational-concepts-in-probability-and-statistics/random-variables-and-probability-distributions.html#random-variables",
    "href": "foundational-concepts-in-probability-and-statistics/random-variables-and-probability-distributions.html#random-variables",
    "title": "Random variables and probability distributions",
    "section": "Random variables",
    "text": "Random variables\nWe tend to think of random variables as fundamentally indeterminate in nature. We model this indeterminacy using a function. Specifically, we use a measurable function \\(X: \\Omega \\rightarrow A\\), where \\(\\langle \\Omega, \\mathcal{F} \\rangle\\) and \\(\\langle A, \\mathcal{G} \\rangle\\) are both measurable spaces, which just means that \\(\\Omega\\) and \\(A\\) are sets associated with \\(\\sigma\\)-algebras \\(\\mathcal{F}\\) and \\(\\mathcal{G}\\), respectively. Given \\(\\sigma\\)-algebras \\(\\mathcal{F}\\) and \\(\\mathcal{G}\\), this function must satisfy the constraint that:\n\\[\\{X^{-1}(E) \\mid E \\in \\mathcal{G}\\} \\subseteq \\mathcal{F}\\]\nThat is, every event \\(E\\) in the codomain space \\(\\mathcal{G} \\subseteq 2^A\\) must have a corresponding event \\(X^{-1}(E)\\) as its pre-image in the domain space \\(\\mathcal{F} \\subseteq 2^\\Omega\\).\nI’m using \\(\\langle \\Omega, \\mathcal{F} \\rangle\\) for the domain space to signal that the domain of a random variable is always the sample and event space of some probability space, which means that there will always be some probability space \\(\\langle \\Omega, \\mathcal{F}, \\mathbb{P} \\rangle\\) implicit in a random variable \\(X\\).\nFor our purposes, the codomain \\(A\\) of \\(X\\) will almost always be the real numbers \\(\\mathbb{R}\\) and \\(\\mathcal{G}\\) will be almost always be the Borel \\(\\sigma\\)-algebra on \\(\\mathbb{R}\\). As I mentioned above, knowing the fine details of what a Borel \\(\\sigma\\)-algebra is is not going to be necessary: all you really need to know is that it’s got every real interval, so \\(E \\in \\mathcal{G}\\) will always be an interval (and crucially, not just a single real number).\nTo ground this out, we can consider our running example of English pronouns again, where \\(\\Omega = \\left\\{\\text{I}, \\text{me}, \\text{you}_\\text{[+acc]}, \\text{you}_\\text{[-acc]}, \\text{they}, \\text{them}, \\text{it}_\\text{[+acc]}, \\text{it}_\\text{[-acc]} \\text{she}, \\text{her}, \\text{he}, \\text{him}, \\text{we}, \\text{us}\\right\\}\\).\n\npronouns = frozenset({\n    \"I\", \"me\", \n    \"you_nonacc\", \"you_acc\", \n    \"they\", \"them\", \n    \"it_nonacc\", \"it_acc\", \n    \"she\", \"her\", \n    \"he\", \"him\", \n    \"we\", \"us\",\n})\n\nSo \\(X(\\omega)\\), where \\(\\omega\\) is some pronoun, will be a real number. It’s important to note that \\(X\\) is being applied directly to a pronoun (rather than a set of pronouns in the event space) and resulting in a single real number (rather than an interval in the Borel \\(\\sigma\\)-algebra on the reals). I’m pointing this out because of the way we defined a random variable: in terms of the pre-image \\(X^{-1}(E)\\) of \\(E\\) under \\(X\\) (relativized to \\(\\sigma\\)-algebras \\(\\mathcal{F}\\) and \\(\\mathcal{G}\\)). \\(X^{-1}(E)\\) is a pre-image, not the value of an inverse, which will be important when we discuss discrete v. continuous random variables.\nIf we were to assume that the event space for our pronouns is the discrete event space \\(2^\\Omega\\), one possible (arbitrarily ordered) random variable is:\n\\[V = \\begin{bmatrix} \\text{I} \\rightarrow 1 \\\\ \\text{me} \\rightarrow 2 \\\\ \\text{you}_\\text{[+acc]} \\rightarrow 3 \\\\ \\text{you}_\\text{[-acc]} \\rightarrow 4 \\\\ \\text{they} \\rightarrow 5 \\\\ \\text{them} \\rightarrow 6 \\\\ \\text{it}_\\text{[+acc]} \\rightarrow 7 \\\\ \\text{it}_\\text{[-acc]} \\rightarrow 8 \\\\ \\text{she} \\rightarrow 9 \\\\ \\text{her} \\rightarrow 10 \\\\ \\text{he} \\rightarrow 11 \\\\ \\text{him} \\rightarrow 12 \\\\ \\text{we} \\rightarrow 13 \\\\ \\text{us} \\rightarrow 14 \\\\ \\end{bmatrix}\\]\nSo then, for example, \\(V^{-1}((-\\infty, 4)) = \\left\\{\\text{I}, \\text{me}, \\text{you}_\\text{[+acc]}\\right\\}\\), \\(V^{-1}((1, 5)) = \\left\\{\\text{me}, \\text{you}_\\text{[+acc]}, \\text{you}_\\text{[-acc]}\\right\\}\\), and \\(V^{-1}((11, \\infty)) = V^{-1}((-\\infty, 1)) = V^{-1}((1, 2)) = \\emptyset\\), all of which are in \\(\\mathcal{F} = 2^\\Omega\\).\n\nDiscrete v. continuous random variables\nAn important distinction among random variables is whether they are discrete or continuous.\n\nDiscrete random variables\nA discrete random variable is one whose range \\(X(\\Omega)\\)—i.e. the image of its domain—is countable. The random variable given above is thus countable, since \\(V(\\Omega) = \\{1, ..., 14\\}\\) is finite and therefore countable.\nA discrete random variable need not be finite. For instance, we often want to work with sample spaces consisting of all strings \\(\\Sigma^*\\) of primitive elements \\(\\Sigma\\)–e.g. phonemes, morphemes, etc.–in a language. In this case, we might be concerned with modeling the length of a string, and so wemight define a random variable \\(L: \\Sigma^* \\rightarrow \\mathbb{R}\\) that maps a string \\(\\omega \\in \\Sigma^*\\) to its length \\(L(\\omega)\\). Unlike \\(V\\), \\(L\\) has an infinite but countable range (assuming lengths are isomorphic with the natural numbers); and unlike \\(V\\), \\(L\\) is not injective: if \\(L(\\omega_1) = L(\\omega_2)\\), it is not guaranteed that \\(\\omega_1 = \\omega_2\\), since many strings share a length with other strings.\n\n\nContinuous random variables\nA continuous random variable is a random variable whose range is uncountable. One example of a continuous random variable (mentioned earlier) is one where \\(\\Omega\\) is the set of all pairs of first and second formant values. In this case, we’ll assume that \\(\\Omega\\) is just all pairs of positive real numbers \\(\\mathbb{R}_+^2\\).1\nIf we assume that the random variable \\(F: \\mathbb{R}_+^2 \\rightarrow \\mathbb{R}^2\\) is the identity function \\(F(\\mathbf{x}) = \\mathbf{x}\\), we get that \\(F\\) is a continuous random variable, since \\(\\mathbb{R}\\) is uncountable and \\(F^{-1}(E) = E \\in \\mathcal{F}\\)."
  },
  {
    "objectID": "foundational-concepts-in-probability-and-statistics/random-variables-and-probability-distributions.html#probability-distributions",
    "href": "foundational-concepts-in-probability-and-statistics/random-variables-and-probability-distributions.html#probability-distributions",
    "title": "Random variables and probability distributions",
    "section": "Probability distributions",
    "text": "Probability distributions\nA probability distribution is a compact description of a probability space \\(\\langle \\Omega, \\mathcal{F}, \\mathbb{P} \\rangle\\) in conjunction with a random variable whose domain is \\(\\Omega\\) (relative to \\(\\mathcal{F}\\)).\n\nDiscrete probability distributions\nIn the case of a discrete random variable \\(X\\) (e.g. our pronoun and string-length examples), we can fully describe its probability distribution using a probability mass function (PMF) \\(p_X: \\text{cod}(X) \\rightarrow \\mathbb{R}_+\\).This function is defined directly in terms of the random variable and the probability function \\(\\mathbb{P}\\):\n\\[p_X(x) \\equiv \\mathbb{P}(\\{\\omega \\in \\Omega \\mid X(\\omega) = x\\})\\]\nThese definitions are related to a notation that you might be familiar with: \\(\\mathbb{P}(X = x) \\equiv p_X(x)\\). This notation is often extended to other relations \\(\\mathbb{P}(X \\in E) = \\mathbb{P}(\\{\\omega \\in \\Omega \\mid \\omega \\in X^{-1}(E)\\})\\) or \\(\\mathbb{P}(X \\leq x) \\equiv \\mathbb{P}(\\{\\omega: X(\\omega) \\leq x\\})\\).\nThe latter of these is often used in defining the cumulative distribution function (CDF) \\(F_X: \\text{cod}(X) \\rightarrow \\mathbb{R}_+\\):\n\\[F_X(x) = \\mathbb{P}(X \\leq x) = \\sum_{y \\in X(\\Omega):y&lt;x} p_X(y)\\]\nThe PMF (and by extension the CDF) is parameterized in terms of the information necessary to define their outputs for all possible inputs \\(x \\in X(\\Omega)\\). This parameterization allows us to talk about families of distributions, which all share a functional form (modulo the values of the parameters). We’ll see a few examples of this below.\nIn scipy, discrete distributions are implemented using scipy.rv_discrete, either by direct instantiation or subclassing.\n\nfrom scipy.stats import rv_discrete\n\n\nFinite distributions\nWhen there are a finite number of values that the random variables can take, as in the example of \\(V\\) above, the probability of each possibility can simply be listed. One such distribution—or really family of distributions—that we will make extensive use of—indeed, the distribution that our pronoun random variable \\(V\\) from above has—is the categorical distribution.2 This distribution is parameterized by a list of probabilities \\(\\boldsymbol\\theta\\), where \\(\\theta_i\\) gives \\(p_V(i) = \\mathbb{P}(V = i) = \\mathbb{P}(\\{\\omega \\in \\Omega \\mid V(\\omega) = i\\}) = \\theta_i\\) and \\(\\sum_{i \\in V(\\Omega)} \\theta_i\\).3\n\nfrom numpy import arange\n\nidx = arange(14)\ntheta = (0.03, 0.09, 0.03, 0.12, 0.07, 0.28, 0.07, 0.05, 0.02, 0.02, 0.07, 0.08, 0.05, 0.02)\ncategorical = rv_discrete(name='categorical', values=(idx, theta))\n\nThe PMF is implemented as an instance method rv_discrete.pmf on this distribution.\n\n\nCode\nimport warnings\nfrom matplotlib.pyplot import subplot\n\nwarnings.filterwarnings('ignore')\n\npronouns_ordered = [\n    'us', 'they', 'them', r'you_[-acc]',\n    'he', 'I', r'it_[-acc]', 'me', 'him', 'she',\n    'we', r'it_[+acc]', r'you_[+acc]', 'her'\n]\n\nax = subplot()\nax.plot(pronouns_ordered, categorical.pmf(idx), 'ro', ms=12, mec='r')\nax.vlines(pronouns_ordered, 0, categorical.pmf(idx), colors='r', lw=4)\nax.set_xticklabels(pronouns_ordered, rotation=45, ha='right')\nax.set_ylabel(\"Probability\")\n_ = ax.set_title(\"PMF for categorical distribution on pronouns\")\n\n\n\n\n\nThe Bernoulli distribution, which we will also make extensive use of, is a special case of the categorical distribution where \\(|X(\\Omega)| = 2\\).\n\nfrom scipy.stats import bernoulli\n\nBy convention, \\(X(\\Omega) = \\{0, 1\\}\\). In this case, we need to specify the probability \\(\\pi\\) for only one value of \\(X\\), since the probability of the other must be \\(1- \\pi\\). Indeed, more generally, we need to specify only \\(|X(\\Omega)| - 1\\) values for a random variable \\(X\\) that is distributed categorical.\nImportantly, note that the condition that \\(|X(\\Omega)| = 2\\) is a condition on the range of \\(X\\), not on \\(\\Omega\\). So it may be that \\(|\\Omega| &gt; 2\\). Indeed, we would want this in the case where we had an event space like \\(\\mathcal{F}_\\text{case}\\), where \\(\\mathcal{F}_\\text{case} = \\{F_\\text{[+acc]}, F_\\text{[-acc]}, \\Omega, \\emptyset\\}\\), with \\(F_\\text{[+acc]} = \\{\\text{me}, \\text{you}_\\text{[+acc]}, \\text{them}, \\text{her}, \\text{him}, \\text{it}_\\text{[+acc]}, \\text{us}\\}\\) and \\(F_\\text{[-acc]} = \\Omega - F_\\text{[+acc]}\\).\nWe then might say that:\n\\[X(\\omega) = \\begin{cases}\n1 & \\text{if } \\omega \\in F_\\text{[+acc]}\\\\\n0 & \\text{otherwise}\n\\end{cases}\\]\nThat is, the function that maps a pronoun to whether it is accusative or not is a Bernoulli random variable.\n\nbern = bernoulli(0.27)\n\n\n\nCode\nax = subplot()\nax.plot([\"[–acc]\", \"[+acc]\"], bern.pmf([0, 1]), 'ro', ms=12, mec='r')\nax.vlines([\"[–acc]\", \"[+acc]\"], 0, bern.pmf([0, 1]), colors='r', lw=4)\nax.set_ylabel(\"Probability\")\n_ = ax.set_title(\"PMF for Bernoulli distribution on pronoun case\")\n\n\n\n\n\n\n\n\n\n\n\nQuestion\n\n\n\nSuppose we did not include the case specifications on you and it in \\(\\Omega\\), instead defining \\(\\mathcal{F}_\\text{case}\\) as we did here: \\(\\mathcal{F}_\\text{case} = \\{F_\\text{[+acc]}, F_\\text{[-acc]}, F_\\text{[+acc]} \\cap F_\\text{[-acc]}, \\Omega - F_\\text{[+acc]}, \\Omega - F_\\text{[-acc]}, \\Omega - [F_\\text{[+acc]} \\cap F_\\text{[-acc]}], \\Omega, \\emptyset\\}\\), with \\(F_\\text{[+acc]} = \\{\\text{me}, \\text{you}, \\text{them}, \\text{her}, \\text{him}, \\text{it}, \\text{us}\\}\\) and \\(F_\\text{[-acc]} = \\{\\text{I}, \\text{you}, \\text{they}, \\text{she}, \\text{he}, \\text{it}, \\text{we}\\}\\). How would \\(X\\) need to change?\n\n\n\n\n\n\n\n\nAnswer\n\n\n\n\n\nOne option is to say:\n\\[X(\\omega) = \\begin{cases}\n2 & \\text{if } \\omega \\in F_\\text{[+acc]} \\land \\omega \\in F_\\text{[-acc]}\\\\\n1 & \\text{if } \\omega \\in F_\\text{[+acc]} \\land \\omega \\not\\in F_\\text{[-acc]}\\\\\n0 & \\text{otherwise}\n\\end{cases}\\]\nAnother option is to say:\n\\[X(\\omega) = \\begin{cases}\n\\langle 1, 1 \\rangle & \\text{if } \\omega \\in F_\\text{[+acc]} \\land \\omega \\in F_\\text{[-acc]}\\\\\n\\langle 1, 0 \\rangle & \\text{if } \\omega \\in F_\\text{[+acc]} \\land \\omega \\not\\in F_\\text{[-acc]}\\\\\n\\langle 0, 1 \\rangle & \\text{otherwise}\\\\\n\\end{cases}\\]\n\n\n\nI’ll follow the convention of denoting the PMF of a particular kind of distribution using (usually shortened versions of) the distribution’s name, with the parameters following a semicolon.4\n\\[\\text{Cat}(x; \\boldsymbol\\theta) = p_X(x) = \\mathbb{P}(X = x) = \\mathbb{P}(\\{\\omega \\in \\Omega \\mid X(\\omega) = x\\}) = \\theta_x\\]\nTo express the above equivalences, I’ll often write:\n\\[X \\sim \\text{Cat}(\\boldsymbol{\\theta})\\]\nThis statement is read “\\(X\\) is distributed categorical with parameters \\(\\boldsymbol{\\theta}\\).”\nSo then the Bernoulli distribution would just be:\n\\[\\text{Bern}(x; \\pi) = \\begin{cases}\\pi & \\text{if } x = 1\\\\1 - \\pi & \\text{if } x = 0\\end{cases}\\]\nAnd if a random variable \\(X\\) is distributed Bernoulli with parameter \\(\\pi\\), we would write:\n\\[X \\sim \\text{Bern}(\\pi)\\]\nIt’s sometimes useful to write the PMF for the categorical and Bernoulli distributions as:\n\\[\\text{Cat}(x; \\boldsymbol\\theta) = \\prod_{i \\in V(\\Omega)} \\theta_i^{1_{\\{x\\}}[i]}\\]\n\\[\\text{Bern}(x; \\pi) = \\pi^{x}(1-\\pi)^{1-x}\\]\nwhere\n\\[1_A[x] = \\begin{cases}1 & \\text{if } x \\in A\\\\ 0 & \\text{otherwise}\\\\ \\end{cases}\\]\nIn an abuse of notation, I will sometimes write:\n\\[\\text{Cat}(x; \\boldsymbol\\theta) = \\prod_{i \\in V(\\Omega)} \\theta_i^{1_{x}[i]}\\]\nCategorical and Bernoulli distributions won’t be the only finite distributions we work with, but they will be the most common.\n\n\nCountably infinite distributions\nWhen there are a countably infinite number of values that a random variable can take, as in the example of string length \\(L\\) above, the probability of each possibility cannot simply be listed: we need some way of computing it for any value.\nHowever we compute these values, they must sum to one as required by the assumption of unit measure: \\(\\mathbb{P}(\\Omega) = 1\\). Since \\(\\mathbb{P}(\\Omega) = \\sum_{x \\in X(\\Omega)} p_X(x)\\), another way of stating this requirement is to say that the series \\(\\sum_{x \\in X(\\Omega)} p_X(x)\\) must converge to 1.\nOne example of such a series is a geometric series, such as \\(\\sum_{k=1}^\\infty \\frac{1}{2^k} = \\frac{1}{2} + \\frac{1}{4} + \\frac{1}{8} + \\ldots = 1\\).\n\nclass parameterless_geometric_gen(rv_discrete):\n    \"A special case of the geometric distribution without parameters\"\n    def _pmf(self, k):\n        return 2.0 ** -(k+1)\n\nparameterless_geometric = parameterless_geometric_gen(name=\"parameterless_geometric\")\n\nThis series gives us our first example of a probability distribution with infinite support–i.e. one that assigns a non-zero probability to an infinite (but countable) number of values of a random variable. So for instance, if we are considering our random variable \\(L\\) mapping strings to their lengths, \\(p_X(k) = \\frac{1}{2^k}\\) is a possible PMF for \\(L\\).5\n\n\nCode\nk = arange(10)\n\nax = subplot()\nax.plot(k, parameterless_geometric.pmf(k), 'ro', ms=12, mec='r')\nax.vlines(k, 0, parameterless_geometric.pmf(k), colors='r', lw=4)\nax.vlines(k, 0, parameterless_geometric.pmf(k), colors='r', lw=4)\nax.set_ylabel(\"Probability\")\n_ = ax.set_title(\"PMF of distribution defined by geometric series\")\n\n\n\n\n\nAs it stands, this distribution has no parameters, meaning that we have no control over how quickly the probabilities drop off. The geometric distribution provides us this control using a parameter to \\(\\pi \\in (0, 1]\\):\n\\[\\text{Geom}(k; \\pi) = (1-\\pi)^k\\pi\\]\n\nfrom scipy.stats import geom\n\nWhen \\(\\pi = \\frac{1}{2}\\), we get exactly the distribution above.\n\n\nCode\np = 0.5\n\nax = subplot()\nax.plot(k, geom(p).pmf(k+1), 'ro', ms=12, mec='r')\nax.vlines(k, 0, geom(p).pmf(k+1), colors='r', lw=4)\nax.set_ylabel(\"Probability\")\n_ = ax.set_title(f\"PMF of Geometric({p}) distribution\")\n\n\n\n\n\nAs \\(\\pi \\rightarrow 0\\), the distribution flattens out (or becomes denser).\n\n\nCode\np = 0.1\n\nax = subplot()\nax.plot(k, geom(p).pmf(k+1), 'ro', ms=12, mec='r')\nax.vlines(k, 0, geom(p).pmf(k+1), colors='r', lw=4)\nax.set_ylabel(\"Probability\")\n_ = ax.set_title(f\"PMF of Geometric({p}) distribution\")\n\n\n\n\n\nAnd as \\(\\pi \\rightarrow 1\\), it becomes sharper (or sparser).\n\n\nCode\np = 0.9\n\nax = subplot()\nax.plot(k, geom(p).pmf(k+1), 'ro', ms=12, mec='r')\nax.vlines(k, 0, geom(p).pmf(k+1), colors='r', lw=4)\nax.set_ylabel(\"Probability\")\n_ = ax.set_title(f\"PMF of Geometric({p}) distribution\")\n\n\n\n\n\nAt this point, it’s useful to pause for a moment to think about what exactly a parameter like \\(\\pi\\) is. I said above that random variables and probability distributions together provide a way of classifying probability spaces: in saying that \\(p_X(k) = (1-\\pi)^k\\pi\\) we are describing \\(\\mathbb{P}: \\mathcal{F} \\rightarrow \\mathbb{R}_+\\) by using \\(X\\) to abstract across whatever the underlying measurable space \\(\\langle \\Omega, \\mathcal{F} \\rangle\\) is. The distribution gives you the form of that description; the parameter \\(\\pi\\) gives the content of the description. Because the use of \\(X\\) is always implied, unless it really matters, I’m going to start dropping \\(X\\) from \\(p_X\\) unless I’m emphasizing the random variable in some way.\nThe \\(\\pi\\) parameter of a geometric distribution allows us to describe distributions that have a very particular shape–namely, ones where \\(\\forall k \\in \\mathbb{N}: p(k) &gt; p(k + 1)\\). But this isn’t always a good way of describing a particular distribution. For instance, for our string-length variable \\(L\\), it’s probably a pretty bad description regardless of what particular distribution on string lengths (type or token) we’re describing because 1 grapheme/phoneme words just aren’t more frequent than two grapheme/phoneme words. This point can be seen if we look at the distribution of word lengths at the type level in the CMU Pronouncing Dictionary, which contains phonemic transcriptions of English words.\n\nfrom urllib.request import urlopen\n\ncmudict_url = \"http://svn.code.sf.net/p/cmusphinx/code/trunk/cmudict/cmudict-0.7b\"\n\nwith urlopen(cmudict_url) as cmudict:\n    words = [\n        line.split()[1:] for line in cmudict if line[0] != 59\n    ]\n\n\n\nCode\nax = subplot()\n\nax.hist([len(w) for w in words], bins=32, density=True)\n\nax.set_title(\"Distribution of word length in phonemes\")\nax.set_xlabel(\"Word length in phonemes\")\n_ = ax.set_ylabel(\"Relative frequency\")\n\n\n\n\n\nOne such distribution that give us more flexibility in this respect is the negative binomial distribution, which is a very useful for modeling token frequency in text (Church and Gale 1995). This distribution effectively generalizes the geometric by allowing us to control the exponent on \\(\\pi\\) with a new parameter \\(r\\).\n\\[\\text{NegBin}(k; \\pi, r) = {k+r-1 \\choose r-1}(1-\\pi)^{k}\\pi^{r}\\]\n\nfrom scipy.stats import nbinom\n\nThis added flexibility in turn requires us to add an additional term \\({k+r-1 \\choose r-1} = \\frac{(k+r-1)!}{(r-1)!\\,(k)!}\\) that ensures that the series \\(\\sum_{k=0}^\\infty \\text{NegBin}(k; \\pi, r)\\) converges to \\(1\\). The pieces of this term that do not include the value we’re computing the probability of–i.e. \\(\\frac{1}{(r-1)!}\\)–are often called the normalizing constant. We will make extensive use of this concept as the course moves forward.\nWhen \\(r = 1\\), we of course just get the geometric distribution. As such, if we keep \\(r = 1\\), manipulating \\(\\pi\\) will have the same effect we saw above.\n\np = 0.5\nr = 1\n\n\n\nCode\nax = subplot()\nax.plot(k, nbinom(r, p).pmf(k+1), 'ro', ms=12, mec='r')\nax.vlines(k, 0, nbinom(r, p).pmf(k+1), colors='r', lw=4)\nax.set_ylabel(\"Probability\")\n_ = ax.set_title(f\"PMF of NegBin({p}, {r}) distribution\")\n\n\n\n\n\nAs \\(r\\) grows, though, we get very different behavior: \\(p(k)\\) is no longer always greater than \\(p(k + 1)\\). Another way of saying this is that we can use \\(r\\) to shift the probability mass rightward.\n\np = 0.5\nr = 5\n\n\n\nCode\nax = subplot()\nax.plot(k, nbinom(r, p).pmf(k+1), 'ro', ms=12, mec='r')\nax.vlines(k, 0, nbinom(r, p).pmf(k+1), colors='r', lw=4)\nax.set_ylabel(\"Probability\")\n_ = ax.set_title(f\"PMF of NegBin({p}, {r}) distribution\")\n\n\n\n\n\nThe mass-shifting effect is modulated by \\(\\pi\\): it accelerates with small \\(\\pi\\)…\n\np = 0.1\nr = 5\n\n\n\nCode\nax = subplot()\nax.plot(k, nbinom(r, p).pmf(k+1), 'ro', ms=12, mec='r')\nax.vlines(k, 0, nbinom(r, p).pmf(k+1), colors='r', lw=4)\nax.set_ylabel(\"Probability\")\n_ = ax.set_title(f\"PMF of NegBin({p}, {r}) distribution\")\n\n\n\n\n\n…but decelerates with large \\(\\pi\\).\n\np = 0.9\nr = 5\n\n\n\nCode\nax = subplot()\nax.plot(k, nbinom(r, p).pmf(k+1), 'ro', ms=12, mec='r')\nax.vlines(k, 0, nbinom(r, p).pmf(k+1), colors='r', lw=4)\nax.set_ylabel(\"Probability\")\n_ = ax.set_title(f\"PMF of NegBin({p}, {r}) distribution\")\n\n\n\n\n\n\np = 0.9\nr = 40\n\n\n\nCode\nax = subplot()\nax.plot(k, nbinom(r, p).pmf(k+1), 'ro', ms=12, mec='r')\nax.vlines(k, 0, nbinom(r, p).pmf(k+1), colors='r', lw=4)\nax.set_ylabel(\"Probability\")\n_ = ax.set_title(f\"PMF of NegBin({p}, {r}) distribution\")\n\n\n\n\n\nWe won’t talk about how to fit a distribution to some data until later, when we talk about parameter estimation; but the negative binomial distribution can provide a reasonably good description of the empirical distribution of word lengths. One way to visualize this is to compare the empirical CDF with the CDF of the best fitting negative binomial.\n\nfrom numpy import ones, exp, round, mgrid\n\nfrom statsmodels.distributions.empirical_distribution import ECDF\nfrom statsmodels.discrete.discrete_model import NegativeBinomial\n\necdf = ECDF([len(w) for w in words])\nnegbin_fit = NegativeBinomial([len(w) for w in words], ones(len(words))).fit()\n\np = 1/exp(1+negbin_fit.params[0]*negbin_fit.params[1])\nr = exp(negbin_fit.params[0])*p/(1-p)\n\nprint(f\"p = {round(p, 2)}, r = {round(r, 2)}\")\n\nOptimization terminated successfully.\n         Current function value: 2.180477\n         Iterations: 22\n         Function evaluations: 24\n         Gradient evaluations: 24\np = 0.37, r = 3.71\n\n\n\n\nCode\nk = arange(30)\n\nax = subplot()\nax.plot(mgrid[1:30:0.1], ecdf(mgrid[1:30:0.1]), label=\"Empirical CDF\")\nax.plot(mgrid[1:30:0.1], nbinom(r, p).cdf(mgrid[1:30:0.1]), label=f\"Estimated CDF\\nNegBin({round(p, 2)}, {round(r, 2)})\")\nax.legend()\nax.set_title(\"CDF of word length in phonemes\")\nax.set_xlabel(\"Word length in phonemes\")\n_ = ax.set_ylabel(\"Cumulative relative frequency/probability\")\n\n\n\n\n\nA limiting case of the negative binomial distribution that you may be familiar with is the Poisson distribution.\n\\[\\text{Pois}(k; \\lambda) = \\frac{\\lambda^k\\exp(-\\lambda)}{k!}\\]\nThe Poisson distribution arises as \\(\\text{Pois}(k; \\lambda) = \\lim_{r \\rightarrow \\infty} \\text{NegBin} \\left(k; r, \\frac{\\lambda}{r + \\lambda}\\right)\\).\n\n\n\nContinuous probability distributions\nOnce we move to working with random variables that have an uncountable number of values–as in the case of our formant value example above, where \\(X: \\mathbb{R}_+^2 \\rightarrow \\mathbb{R}^2\\) is the identity function–we can no longer assign a non-zero probability to every value that variable takes. The intuition for why this is is that there are just too many numbers (e.g. too many possible formant values); and if we assigned non-zero probability to more than countably many of them, we’d end up with a sum across those numbers that doesn’t satisfy the assumption of \\(\\sigma\\)-additivity.6\nThis fact is why we require the event space for an uncountable sample space to be a Borel \\(\\sigma\\)-algebra. Remember that a Borel \\(\\sigma\\)-algebra for the reals will contain all the intervals we might want but not single real numbers. This assumption about the event space in turn means that we don’t need to worry about assigning non-zero probability to uncountably many values: indeed, we will always assign exactly zero probability to any particular real. (Well. Most of the time.) To restate this: every possibility in a real-valued sample space has probability zero: \\(\\forall x \\in \\Omega: \\mathbb{P}(x) = 0\\). This in turn means that a PMF isn’t going to be useful here.\nWhat we work with instead is a probability density function (PDF) \\(f_X: \\Omega \\rightarrow \\mathbb{R}_+\\). Note that the PMF, which I will usually denote \\(p\\) or \\(p_X\\), and the PDF, which I will usually denote \\(f\\) or \\(f_X\\), have the same function signature. It is important to note that they provide very different information: where the PMF tells you the probability of a particular possibility, the PDF does not, though it can be used to compute a probability: specifically, the probability of \\(X\\) taking on a value in some set. So it can be used to tell you \\(\\mathbb{P}(X \\in A)\\):\n\\[\\mathbb{P}(X \\in A) = \\int_A f_X(x) \\, \\mathrm{d}x\\]\nWhen the codomain of \\(X\\) is a single value (rather than a vector), we call the distribution univariate; otherwise, we call it multivariate. We can express univariate continuous distributions as:\n\\[\\mathbb{P}(a &lt; X &lt; b) = \\int_a^b f_X(x) \\, \\mathrm{d}x\\]\nThis expressions is a special case of the first:\n\\[\\mathbb{P}(a &lt; X &lt; b) = \\mathbb{P}(X \\in (a, b)) = \\int_{(a, b)} f_X(x) \\, \\mathrm{d}x\\]\nWe can in turn express the cumulative distribution function \\(F_X\\) in a similar way, but without a lower bound:\n\\[F_X(b) = \\mathbb{P}(X &lt; b) = \\int_{-\\infty}^b f_X(x) \\, \\mathrm{d}x\\]\nIt can sometimes be useful to express \\(\\mathbb{P}(a &lt; X &lt; b)\\) and \\(\\mathbb{P}(X &gt; x)\\) in terms of \\(F_X\\):\n\\[\\mathbb{P}(a &lt; X &lt; b) = F_X(b) - F_X(a)\\] \\[\\mathbb{P}(X &gt; x) = 1 - F_X(x)\\]\n\nUnivariate continuous uniform distribution\nThe simplest example of a continuous distribution is the univariate uniform distribution, which is parameterized by an infimum \\(a\\) and a supremum \\(b\\) and has a PDF:\n\\[\\mathcal{U}(x; a, b) = \\begin{cases}\\frac{1}{b - a} & \\text{if } x \\in [a, b] \\\\ 0 & \\text{otherwise}\\end{cases}\\]\n\nfrom scipy.stats import uniform\n\n\n\nCode\nu = uniform(0, 1)\n\nax = subplot()\n\nax.plot(\n    mgrid[-1:2:0.01], \n    u.pdf(mgrid[-1:2:0.01])\n)\nax.set_title(r\"PDF of $\\mathcal{U}(0, 1)$\")\n_ = ax.set_ylabel(\"Density\")\n\n\n\n\n\nYou’ll note that I’m using \\(\\mathcal{U}\\)–rather than something like \\(\\text{Unif}\\)–for the name of the PDF. Certain distributions, including the continuous uniform and the normal or gaussian, canonically have such names.\nYou’ll also note that \\(\\mathcal{U}(x; a, b)\\) is the PDF, not the PMF. This notational convention is common: for discrete distributions like the negative binomial \\(\\text{NegBin}\\) will be used to denote the PMF (or to express that a random variable has a particular distribution), while for continuous distributions like the continuous uniform, \\(\\mathcal{U}\\) will be used to denote the PDF (or to express that a random variable has a particular distribution).\nRemember that the PDF does not give you the probability of a value: the probability of a (continuous) uniformly distributed value \\(x\\) is not \\(\\frac{1}{b - a}\\), it is \\(0\\); \\(\\frac{1}{b - a}\\) is the value of the density at \\(x\\). This means that:\n\\[\\mathbb{P}(x &lt; X &lt; y) = \\int_x^y f_X(z)\\,\\mathrm{d}z = \\frac{\\min(y, b) - \\max(x, a)}{b - a}\\]\nwhere \\(a = \\inf \\{x \\in X(\\Omega) \\mid f_X(x) &gt; 0\\}\\) and \\(b = \\sup \\{x \\in X(\\Omega) \\mid f_X(x) &gt; 0\\}\\). So then, if \\(a=0\\) and \\(b=1\\), \\(\\mathbb{P}(0.25 &lt; X &lt; 0.75) = 0.5\\). This can be visualized by filling in the area we’re integrating.\n\n\nCode\nax = subplot()\n\nax.plot(\n    mgrid[-1:2:0.01], \n    u.pdf(mgrid[-1:2:0.01])\n)\n_ = ax.fill_between(\n    mgrid[0.25:0.75:0.01], \n    u.pdf(mgrid[0.25:0.75:0.01])\n)\nax.set_title(r\"Probability mass of (0.25, 0.75) under PDF of $\\mathcal{U}(0, 1)$\")\n_ = ax.set_ylabel(\"Density\")\n\n\n\n\n\nRather than define parameters relative to \\(X\\) every time we want to specify a probability, I’ll often write:\n\\[\\mathbb{P}(x &lt; X &lt; y; a, b) = \\int_x^y f_X(z)\\,\\mathrm{d}z = \\frac{\\min(y, b) - \\max(x, a)}{b - a}\\]\nOr:\n\\[\\mathbb{P}(x &lt; X &lt; y \\mid a, b) = \\int_x^y f_X(z)\\,\\mathrm{d}z = \\frac{\\min(y, b) - \\max(x, a)}{b - a}\\]\nWhether I use the semicolon or pipe will depend on context, as we’ll discuss below: it basically comes down to whether I’m assuming that \\(a\\) and \\(b\\) are the values of some underlying random variables–in which case, \\(\\mathbb{P}(x &lt; X &lt; y \\mid a, b)\\) is really shorthand for something like \\(\\mathbb{P}(x &lt; X &lt; y \\mid A=a, B=b)\\)–or whether they’re fixed values given by some oracle.\nThe CDF \\(F_X\\) for a uniform random variable \\(X\\) is then:\n\\[F_X(x) = \\mathbb{P}(X &lt; x; a, b) = \\int_{-\\infty}^x f_X(z)\\,\\mathrm{d}z = \\frac{\\min(\\max(x, a), b) - a}{b - a}\\]\n\n\nCode\nax = subplot()\n\nax.plot(\n    mgrid[-1:2:0.01], \n    uniform(0, 1).cdf(mgrid[-1:2:0.01])\n)\n\nax.set_title(r\"CDF of $\\mathcal{U}(0, 1)$\")\n_ = ax.set_ylabel(r\"Probability $\\mathbb{P}(X &lt; x)$\")\n\n\n\n\n\n\n\nBeta distribution\nLike the geometric distribution, the continuous uniform distribution doesn’t give us all the control we might want over the shape of the distribution. We can gain that additional control using a Beta distribution.\n\\[\\text{Beta}(x; \\alpha, \\beta) = \\begin{cases}\\frac{x^{\\alpha-1}(1-x)^{\\beta-1}} {\\mathrm{B}(\\alpha,\\beta)} & \\text{if } x \\in (0, 1)\\\\0 & \\text{otherwise}\\end{cases}\\]\nwhere \\(\\mathrm{B}(\\alpha,\\beta) = \\frac {\\Gamma (\\alpha)\\Gamma (\\beta)}{\\Gamma (\\alpha+\\beta)}\\), the normalizing constant, is known as the beta function and \\(\\Gamma\\) (the gamma function) generalizes the factorial function to real numbers: \\(\\Gamma(x+1) = x\\Gamma(x) = x!\\) for all positive natural numbers; and more generally, for positive really numbers \\(\\Gamma(x) = \\int_0^\\infty t^{x-1} e^{-t}\\,\\mathrm{d}t\\).\n\nfrom scipy.stats import beta\n\nThe beta distribution can be thought of as a generalization of the uniform distribution \\(\\mathcal{U}(0, 1)\\), since it is equivalent when \\(\\alpha = \\beta = 1\\).\n\na = 1\nb = 1\n\n\n\nCode\nax = subplot()\n\nax.plot(\n    mgrid[-1:2:0.01], \n    beta(a, b).pdf(mgrid[-1:2:0.01])\n)\n\nax.set_title(f\"PDF of Beta({a}, {b})\")\n_ = ax.set_ylabel(\"Density\")\n\n\n\n\n\nDefined this way, the beta distribution has support on (assigns non-zero values) only intervals in \\((0, 1)\\), but if we ever need support over an arbitrary finite interval \\((a, b)\\), we can simply add the bounds \\(a\\) and \\(b\\) to the parameterization.\n\\[\\text{Beta}(x; \\alpha, \\beta, a, b) = \\begin{cases}\\frac{\\left(\\frac{x - a}{b - a}\\right)^{\\alpha-1}\\left(1-\\frac{x - a}{b - a}\\right)^{\\beta-1}} {\\mathrm{B}(\\alpha,\\beta)} & \\text{if } x \\in (a, b)\\\\0 & \\text{otherwise}\\end{cases}\\]\nThis definition makes the beta distribution a true generalization of \\(\\mathcal{U}(a, b) = \\text{Beta}(1, 1, a, b)\\). We’ll mainly work with the two-parameter version for the sake of simplicity, and because for most use cases, we actually only need support on \\((0, 1)\\).\nManipulating the shape parameters \\(\\alpha\\) and \\(\\beta\\) introduces bias toward \\(0\\), \\(1\\), or \\(\\frac{\\alpha}{\\alpha + \\beta}\\). When \\(\\alpha = \\beta &gt; 1\\), we get more and more density closer to \\(\\frac{\\alpha}{\\alpha + \\beta} = 0.5\\). We say that these distributions are symmetric (and dense, for reasons I will discuss in a second).\n\ndense_symmetric_beta_params = [\n    (3, 3),\n    (5, 5),\n    (10, 10)\n]\n\n\n\nCode\nax = subplot()\n\nfor a, b in dense_symmetric_beta_params:\n    ax.plot(\n        mgrid[0:1:0.01], \n        beta(a, b).pdf(mgrid[0:1:0.01]),\n        label=f\"Beta({a}, {b})\"\n    )\n\nax.legend()\nax.set_title(r\"PDF of dense symmetric Beta\")\n_ = ax.set_ylabel(\"Density\")\n\n\n\n\n\nIf we increase \\(\\alpha\\) relative to \\(\\beta &gt; 1\\), we shift this density to the right; and if we increase \\(\\beta\\) relative to \\(\\alpha &gt; 1\\), we shift the density toward the left. We say that these are asymmetric.\n\ndense_asymmetric_beta_params = [\n    (5, 3),\n    (3, 5)\n]\n\n\n\nCode\nax = subplot()\n\nfor a, b in dense_asymmetric_beta_params:\n    ax.plot(\n        mgrid[0:1:0.01], \n        beta(a, b).pdf(mgrid[0:1:0.01]),\n        label=f\"Beta({a}, {b})\"\n    )\n\nax.legend()\nax.set_title(r\"PDF of dense asymmetric Beta\")\n_ = ax.set_ylabel(\"Density\")\n\n\n\n\n\nIn both cases, we have a bias against values nearer to \\(0\\) and \\(1\\) in proportion to how much greater than one the smaller of \\(\\alpha\\) and \\(\\beta\\) are.\nWhen either \\(\\alpha &gt; 1 \\geq \\beta\\) or \\(\\alpha \\leq 1 &lt; \\beta\\), we get bias toward values nearer to \\(1\\) or \\(0\\), respectively. We say that these distributions are sparse (in contrast to dense), but like the other beta distributions we’ve seen–besides \\(\\text{Beta}(1, 1)\\)–they are unimodal.\n\nsparse_unimodal_beta_params = [\n    (5, 1),\n    (1, 5)\n]\n\n\n\nCode\nax = subplot()\n\nfor a, b in sparse_unimodal_beta_params:\n    ax.plot(\n        mgrid[0:1:0.01], \n        beta(a, b).pdf(mgrid[0:1:0.01]),\n        label=f\"Beta({a}, {b})\"\n    )\n\nax.legend()\nax.set_title(r\"PDF of sparse unimodal Beta\")\n_ = ax.set_ylabel(\"Density\")\n\n\n\n\n\nWhen \\(\\alpha, \\beta &lt; 1\\), we get a bias toward values near both \\(0\\) and \\(1\\) with more density shifted toward \\(1\\) if \\(\\alpha\\) is larger and more density shifted toward \\(0\\) if \\(\\beta\\) is larger. These distributions are sparse and bimodal.\n\nsparse_bimodal_beta_params = [\n    (0.5, 0.5),\n    (0.6, 0.4),\n    (0.4, 0.6),\n]\n\n\n\nCode\nax = subplot()\n\nfor a, b in sparse_bimodal_beta_params:\n    ax.plot(\n        mgrid[0:1:0.01], \n        beta(a, b).pdf(mgrid[0:1:0.01]),\n        label=f\"Beta({a}, {b})\"\n    )\n\nax.legend()\nax.set_title(r\"PDF of sparse bimodal Beta\")\n_ = ax.set_ylabel(\"Density\")\n\n\n\n\n\n\n\nUnivariate Gaussian distribution\nOne continuous distribution we will work with extensively is the Gaussian or normal distribution.\n\\[\\mathcal{N}(x; \\mu, \\sigma^2) = \\frac{1}{\\sigma\\sqrt{2\\pi}}\\exp\\left(-\\frac{(x-\\mu)^2}{2\\sigma^2}\\right)\\]\nwhere \\(\\mu\\) is referred to as the mean and \\(\\sigma^2\\) as the variance.\n\nfrom scipy.stats import norm\n\n\n\nCode\nax = subplot()\n\nax.plot(mgrid[-3:3:0.01], norm(0, 1).pdf(mgrid[-3:3:0.01]))\n\nax.set_title(r\"PDF of $\\mathcal{N}(0, 1)$\")\n_ = ax.set_ylabel(\"Density\")\n\n\n\n\n\nThe mean controls the position and the variance controls the width–specifically, the wideness.\n\nnormal_params = [\n    (0, 1),\n    (1, 1),\n    (0, 2)\n]\n\n\n\nCode\nax = subplot()\n\nfor a, b in normal_params:\n    ax.plot(\n        mgrid[-3:3:0.01], \n        norm(a, b).pdf(mgrid[-3:3:0.01]),\n        label=r\"$\\mathcal{N}(\"+str(a)+\", \"+str(b)+\")$\"\n    )\n\nax.legend()\nax.set_title(r\"PDF of Guassian\")\n_ = ax.set_ylabel(\"Density\")\n\n\n\n\n\nWe say that the distribution is standard normal if the mean \\(\\mu = 0\\) and the variance \\(\\sigma^2 = 1\\).\nAs with all continuous distributions, we can compute the cumulative distribution function as:\n\\[\\Phi(x) = \\int_{-\\infty}^x \\mathcal{N}(y; \\mu, \\sigma^2)\\,\\mathrm{d}y\\]\nwhere \\(\\Phi\\) is a common notation for \\(F_X\\), when \\(X\\) is a Gaussian random variable.\n\n\nCode\nax = subplot()\n\nax.plot(mgrid[-3:3:0.01], norm(0, 1).cdf(mgrid[-3:3:0.01]))\n\nax.set_title(r\"CDF of $\\mathcal{N}(0, 1)$\")\n_ = ax.set_ylabel(\"Probability\")\n\n\n\n\n\n\\(\\Phi\\) is often referred to as sigmoidal or a sigmoid for its S shape. These sorts of functions will be very important moving forward–most proximally because they play a role in modeling judgments provided through instruments like Likert (1-7) scales and slider scales.\nThe Gaussian CDF is only one of many continuous CDFs with this shape. The beta CDF is also sigmoidal when \\(\\alpha, \\beta \\neq 1\\).\n\n\nCode\nax = subplot()\n\nax.plot(mgrid[0:1:0.01], beta(5, 5).cdf(mgrid[0:1:0.01]))\n\nax.set_title(r\"CDF of Beta(5, 5)\")\n_ = ax.set_ylabel(\"Probability\")"
  },
  {
    "objectID": "foundational-concepts-in-probability-and-statistics/random-variables-and-probability-distributions.html#some-more-useful-definitions",
    "href": "foundational-concepts-in-probability-and-statistics/random-variables-and-probability-distributions.html#some-more-useful-definitions",
    "title": "Random variables and probability distributions",
    "section": "Some more useful definitions",
    "text": "Some more useful definitions\nSince random variables are required to preserve the structure of the event space, the definitions of joint probability, conditional probability, and independence can all be extended to them. The introduction of random variables and probability distributions also allows us to define a notion of expected value.\n\nJoint probability\nDefining the joint probability of random variables \\(X\\) and \\(Y\\) with underlying probabiliy spaces \\(\\langle \\Omega_X, \\mathcal{F}_X, \\mathbb{P}_X \\rangle\\) and \\(\\langle \\Omega_Y, \\mathcal{F}_Y, \\mathbb{P}_Y \\rangle\\) requires us to define a new probability space \\(\\langle \\Omega_X \\times \\Omega_Y, \\mathcal{F}_{X, Y}, \\mathbb{P}_{X, Y} \\rangle\\), where \\(\\mathcal{F}_{X, Y}\\) is the product \\(\\sigma\\)-algebra \\(\\sigma\\left(\\left\\{E_X \\times E_Y \\mid E_X \\in \\mathcal{F}_X, E_Y \\in \\mathcal{F}_Y\\right\\}\\right)\\) on \\(\\Omega_X \\times \\Omega_Y\\). We then define the joint distribution \\(p_{X, Y}\\) in terms of \\(X'(\\omega_X, \\omega_Y) = X(\\omega_X)\\) and \\(Y'(\\omega_X, \\omega_Y) = Y(\\omega_Y)\\):\n\\[\\begin{align*}p_{X, Y}(x, y) &= \\mathbb{P}_{X, Y}(X' = x, Y' = y)\\\\ &= \\mathbb{P}_{X, Y}\\left(\\{\\langle\\omega_X, \\omega_Y\\rangle \\mid X'(\\langle\\omega_X, \\omega_Y\\rangle) = x\\}, \\{\\langle\\omega_X, \\omega_Y\\rangle \\mid Y'(\\langle\\omega_X, \\omega_Y\\rangle) = y\\}\\right)\\\\ &= \\mathbb{P}_{X, Y}\\left(\\{\\langle\\omega_X, \\omega_Y\\rangle \\mid X'(\\langle\\omega_X, \\omega_Y\\rangle) = x\\} \\cap \\{\\langle\\omega_X, \\omega_Y\\rangle \\mid Y'(\\langle\\omega_X, \\omega_Y\\rangle) = y\\}\\right)\\\\ &= \\mathbb{P}_{X, Y}\\left(\\{\\langle\\omega_X, \\omega_Y\\rangle \\mid X'(\\langle\\omega_X, \\omega_Y\\rangle) = x \\land Y'(\\langle\\omega_X, \\omega_Y\\rangle) = y\\}\\right)\\\\ &= \\mathbb{P}_{X, Y}\\left(\\{\\langle\\omega_X, \\omega_Y\\rangle \\mid X(\\omega_X) = x \\land Y'(\\omega_Y) = y\\}\\right)\\end{align*}\\]\nwhere \\(p_{X, Y}\\) (and thus \\(\\mathbb{P}_{X, Y}\\)) must be such that the marginal distributions \\(p_X\\) and \\(p_Y\\) satisfy:\n\\[p_X(x) = \\begin{cases}\\sum_{y \\in Y(\\Omega_Y)} p_{X, Y}(x, y) & \\text{if $Y$ is discrete} \\\\ \\int_{Y(\\Omega_Y)} p_{X, Y}(x, y)\\,\\mathrm{d}y & \\text{if $Y$ is continuous} \\\\ \\end{cases}\\]\n\\[p_Y(y) = \\begin{cases}\\sum_{x \\in X(\\Omega_X)} p_{X, Y}(x, y) & \\text{if $X$ is discrete} \\\\ \\int_{X(\\Omega_X)} p_{X, Y}(x, y)\\,\\mathrm{d}x & \\text{if $X$ is continuous} \\\\ \\end{cases}\\]\nI’ll sometimes simply write \\(p(x, y)\\) (with \\(x\\) and \\(y\\) values of implicit random variables) instead of \\(p_{X, Y}(x, y)\\). I’ll often use \\(p\\) here, even when both \\(X\\) and \\(Y\\) are continuous. I’ll also often drop all but the variable of summation/integration from the sum or integral over the range of a random variable. So I’ll write things like…\n\\[p(x) = \\begin{cases}\\sum_{y} p(x, y) & \\text{if $Y$ is discrete} \\\\ \\int p(x, y)\\,\\mathrm{d}y & \\text{if $Y$ is continuous} \\\\ \\end{cases}\\]\n…rather than…\n\\[p_X(x) = \\begin{cases}\\sum_{y \\in Y(\\Omega_Y)} p_{X, Y}(x, y) & \\text{if $Y$ is discrete} \\\\ \\int_{Y(\\Omega_Y)} p_{X, Y}(x, y)\\,\\mathrm{d}y & \\text{if $Y$ is continuous} \\\\ \\end{cases}\\]\nJust remember that \\(p_{X, Y}\\) is a different function from \\(p_X\\) or \\(p_Y\\)–even when I write \\(p(x, y)\\), \\(p(x)\\), or \\(p(y)\\), rather than the more verbose \\(p_{X, Y}(x, y)\\), \\(p_X(x)\\), or \\(p_Y(y)\\).\n\n\nConditional probability\nThe conditional probability of a random variable \\(X\\) given a random variable \\(Y\\) is defined in terms of their joint probability and the marginal probability of \\(Y\\):\n\\[p_{X \\mid Y}(x \\mid y) \\equiv \\frac{p_{X, Y}(x, y)}{p_{Y}(y)} = \\begin{cases}\\frac{p_{X, Y}(x, y)}{\\sum_{x'} p_{X, Y}(x', y)} & \\text{if $X$ is discrete} \\\\ \\frac{p_{X, Y}(x, y)}{\\int p_{X, Y}(x', y)\\,\\mathrm{d}x'} & \\text{if $X$ is continuous} \\\\ \\end{cases}\\]\n\n\nIndependence\nWe can extend the definition of independent events to that of independent random variables by saying that two random variables \\(X\\) and \\(Y\\) are independent if and only if:\n\\[p_{X \\mid Y}(x \\mid y) = p_X(x)\\] \\[p_{Y \\mid X}(y \\mid x) = p_Y(y)\\]\nBy the same reasoning as for independent events, this in turn implies that:\n\\[p_{X, Y}(x, y) = p_X(x)p_Y(y)\\]\nWe say that two random variables \\(X\\) and \\(Y\\) are conditionally independent given another \\(Z\\) if and only if:\n\\[p_{X \\mid Y, Z}(x \\mid y, z) = p_{X \\mid Z}(x \\mid z)\\] \\[p_{Y \\mid X, Z}(y \\mid x, z) = p_{Y \\mid Z}(y \\mid z)\\]\nAs before, this implies that:\n\\[p_{X, Y \\mid Z}(x, y \\mid z) = p_{X \\mid Z}(x \\mid z)p_{Y \\mid Z}(y \\mid z)\\]\nNote that being conditionally independent is not the same as being independent.\n\n\nExpected values\nThe expected value \\(\\mathbb{E}[X]\\) of a random variable \\(X\\) can be thought of as a kind of weighted average over the values of that variable. When the variable is discrete, this average is computed using a sum.\n\\[\\mathbb{E}[X] \\equiv \\sum_{x} x \\cdot p_X(x)\\]\nWhen the variable is continuous, this average is computed using an integral.\n\\[\\mathbb{E}[X] \\equiv \\int x \\cdot f_X(x) \\, \\mathrm{d}x\\]\nThe expected value of a random variable \\(X\\) is often referred to as the mean of \\(X\\). Given a PMF or PDF of a probability distribution, we can often (though not always) compute the mean analytically in terms of the distribution’s parameters. For instance, the mean of a random variable \\(X \\sim \\text{Geom}(\\pi)\\) is:\n\\[\\mathbb{E}[X] = \\sum_{k=0}^\\infty k \\cdot (1-\\pi)^k\\pi = \\frac{1-\\pi}{\\pi}\\]\nAnd the mean of a random variable \\(X \\sim \\text{Beta}(\\alpha, \\beta)\\) is:\n\\[\\mathbb{E}[X] = \\int_0^1 x \\cdot \\frac{x^{\\alpha - 1}(1-x)^{\\beta-1}}{\\text{B}(\\alpha, \\beta)} \\, \\mathrm{d}x = \\frac{\\alpha}{\\alpha + \\beta}\\]\nThe mean of a Cauchy-distributed random variable \\(X \\sim \\text{Cauchy}(x_0, \\gamma)\\) is one instance of a random variable where \\(\\mathbb{E}[X]\\) is not defined. This fact is not immediately obvious from its PDF.\n\\[\\text{Cauchy}(x; x_{0},\\gamma )={\\frac {1}{\\pi \\gamma \\left[1+\\left({\\frac {x-x_{0}}{\\gamma }}\\right)^{2}\\right]}}\\]\n\nfrom scipy.stats import cauchy\n\n_ = plt.plot(mgrid[-3:3:0.01], cauchy(0, 1).pdf(mgrid[-3:3:0.01]))\n\nThe moral is to be careful in assuming that the expected value is always defined.\n\nExpected value of a function of a random variable\nWe’ll often have cause to take the expected value of some function \\(g(X) \\equiv g \\circ X\\) of a random variable, which we define as:\n\\[\\mathbb{E}\\left[g(X)\\right] \\equiv \\begin{cases}\\sum_{x} g(x) \\cdot p(x) & \\text{if $X$ is discrete} \\\\ \\int g(x) \\cdot f(x) \\, \\mathrm{d}x & \\text{if $X$ is continuous} \\\\ \\end{cases}\\]\nFor simple affine functions, it is straightforward to prove that \\(\\mathbb{E}\\left[aX + b\\right] = a\\mathbb{E}\\left[X\\right] + b\\). But it’s important to note that \\(\\mathbb{E}\\left[g(X)\\right] \\neq g\\left(\\mathbb{E}\\left[X\\right]\\right)\\) in general.7\n\n\nCentral moments\nOne function of a random variable we’ll use frequently is \\(\\left(X - \\mathbb{E}[X]\\right)^k\\), which gives us the concept of a central moment:\n\\[\\mathbb{E}\\left[\\left(X - \\mathbb{E}[X]\\right)^k\\right] = \\begin{cases}\\sum_{x \\in X(\\Omega)} \\left(x - \\mathbb{E}[X]\\right)^k \\cdot p_X(x) & \\text{if $X$ is discrete} \\\\ \\int_{X(\\Omega)} \\left(x - \\mathbb{E}[X]\\right)^k \\cdot f_X(x) \\, \\mathrm{d}x & \\text{if $X$ is continuous} \\\\ \\end{cases}\\]\nThe second central moment \\(\\mathbb{E}\\left[\\left(X - \\mathbb{E}[X]\\right)^2\\right]\\) is known as the variance \\(\\mathbb{V}\\left[X\\right]\\) or \\(\\text{Var}[X]\\), which is a common measure of dispersion. Another common measure of dispersion, the standard deviation, is simply \\(\\sqrt{\\mathbb{V}[X]}\\).\nLike the expected value/mean, the variance of a particular distribution can often be computed analytically in terms of the distribution’s parameters. For instance, the variance of a random variable \\(X \\sim \\text{Geom}(\\pi)\\) is:\n\\[\\mathbb{V}[X] \\equiv \\sum_{k=0}^\\infty (k - \\mathbb{E}[X])^2 \\cdot (1-\\pi)^k\\pi\\]\nIf \\(X \\sim \\mathcal{N}(\\mu, \\sigma^2)\\) , then \\(\\mathbb{E}[X] = \\mu\\) and \\(\\mathbb{V}[X] = \\sigma^2\\), hence the names mean and variance for those parameters.\n\n\nCovariance and correlation\nIt is often useful to know how two random variables \\(X\\) and \\(Y\\) “move together” or covary. We can measure this covariance by extending variance \\(\\mathbb{V}[X]\\), which is a property of a single random variable, to covariance, which is a property of pairs of random variables with a joint distribution \\(p_{X, Y}\\). Assuming both \\(X\\) and \\(Y\\) are continuous and real-valued:\n\\[\\begin{align*}\\text{cov}(X, Y) &= \\mathbb{E}[(X - \\mathbb{E}[X])(Y - \\mathbb{E}[Y])]\\\\ &= \\int_{\\mathbb{R}^2} (x - \\mathbb{E}[X]) \\cdot (y - \\mathbb{E}[Y]) \\cdot p(x, y) \\, \\mathrm{d}\\langle x, y \\rangle \\\\ &= \\int_{\\mathbb{R}} \\left[\\int_{\\mathbb{R}} (x - \\mathbb{E}[X]) \\cdot (y - \\mathbb{E}[Y]) \\cdot p(x, y) \\, \\mathrm{d}x\\right]\\, \\mathrm{d}y\\end{align*}\\]\nIf either are discrete, we just replace the integral over that variable with a sum.\nThe covariance of a random variable with itself is just the variance:\n\\[\\text{cov}(X, X) \\equiv \\mathbb{E}[(X - \\mathbb{E}[X])(X - \\mathbb{E}[X])] = \\mathbb{V}[X]\\]\nThe covariance has units corresponding to whatever the units of \\(X\\) and \\(Y\\) are: for instance, if both were formant values, the units would be frequency. The (Pearson) correlation normalizes these units away to a quantity in \\([-1, 1]\\), which can be useful if the variables have different units whose product is not itself interpretable.\n\\[\\text{corr}(X, Y) \\equiv \\frac{\\text{cov}(X, Y)}{\\sqrt{\\mathbb{V}[X]}\\sqrt{\\mathbb{V}[Y]}}\\]\nThis quantity is guaranteed to be between \\([-1, 1]\\) due to an application of the Cauchy-Schwarz inequality:\n\\[\\text{cov}(X, Y)^2 \\leq \\mathbb{V}[X] \\cdot \\mathbb{V}[Y]\\]\n\n\nConditional expectation\nIn certain cases, we need the expected value of one random variable \\(X\\) conditioned on another random variable \\(Y\\): \\(\\mathbb{E}[X \\mid Y]\\). In the case where we known the value of \\(Y\\) (or want to assume we do):\n\\[\\mathbb{E}[X \\mid Y = y] = \\begin{cases}\\sum_x x \\cdot p(x \\mid y) & \\text{if } X \\text{ is discrete} \\\\ \\int x \\cdot p(x \\mid y) \\, \\mathrm{d}x & \\text{if } X \\text{ is continuous}\\end{cases}\\]\nThus, we could think of \\(\\mathbb{E}[X \\mid Y = y]\\) as a function \\(g: \\mathrm{cod}(Y) \\rightarrow \\mathrm{cod}(X)\\).\nAlternatively, we can think of \\(\\mathbb{E}[X \\mid Y]\\) as a random variable \\(g(Y) = g \\circ Y: \\mathrm{dom}(Y) \\rightarrow \\mathrm{cod}(X)\\), where \\(\\mathrm{dom}(Y)\\) is the sample space of the probability space underlying \\(Y\\)."
  },
  {
    "objectID": "foundational-concepts-in-probability-and-statistics/random-variables-and-probability-distributions.html#footnotes",
    "href": "foundational-concepts-in-probability-and-statistics/random-variables-and-probability-distributions.html#footnotes",
    "title": "Random variables and probability distributions",
    "section": "Footnotes",
    "text": "Footnotes\n\n\nThe event space for \\(\\Omega = \\mathbb{R}_+^2\\) is analogous to the Borel \\(\\sigma\\)-algebra for \\(\\mathbb{R}\\). Basically, it contains all pairs of real intervals. The technical details aren’t really going to be important for our purposes beyond knowing that \\(\\mathbb{R}_+^2\\) is going to act like \\(\\mathbb{R}\\) in the ways we care about.↩︎\nIt is common to talk about the categorical distribution, when we really mean the family of categorical distributions.↩︎\nThe parameterization below is derived from the relative frequencies for each pronoun extracted from the Universal Dependencies English Web TreeBank here.↩︎\nThis semicolon notation–in contrast to the pipe notation–will become important shortly.↩︎\nThis assumes that strings cannot have zero length, meaning that \\(\\Omega = \\Sigma^+\\) rather than \\(\\Sigma^*\\); if we want to allow zero-length strings \\(\\epsilon\\), we would need \\(p_X(k) = \\frac{1}{2^{k+1}}\\).↩︎\nYou’ll need to take my word on this point if you haven’t proved it before.↩︎\nIf \\(g\\) is convex, however, \\(\\mathbb{E}\\left[g(X)\\right] \\geq g\\left(\\mathbb{E}\\left[X\\right]\\right)\\) by Jensen’s inequality.↩︎"
  },
  {
    "objectID": "foundational-concepts-in-probability-and-statistics/statistical-inference.html",
    "href": "foundational-concepts-in-probability-and-statistics/statistical-inference.html",
    "title": "Statistical Inference",
    "section": "",
    "text": "The concepts we’ve discussed so far provide us a space of possible descriptions of the world coming from probability theory, but they do not give us a way of grounding that description, thereby imbuing it with content. This is the role of statistics in general and statistical inference in particular. A good bit of this course will cover different forms of statistical inference. In this section, my aim is to give you a taste of two of the major forms of statistical inference we’ll use throughout the course in increasing more complex forms: frequentist inference and Bayesian inference. Unless you have explicitly been introduced to Bayesian inference, frequentist inference is probably the form you are most familiar with through the use of constructs like \\(p\\)-values and confidence intervals.\nThe overall goal of statistical inference is to find a good description of (some property of) a population in terms of probability distributions. The notion of population is very abstract; it could be basically any of the things we might be interested in defining a probability model for: formant values, vowels, well-formed strings of phonemes, morphemes, words, etc. We will generally start out with some assumptions about the family of distributions that might best describe the population and then on the basis of data sampled from the population attempt to determine which distribution in the family is the best description."
  },
  {
    "objectID": "foundational-concepts-in-probability-and-statistics/statistical-inference.html#running-example-pronoun-case",
    "href": "foundational-concepts-in-probability-and-statistics/statistical-inference.html#running-example-pronoun-case",
    "title": "Statistical Inference",
    "section": "Running example: pronoun case",
    "text": "Running example: pronoun case\nAs a running example, I’ll consider a case where \\(X_i\\) maps a pronoun token \\(i\\) to an indicator of whether it is accusative or not–i.e. the Bernoulli random variable we discussed here.\n\npronouns = frozenset({\n    \"i\", \"me\", \n    \"you\", \n    \"they\", \"them\", \n    \"it\", \n    \"she\", \"her\", \n    \"he\", \"him\", \n    \"we\", \"us\",\n})\n\npronouns_acc = frozenset({\"me\", \"you\", \"them\", \"her\", \"him\", \"it\", \"us\"})\npronouns_nonacc = frozenset({\"i\", \"you\", \"they\", \"she\", \"he\", \"it\", \"we\"})\n\nFor data, we’ll use the Universal Dependencies English Web Treebank.1 I’ll use this data throughout, often without comment.\n\nfrom urllib.request import urlopen\nfrom collections import Counter\nfrom numpy import array\n\ndata = []\n\ncase_pronoun = {\n    \"[+acc]\": [],\n    \"[-acc]\": []\n}\n\npronoun_count = Counter()\n\nud_ewt_url = \"https://raw.githubusercontent.com/UniversalDependencies/UD_English-EWT/master/en_ewt-ud-train.conllu\"\n\nwith urlopen(ud_ewt_url) as ud_ewt_url:\n    for i, l in enumerate(ud_ewt_url):\n        l = l.decode()\n        \n        if l[0] != \"#\" and l.strip():\n            l = l.split()\n            word = l[1].lower()\n            \n            if word not in pronouns:\n                continue\n            \n            if word in pronouns_acc - pronouns_nonacc:\n                data.append(1)\n                case_pronoun[\"[+acc]\"].append(word)\n                pronoun_count[word] += 1\n            elif word in pronouns_nonacc - pronouns_acc:\n                data.append(0)\n                case_pronoun[\"[-acc]\"].append(word)\n                pronoun_count[word] += 1\n            elif l[7] == \"nsubj\":\n                data.append(0)\n                case_pronoun[\"[-acc]\"].append(word)\n                pronoun_count[word+\"_[-acc]\"] += 1\n            else:\n                data.append(1)\n                case_pronoun[\"[+acc]\"].append(word)\n                pronoun_count[word+\"_[+acc]\"] += 1\n                \ndata = array(data)\n\nI’ll assume that \\(X_i\\) is independent of \\(X_j\\) for all \\(i \\neq j\\). In this case, we say that the collection of random variables \\(\\{X_1, X_2, \\ldots\\}\\) is independent and identically distributed (iid), which I will denote by.\n\\[X_i \\sim \\text{Bern}(\\pi)\\]\nHere, our description of our population is \\(\\text{Bern}(\\pi)\\) and \\(X_i\\) is a random variable corresponding to the \\(i^{th}\\) sample we’ve taken from the population.\nOne thing we might be interested in inferring is what the value of \\(\\pi\\) is. We’ll discuss two broad families of approaches to doing this: frequentist inference and Bayesian inference."
  },
  {
    "objectID": "foundational-concepts-in-probability-and-statistics/statistical-inference.html#frequentist-inference",
    "href": "foundational-concepts-in-probability-and-statistics/statistical-inference.html#frequentist-inference",
    "title": "Statistical Inference",
    "section": "Frequentist inference",
    "text": "Frequentist inference\nIn frequentist inference, we assume that \\(\\pi\\) is a fixed value–some aspect of the world we are attempting to discover (or at least approximate). One popular way to attempt to approximate (or estimate) this value is through use of the likelihood function \\(\\mathcal{L}_\\mathbf{x}(\\pi) = p_{X_1, X_2, \\ldots, X_N}(\\mathbf{x} = x_1, x_2, \\ldots, x_N; \\pi)\\).2 One common way to use the likelihood function in this way is maximum likelihood estimation (MLE). In MLE, we derive an estimate \\(\\hat\\pi\\) by…maximizing the likelihood.\n\\[\\begin{align*}\\hat\\pi &= \\arg_\\pi\\max\\mathcal{L}_\\mathbf{x}(\\pi)\\\\ &= \\arg_\\pi\\max p_{X_1, X_2, \\ldots, X_N}(\\mathbf{x}; \\pi)\\end{align*}\\]\nBecause \\(X_1, X_2, \\ldots, X_N\\) are iid by assumption (whether we observe an accusative on the \\(i^{th}\\) observation doesn’t depend on whether we observed it on any other), we can express this quantity as:\n\\[\\begin{align*}\\hat\\pi &= \\arg_\\pi\\max p_{X_1, X_2, \\ldots}(\\mathbf{x}; \\pi)\\\\ &= \\arg_\\pi\\max \\prod_{i=1}^N p_{X_i}(x_i; \\pi)\\\\ &= \\arg_\\pi\\max \\prod_{i=1}^N \\text{Bern}(x_i; \\pi)\\\\ &= \\arg_\\pi\\max \\prod_{i=1}^N \\pi^{x_i}(1-\\pi)^{1-x_i}\\\\\\end{align*}\\]\nTo make this form easier to work with, we will often maximize the log of the likelihood rather than the likelihood directly. (Equivalently, we will sometimes minimize the negative of the log-likelihood.) Taking the logarithm gives us the same result for the argmax, since logarithms are monotone increasing.\n\\[\\begin{align*}\\hat\\pi &= \\arg_\\pi\\max \\mathcal{L}_\\mathbf{x}(\\pi)\\\\ &= \\arg_\\pi\\max\\log\\mathcal{L}_\\mathbf{x}(\\pi) \\\\ &= \\arg_\\pi\\max \\log\\prod_{i=1}^N \\pi^{x_i}(1-\\pi)^{1-x_i}\\\\ &= \\arg_\\pi\\max \\sum_{i=1}^N \\log\\left( \\pi^{x_i}(1-\\pi)^{1-x_i}\\right)\\\\ &= \\arg_\\pi\\max \\sum_{i=1}^N x_i \\log \\pi + (1-x_i)\\log(1-\\pi)\\\\\\end{align*}\\]\nOne reason to express the maximization in terms of the log-likelihood, rather than the likelihood, is that it allows us to exchange a product for a sum. This sum makes it easier to compute the derivative, which we will use to maximize \\(\\pi\\)….\n\\[\\begin{align*}\\frac{\\mathrm{d}}{\\mathrm{d}\\pi}\\log\\mathcal{L}_\\mathbf{x}(\\pi) &= \\frac{\\mathrm{d}}{\\mathrm{d}\\pi}\\sum_{i=1}^N x_i \\log \\pi + (1-x_i)\\log(1-\\pi)\\\\ &= \\sum_{i=1}^N \\frac{\\mathrm{d}}{\\mathrm{d}\\pi} x_i \\log \\pi + (1-x_i)\\log(1-\\pi)\\\\ &= \\sum_{i=1}^N \\frac{x_i -\\pi}{p(1-\\pi)}\\\\ &= \\sum_{i=1}^N \\frac{x_i}{\\pi(1-\\pi)} - \\frac{1}{1-\\pi}\\\\ &= \\left[\\frac{1}{\\pi(1-\\pi)}\\sum_{i=1}^N x_i\\right] - \\frac{N}{1-\\pi}\\end{align*}\\]\n…by setting it to zero.\n\\[\\begin{align*}\\left[\\frac{1}{\\hat\\pi(1-\\hat\\pi)}\\sum_{i=1}^N x_i\\right] - \\frac{N}{1-\\hat\\pi} &= 0 \\\\ \\frac{1}{\\hat\\pi(1-\\hat\\pi)}\\sum_{i=1}^N x_i &= \\frac{N}{1-\\hat\\pi} \\\\ \\sum_{i=1}^N x_i &= N\\hat\\pi \\\\ \\frac{\\sum_{i=1}^N x_i}{N} &= \\hat\\pi \\\\ \\end{align*}\\]\nThus, the maximum likelihood estimate \\(\\hat\\pi\\) for a particular set of samples \\(x_1, x_2, \\ldots, x_N\\) is simply the sample mean for \\(X_1, X_2, \\ldots, X_N\\): \\(\\frac{\\sum_{i=1}^N x_i}{N}\\) (the number of accusative pronouns we observed over the number of pronouns we observed in total). View as a function of \\(\\mathbf{x}\\), we call \\(\\hat\\pi(\\mathbf{x}) = \\frac{\\sum_{i=1}^N x_i}{N}\\) the maximum likelihood estimator for the Bernoulli parameter (the estimand) \\(\\pi\\).\n\nfrom numpy import mean\n\npi_hat = data.mean()\n\npi_hat\n\n0.2709504031272905\n\n\nViewed as a function of some fixed quantity \\(\\hat\\pi(\\mathbf{x})\\) is to the conditional expectation \\(\\mathbb{E}[X \\mid Y = y]\\), which we viewed as a function of the value \\(y\\) of the random variable \\(Y\\). Here, we would consider \\(\\arg_\\pi\\max\\mathcal{L}_\\mathbf{x}(\\pi)\\) as a function of the values \\(x_1, x_2, \\ldots, x_N\\) of the random variables \\(X_1, X_2, \\ldots, X_N\\).\nBut similar to our discussion of conditional expectations, we will often talk about the estimator itself as a random variable that is a function of some other set of random variables \\(X_1, X_2, \\ldots, X_N\\). The view of \\(\\hat\\pi(\\mathbf{X})\\) as a random variable in turn allows us to talk about the distribution of \\(\\hat\\pi(\\mathbf{X})\\) as well as the distributions of functions on that random variable.\nIn the case of \\(X_i \\sim \\text{Bern}(\\pi)\\), \\(N\\hat\\pi(X_1, X_2, \\ldots, X_N) \\sim \\text{Binomial}(N, \\pi)\\):\n\\[p_{N\\hat\\pi(X_1, X_2, \\ldots, X_N)}(k) = {N \\choose k}\\pi^{k}(1-\\pi)^{N-k}\\]\nYou can get a sense for why this is by noting that any particular assignment \\(X_1 = x_1, X_2 = x_2, \\ldots, X_N = x_N\\) has a probability \\(p(x_1, x_2, \\ldots, x_N) = \\prod_{i=1}^N \\pi^{x_i}(1-\\pi)^{(1-x_i)} = \\pi^{\\sum_{i=1}^N x_i}(1-\\pi)^{\\sum_{i=1}^N (1-x_i)}\\) but that many other configurations will average to the same thing as \\(x_1, x_2, \\ldots, x_N\\) because they sum to the same thing as \\(x_1, x_2, \\ldots, x_N\\). The number of such configurations is given by the binomial coefficient \\({N \\choose k} = \\frac {n!}{k!(n-k)!}\\), which tells you the number of ways of selecting \\(x_i = 1\\) such that the sum is \\(k\\).\nWe can alternatively see that the estimator has this distribution by simulation. With smaller number of samples, the estimator will have higher variance.\n\nfrom numpy import mgrid\nfrom scipy.stats import bernoulli\nfrom statsmodels.distributions.empirical_distribution import ECDF\nfrom matplotlib.pyplot import subplot\n\ndef sample_bernoulli_sample_mean(p: float, n: int) -&gt; float:\n  return mean(bernoulli(p).rvs(n))\n\nn = 10\np = pi_hat\n\nsamples = [sample_bernoulli_sample_mean(p, n) for _ in range(1000)]\necdf = ECDF(samples)\n\n\n\nPlotting code\nfrom numpy import round\nfrom scipy.stats import binom\n\nax = subplot()\nax.plot(mgrid[0:n:0.1]/n, ecdf(mgrid[0:n:0.1]/n), label=\"Empirical CDF of simulated estimator\")\nax.plot(mgrid[0:n:0.1]/n, binom(n, p).cdf(mgrid[0:n:0.1]), label=\"Theoretical CDF of estimator\")\n\nax.legend()\nax.set_title(r\"CDF for estimator $\\hat{\\pi}(\\mathbf{X})$ of $\\pi = \"+ str(round(pi_hat, 2)) + \"$ when $N=10$\")\nax.set_xlabel(r\"$\\hat{\\pi}(\\mathbf{X})$\")\n_ = ax.set_ylabel(\"Probability\")\n\n\n\n\n\nWith larger numbers of samples–e.g. the number of datapoints we have (12,279)–it will have much lower variance.\n\nn = len(data)\np = pi_hat\n\nsamples = [sample_bernoulli_sample_mean(p, n) for _ in range(1000)]\necdf = ECDF(samples)\n\n\n\nPlotting code\nax = subplot()\nax.plot(mgrid[0:n:0.1]/n, ecdf(mgrid[0:n:0.1]/n), label=\"Empirical CDF of simulated estimator\")\nax.plot(mgrid[0:n:0.1]/n, binom(n, p).cdf(mgrid[0:n:0.1]), label=\"Theoretical CDF of estimator\")\n\nax.legend()\nax.set_title(r\"CDF for estimator $\\hat{\\pi}(\\mathbf{X})$ of $\\pi = \"+ str(round(pi_hat, 2)) + \"$ when $N=\"+ str(len(data)) +\"$\")\nax.set_xlabel(r\"$\\hat{\\pi}(\\mathbf{X})$\")\n_ = ax.set_ylabel(\"Probability\")\n\n\n\n\n\nOne such important distribution is that of the error.\n\\[e(\\hat\\pi(\\mathbf{X})) = \\hat\\pi(\\mathbf{X}) - \\pi\\]\nWe can describe this distribution as \\(N (\\pi + e(\\hat\\pi(\\mathbf{X}))) \\sim \\text{Binomial}(N, \\pi)\\).\n\ndef sample_bernoulli_sample_mean_error(p: float, n: int) -&gt; float:\n    return sample_bernoulli_sample_mean(p, n) - p\n\n\n\nPlotting code\nax = subplot()\n\nax.hist([sample_bernoulli_sample_mean_error(pi_hat, 10) for _ in range(1000)], bins=100, range=[-0.5, 0.5], density=True)\n\nax.set_title(r\"PDF of estimator error $e(\\hat{\\pi}(\\mathbf{X}))$ of $\\pi = \"+ str(round(pi_hat, 2)) + \"$ when $N=10$\")\nax.set_xlabel(r\"$e(\\hat{\\pi}(\\mathbf{X}))$\")\n_ = ax.set_ylabel(\"Density\")\n\n\n\n\n\n\n\nPlotting code\nax = subplot()\n\nax.hist([sample_bernoulli_sample_mean_error(pi_hat, len(data)) for _ in range(1000)], bins=1000, range=[-0.5, 0.5])\n\nax.set_title(r\"PDF of estimator error $e(\\hat{\\pi}(\\mathbf{X}))$ of $\\pi = \"+ str(round(pi_hat, 2)) + \"$ when $N=\"+ str(len(data)) +\"$\")\nax.set_xlabel(r\"$e(\\hat{\\pi}(\\mathbf{X}))$\")\n_ = ax.set_ylabel(\"Density\")\n\n\n\n\n\nIt also allows us to define two important quantities associated with the estimator: the bias, which is equivalent to the expected value of the error…\n\\[b(\\hat\\pi(\\mathbf{X})) = \\mathbb{E}[\\hat\\pi(\\mathbf{X})] - \\pi = \\mathbb{E}[\\hat\\pi(\\mathbf{X}) - \\pi]\\]\n…and the mean squared error (MSE).\n\\[\\text{MSE}(\\hat\\pi(\\mathbf{X})) = \\mathbb{E}\\left[(\\hat\\pi(\\mathbf{X}) - \\pi)^2\\right]\\]\nBoth are ways of quantifying how off we will tend to be in estimating the parameter of interest at a particular sample size. So for instance, for the maximum likelihood estimator we’ve been looking at:\n\\[\\text{b}(\\hat\\pi(\\mathbf{X})) = \\sum_{k=0}^N \\left(\\frac{k}{N} - \\pi\\right) \\cdot {N \\choose k}\\pi^k(1-\\pi)^{N-k}\\]\n\\[\\text{MSE}(\\hat\\pi(\\mathbf{X})) = \\sum_{k=0}^N \\left(\\frac{k}{N} - \\pi\\right)^2 \\cdot {N \\choose k}\\pi^k(1-\\pi)^{N-k}\\]\nThus, while the bias of this estimator is 0, the MSE starts relatively high and goes down as \\(N \\rightarrow \\infty\\), and it goes down faster the further from 0.5 \\(\\pi\\) is.\n\nfrom numpy import arange, sum\n\ndef bernoulli_mle_mse(n, p):\n  return sum((arange(n+1)/n - p)**2 * binom(n, p).pmf(arange(n+1)))\n\n\n\nPlotting code\nsample_sizes = arange(1, 20)\n\nax = subplot()\n\nax.plot(sample_sizes, [bernoulli_mle_mse(n, 0.5) for n in sample_sizes], label=r\"$\\pi = 0.5$\")\nax.plot(sample_sizes, [bernoulli_mle_mse(n, 0.75) for n in sample_sizes], label=r\"$\\pi = 0.25$\")\nax.plot(sample_sizes, [bernoulli_mle_mse(n, 0.9) for n in sample_sizes], label=r\"$\\pi = 0.1$\")\n\nax.legend()\n\nax.set_title(r\"MSE of estimator $\\hat{\\pi}(\\mathbf{X})$ at different sample sizes\")\nax.set_xlabel(r\"Sample size\")\n_ = ax.set_ylabel(\"MSE\")\n\n\n\n\n\nWe say that an estimator is unbiased if the bias of the estimator is \\(0\\); otherwise it’s biased. Therefore, the maximum likelihood estimator for the Bernoulli parameter is unbiased: it’s always \\(0\\), regardless of the sample size.\nBut maximum likelihood estimators for many other distributions are not. For instance, the maximum likelihood estimator \\(\\hat\\mu(\\mathbf{X})\\) for the mean \\(\\mu\\) of a univariate normal distribution is also the sample mean \\(\\hat\\mu(\\mathbf{x}) = \\frac{\\sum_{i=1}^N x_i}{N}\\), and this estimator is unbiased. In contrast, the maximum likelihood estimator \\(\\hat\\sigma^2(\\mathbf{X})\\) for the variance \\(\\sigma^2\\) is the sample variance \\(\\hat\\sigma^2(\\mathbf{x}) = \\frac{\\sum_{i=1}^N \\left(x_i - \\hat\\mu(\\mathbf{x})\\right)^2}{N}\\), but this estimator is biased: \\(b\\left(\\hat\\sigma^2(\\mathbf{X})\\right) = -\\frac{\\sigma^2}{N}\\). That is, in expectation, it underestimates the true variance by \\(-\\frac{\\sigma^2}{N}\\). (I won’t work through why this is, but you can find a proof here.) It’s for this reason that you’ll often see an alternative estimator of the variance used: \\(s^2(\\mathbf{X}) = \\frac{\\sum_{i=1}^N \\left(x_i - \\hat\\mu(\\mathbf{x})\\right)^2}{N-1}\\).\nIn general, we aren’t going to worry too much about bias (indeed, in some sense, we’re going to lean into biased estimators), but it is useful to know the above if you haven’t seen it before."
  },
  {
    "objectID": "foundational-concepts-in-probability-and-statistics/statistical-inference.html#bayesian-inference",
    "href": "foundational-concepts-in-probability-and-statistics/statistical-inference.html#bayesian-inference",
    "title": "Statistical Inference",
    "section": "Bayesian Inference",
    "text": "Bayesian Inference\nThe maximum likelihood estimate is what’s known as a point estimate because it’s a single number that gives the “best” estimate for the parameter given a way of estimating that parameter, such as MLE. But often we want to know how much uncertainty we should have about that estimate. For instance, if I compute the maximum likelihood estimate on the basis of only a single sample, that estimate, which will be either \\(0\\) or \\(1\\), will probably be terrible, even though, as we just discussed, the estimator is unbiased: it’s expected error is \\(0\\). The MSE gives us some indication of how much to trust the estimate (less with smaller sample sizes and more with larger sample sizes), but it doesn’t really tell us which other possible estimates might be reasonable values.\nBefore talking about how we deal with this issue in Bayesian inference, I first want to discuss one way that frequentist inference deals with uncertainty and that you might be familiar with: confidence intervals. The main reason I want to discuss confidence intervals is because they are tricky: their interpretation seems a lot clearer than it actually is.\n\nConfidence Intervals\nA confidence interval for some parameter \\(\\pi\\) at some confidence level \\(\\gamma \\in (0, 1)\\) is an interval \\((l(\\mathbf{X}), u(\\mathbf{X}))\\) whose bounds are determined by a pair of random variables \\(l(\\mathbf{X})\\) and \\(u(\\mathbf{X})\\). In being random variables, we can compute probabilities of events defined in terms of them. The probability that is relevant in constructing a confidence interval is \\(\\mathbb{P}\\left(l(\\mathbf{X}) &lt; \\theta &lt; u(\\mathbf{X})\\right)\\). To construct a confidence interval at level \\(\\gamma\\), we’re going to find the values of \\(l(\\mathbf{X})\\) and \\(u(\\mathbf{X})\\) such that \\(\\mathbb{P}\\left(l(\\mathbf{X}) &lt; \\theta &lt; u(\\mathbf{X})\\right) = \\gamma\\).\nOften, this interval needs to be approximated; and even in the case of the Bernoulli parameter, there are a variety of ways of doing this approximation. One way to do it is using the Clopper-Pearson method, which computes the interval as:\n\\[l(\\mathbf{x}) = \\inf \\left\\{\\theta \\,\\,{\\Big |}\\,\\,\\left[\\sum_{k=\\sum_{i=0}^N x_i}^N\\operatorname {Bin} \\left(k; N, \\theta \\right)\\right]&gt;{\\frac {1 - \\gamma }{2}}\\right\\}\\]\n\\[u(\\mathbf{x}) = \\sup\\left\\{\\theta \\,\\,{\\Big |}\\,\\,\\left[\\sum_{k=0}^{\\sum_{i=0}^N x_i}\\operatorname {Bin} \\left(k; N, \\theta \\right)\\right]&gt;{\\frac {1 - \\gamma }{2}}\\right\\}\\]\n\nfrom statsmodels.stats.proportion import proportion_confint\n\n\n\nEstimate CI with Clopper-Pearson\ncount_n_obs = [\n    (2, 10),\n    (20, 100),\n    (200, 1_000)\n]\n\nfor count, n_obs in count_n_obs:\n    ci = round(\n        proportion_confint(\n            count=count, nobs=n_obs, \n            method='beta'\n        ), 2\n    )\n\n    print(f\"successes = {count}\\tobservations = {n_obs}\\t95% CI={ci}\")\n\n\nsuccesses = 2   observations = 10   95% CI=[0.03 0.56]\nsuccesses = 20  observations = 100  95% CI=[0.13 0.29]\nsuccesses = 200 observations = 1000 95% CI=[0.18 0.23]\n\n\nAlternatively, we’ll very frequently compute confidence intervals via nonparametric bootstraps. In the simplest form of a nonparametric bootstrap, we take a dataset and resample it with replacement many times, thereby simulating the experiment on the basis of the distribution of samples. On each resampling, we compute the statistic of interest. Then, we compute the \\(\\frac{1-\\gamma}{2}\\) and \\(1-\\frac{1-\\gamma}{2}\\) quantiles of the collection of statistics–i.e. the values \\(l\\) and \\(u\\) such that \\(\\frac{1-\\gamma}{2}\\) of the statistics are less the \\(l\\) and \\(\\frac{1-\\gamma}{2}\\) are greater than \\(u\\).\n\nfrom typing import Tuple, Iterable\nfrom numpy import concatenate, zeros, ones, quantile\nfrom numpy.random import choice\n\ndef bootstrap_mean(\n    x: Iterable, gamma: float=0.95, \n    n_iter: int=10_000\n) -&gt; Tuple[float, Tuple[float, float]]:\n    \"\"\"Confidence interval of the mean using a non-parametric bootstrap\n    \n    Parameters\n    ----------\n    x\n        The data whose mean CI we want to bootstrap\n    gamma\n        The confidence level\n    n_iter\n        The number of bootstrap iterates\n        \n    Returns\n    -------\n    est\n        The estimate of the mean\n    ci\n        The confidence interval\n    \"\"\"\n    alpha = 1 - gamma\n\n    resampled = [choice(x, len(x)) for _ in range(n_iter)]\n    means = [mean(resamp) for resamp in resampled]\n\n    cilo, est, cihi = quantile(means, [alpha/2, 0.5, 1 - alpha/2])\n\n    return est, (cilo, cihi)\n\n\n\nEstimate CI with nonparametric bootstrap\nfor count, n_obs in count_n_obs:\n    samples = concatenate([ones(count), zeros(n_obs-count)])\n    est, ci = bootstrap_mean(samples)\n\n    print(f\"successes = {count}\\tobservations = {n_obs}\\testimate: {est}\\t95% CI={ci}\")\n\n\nsuccesses = 2   observations = 10   estimate: 0.2   95% CI=(0.0, 0.5)\nsuccesses = 20  observations = 100  estimate: 0.2   95% CI=(0.12, 0.28)\nsuccesses = 200 observations = 1000 estimate: 0.2   95% CI=(0.175, 0.225)\n\n\nWhy do I say the interpretation of these intervals is tricky? I say this because you might try to read \\(\\theta\\) in \\(\\mathbb{P}\\left(l(\\mathbf{X}) &lt; \\theta &lt; u(\\mathbf{X})\\right)\\) as a random variable, but it’s importantly not in this context: \\(\\theta\\) is some fixed value that we’re trying to estimate. So what this probability is telling us is how likely it is that the true, fixed value \\(\\theta\\) falls within the interval we construct when observing \\(\\mathbf{X}\\) many, many times. That is, the random variables here are those in \\(\\mathbf{X}\\), not \\(\\theta\\).\n\n\nPosterior Distributions\nThe way Bayesian inference deals with this issue is instead calculating something a bit more intuitive: the conditional distribution of the parameter \\(p(\\theta\\mid \\mathbf{x})\\). This approach is very different than the one we just saw because it requires us to view the parameter as (the value of) a random variable \\(\\Theta = \\theta\\). Generally, we don’t have a good idea what that conditional distribution looks like, but we may have some reasonable guesses about what \\(p(\\mathbf{x} \\mid \\theta)\\) and \\(p(\\theta)\\) look like. In this case, we will often invoke Bayes’ theorem to try to compute \\(p(\\theta\\mid \\mathbf{x})\\).\n\\[\\begin{align*}p(\\theta\\mid \\mathbf{x}) &= \\frac{p(\\mathbf{x} \\mid \\theta)p(\\theta)}{p(\\mathbf{x})} \\\\ &= \\begin{cases}\\frac{p(\\mathbf{x} \\mid \\theta)p(\\theta)}{\\sum_{\\theta'} p(\\mathbf{x}, \\theta')} & \\text{if } \\Theta \\text{ is discrete} \\\\ \\frac{p(\\mathbf{x} \\mid \\theta)p(\\theta)}{\\int p(\\mathbf{x}, \\theta')\\,\\mathrm{d}\\theta'} & \\text{if } \\Theta \\text{ is continuous} \\\\ \\end{cases}\\\\ &= \\begin{cases}\\frac{p(\\mathbf{x} \\mid \\theta)p(\\theta)}{\\sum_{\\theta'} p(\\mathbf{x} \\mid \\theta')p(\\theta')} & \\text{if } \\Theta \\text{ is discrete} \\\\ \\frac{p(\\mathbf{x} \\mid \\theta)p(\\theta)}{\\int p(\\mathbf{x} \\mid \\theta')p(\\theta')\\,\\mathrm{d}\\theta'} & \\text{if } \\Theta \\text{ is continuous} \\\\ \\end{cases}\\\\ \\end{align*} \\]\nIn this context, \\(p(\\theta\\mid \\mathbf{x})\\) is often termed the posterior (since it is the distribution of \\(\\Theta\\) after observing \\(\\mathbf{X}\\)), \\(p(\\theta)\\) is often termed the prior (since it is the distribution of \\(\\Theta\\) before observing \\(\\mathbf{X}\\)), and \\(p(\\mathbf{x})\\) is often termed the evidence. The name for \\(p(\\mathbf{x} \\mid \\theta)\\) is one we’ve seen before: the likelihood. This terminology is where the notation \\(\\mathcal{L}(\\theta \\mid \\mathbf{x})\\) I mentioned earlier comes from. In Bayesian inference, \\(\\mathcal{L}\\) is often defined as:\n\\[\\mathcal{L}(\\theta \\mid \\mathbf{x}) = p(\\mathbf{x} \\mid \\theta)\\]\nThis notation, which contrasts with the notation I used earlier–\\(\\mathcal{L}(\\theta \\mid \\mathbf{x}) = p(\\mathbf{x}; \\theta)\\)–is intended to emphasize that both \\(\\mathbf{X}\\) and \\(\\Theta\\) are viewed as random variables.\nBecause we generally assume a situation where the value of \\(\\mathbf{X} = \\mathbf{x}\\) is known (or at least observable in principle), so \\(p(\\mathbf{x})\\) (the evidence) is a constant: whatever the probability (or density) of the actual observation is. Indeed, it’s specifically a normalizing constant, since it doesn’t depend on \\(\\theta\\). So in a reasonable number of cases, we actually only care about the numerator (the product of the prior and the likelihood): we only care that \\(p(\\theta \\mid \\mathbf{x})\\) is proportional to \\(p(\\mathbf{x} \\mid \\theta)p(\\theta)\\).3 4\n\\[p(\\theta \\mid \\mathbf{x}) \\propto p(\\mathbf{x} \\mid \\theta)p(\\theta)\\]\n“Full” Bayesian inference will always use the posterior distribution in downstream inferences–as I discuss below. To simulate frequentist inference, however, we will sometimes derive point estimates from this distribution: often, a measure of the posterior’s central tendency (mean, median, or mode) and/or the \\((1-\\alpha)\\)% credible interval. The latter can be defined multiple ways. If the variable is univariate and continuous (which is often the case when computing credible intervals), one way is to define it as the interval \\((\\theta_\\text{min}, \\theta_\\text{max})\\) s.t. \\(\\mathbb{P}(\\theta &lt; \\theta_\\text{min} \\mid \\mathbf{x}) = \\mathbb{P}(\\theta &gt; \\theta_\\text{max} \\mid \\mathbf{x}) = \\frac{\\alpha}{2}\\).\n\n\nConjugate Priors\nIf we were to pick two arbitrary distributions for the likelihood \\(p(\\mathbf{x} \\mid \\theta)\\) and the prior \\(p(\\theta)\\) with which to express the posterior distribution \\(p(\\theta \\mid \\mathbf{x})\\), the posterior will often still be difficult to compute. But there are specific cases where computing it gets easier if we are prudent in our choice of what form the likelihood and prior take. Specifically, when the prior is conjugate to the likelihood, the posterior is guaranteed to be in the same distributional family as the prior (usually with different parameters).\nAn example of this can be seen with the beta and Bernoulli distributions we’ve been working with. Suppose that:\n\\[\\Pi \\sim \\text{Beta}(\\alpha, \\beta)\\]\nAnd suppose we wanted to compute the posterior density \\(p(\\pi \\mid x)\\) when we’ve observed a single \\(X\\). We don’t know this density directly, but we do know \\(p(x \\mid \\pi) = \\text{Bern}(x \\mid \\pi)\\) and the \\(p(\\pi) = \\text{Beta}(\\pi; \\alpha, \\beta)\\).5\nLet’s work through the full expression of Bayes’ theorem.\n\\[p(\\pi \\mid x) = \\frac{p(x \\mid \\pi)p(\\pi)}{p(x)} = \\frac{p(x \\mid \\pi)p(\\pi)}{\\int p(x \\mid \\pi')p(\\pi') \\, \\mathrm{d}\\pi'}\\]\nAnd let’s first deal with that denominator.\n\\[\\begin{align*}p(x) &= \\int p(x \\mid \\pi)p(\\pi) \\, \\mathrm{d}\\pi \\\\ &= \\int_0^1 \\text{Bern}(x\\mid \\pi)\\,\\text{Beta}(\\pi; \\alpha, \\beta)\\,\\mathrm{d}\\pi\\\\\n&= \\int_0^1 \\pi^x(1-\\pi)^{1-x}\\frac{\\pi^{\\alpha-1}(1-\\pi)^{\\beta-1}} {\\mathrm{B}(\\alpha,\\beta)} \\,\\mathrm{d}\\pi\\\\ &= \\frac{1}{\\mathrm{B}(\\alpha,\\beta)}\\int_0^1 \\pi^{x+\\alpha-1}(1-\\pi)^{\\beta+(1-x)-1} \\,\\mathrm{d}\\pi\\end{align*}\\]\nThis formula looks complex, but it turns out that we can use a straightforward trick to simplify it: because PDFs must always integrate to 1 over the range of the random variable by the assumption of unit measure, e.g.,…\n\\[\\int_0^1 \\text{Beta}(\\pi; \\alpha, \\beta)\\,\\mathrm{d}\\pi = \\int_0^1 \\frac{\\pi^{\\alpha-1}(1-\\pi)^{\\beta-1}} {\\mathrm{B}(\\alpha,\\beta)}\\,\\mathrm{d}\\pi = 1\\]\n…and because the normalizing constant can always be factored out of the integral, since it doesn’t depend on the variable of integration, e.g., …\n\\[\\int_0^1 \\frac{\\pi^{\\alpha-1}(1-\\pi)^{\\beta-1}} {\\mathrm{B}(\\alpha,\\beta)}\\,\\mathrm{d}\\pi = \\frac{1} {\\mathrm{B}(\\alpha,\\beta)}\\int_0^1 \\pi^{\\alpha-1}(1-\\pi)^{\\beta-1}\\,\\mathrm{d}\\pi\\]\n…it must be that the unnormalized PDF, e.g., \\(\\pi^{\\alpha-1}(1-\\pi)^{\\beta-1}\\) integrates to the normalizing constant:\n\\[\\int_0^1 \\pi^{\\alpha-1}(1-\\pi)^{\\beta-1}\\,\\mathrm{d}\\pi = \\mathrm{B}(\\alpha,\\beta)\\]\nWhy does this help us? Well. We can view the value we need to integrate in our compound distribution as an unnormalized PDF of a random variable \\(\\text{Beta}(\\alpha + x, \\beta + (1-x))\\) and thus:\n\\[\\begin{align*}p(x) &= \\frac{1}{\\mathrm{B}(\\alpha,\\beta)}\\int_0^1 \\pi^{x+\\alpha-1}(1-\\pi)^{\\beta+(1-x)-1} \\,\\mathrm{d}\\pi\\\\ &= \\frac{\\mathrm{B}(\\alpha + x, \\beta + (1-x))}{\\mathrm{B}(\\alpha,\\beta)} \\end{align*}\\]\nThis still looks complex, but it’s actually not, because we can take advantage of the properties of the gamma function.\n\\[\\begin{align*}p(x) &= \\frac{\\mathrm{B}(\\alpha + x, \\beta + (1-x))}{\\mathrm{B}(\\alpha,\\beta)}\\\\ &= \\frac{\\left(\\frac {\\Gamma (\\alpha+x)\\Gamma (\\beta+(1-x))}{\\Gamma (\\alpha+\\beta+1)}\\right)}{\\left(\\frac {\\Gamma (\\alpha)\\Gamma (\\beta)}{\\Gamma (\\alpha+\\beta)}\\right)} \\\\ &= \\frac{\\Gamma (\\alpha+\\beta)}{\\Gamma (\\alpha+\\beta+1)} \\frac{\\Gamma (\\alpha+x)}{\\Gamma (\\alpha)} \\frac{\\Gamma (\\beta+(1-x))}{\\Gamma (\\beta)} \\\\ &= \\begin{cases}\\frac{\\alpha}{\\alpha+\\beta} & \\text{if } x = 1\\\\ \\frac{\\beta}{\\alpha+\\beta} & \\text{if } x = 0\\end{cases} \\\\ &= \\left(\\frac{\\alpha}{\\alpha+\\beta}\\right)^x\\left(1-\\frac{\\alpha}{\\alpha+\\beta}\\right)^{1-x} \\end{align*}\\]\n\\(X\\) (in contrast to \\(X \\mid \\Pi\\), which is distributed Bernoulli) is thus said to be distributed \\(\\text{BetaBernoulli}(\\alpha, \\beta)\\), which as we just showed turns out to be equivalent to being distributed \\(\\text{Bernoulli}\\left(\\frac{\\alpha}{\\alpha+\\beta}\\right)\\). The BetaBernoulli distribution is our first instance of a compound probability distribution. We’ll see more such distributions throughout the course.6\nSo now we know what the denominator looks like; what’s the numerator? Well. We’ve already computed it while computing the denominator:\n\\[p(x \\mid \\pi)p(\\pi) = \\frac{\\pi^{x+\\alpha-1}(1-\\pi)^{\\beta+(1-x)-1}}{\\mathrm{B}(\\alpha, \\beta)}\\]\nThus:\n\\[p(\\pi \\mid x) = \\frac{\\left(\\frac{\\pi^{x+\\alpha-1}(1-\\pi)^{\\beta+(1-x)-1}}{\\mathrm{B}(\\alpha, \\beta)}\\right)}{\\left(\\frac{\\alpha}{\\alpha+\\beta}\\right)^x\\left(\\frac{\\beta}{\\alpha+\\beta}\\right)^{1-x}}\\]\nI promised a form for the posterior that was in the same family as the prior, so this should be a beta distribution; but it doesn’t really look like one. It is, though; and to see it, we need to go back to:\n\\[p(x) = \\frac{\\mathrm{B}(\\alpha + x, \\beta + (1-x))}{\\mathrm{B}(\\alpha,\\beta)}\\]\nUsing this equality, we get:\n\\[\\begin{align*}p(\\pi \\mid x) &= \\frac{\\left(\\frac{\\pi^{x+\\alpha-1}(1-\\pi)^{\\beta+(1-x)-1}}{\\mathrm{B}(\\alpha, \\beta)}\\right)}{\\left(\\frac{\\mathrm{B}(\\alpha + x, \\beta + (1-x))}{\\mathrm{B}(\\alpha,\\beta)}\\right)}\\\\ &= \\frac{\\pi^{x+\\alpha-1}(1-\\pi)^{\\beta+(1-x)-1}}{\\mathrm{B}(\\alpha + x, \\beta + (1-x))}\\\\ &= \\mathrm{Beta}(\\pi \\mid \\alpha + x, \\beta + (1-x))\\\\ \\end{align*}\\]\nIntuitively, this can be read: “if I started out believing that \\(\\Pi\\) was distributed \\(\\text{Beta}(\\alpha, \\beta)\\) and then I observed that \\(X = x\\), I now should believe that \\(\\Pi\\) is distributed \\(\\mathrm{Beta}(\\pi \\mid \\alpha + x, \\beta + (1-x))\\).”\nSo if I started out with a uniform distribution on \\(\\pi \\sim \\text{Beta}(1, 1)\\)…\n\n\nPlotting code\nfrom scipy.stats import beta\n\nax = subplot()\n\n_ = ax.plot(mgrid[0:1:0.01], beta(1, 1).pdf(mgrid[0:1:0.01]))\n\n\n\n\n\n…and I observed \\(X = 1\\), I shift the density to the right: \\(\\pi \\mid X = 1 \\sim \\text{Beta}(2, 1)\\)…\n\n\nPlotting code\nax = subplot()\n\n_ = ax.plot(mgrid[0:1:0.01], beta(2, 1).pdf(mgrid[0:1:0.01]))\n\n\n\n\n\n…but if I observed \\(X = 0\\), I shift the density to the left: \\(\\pi \\mid X = 0 \\sim \\text{Beta}(1, 2)\\).\n\n\nPlotting code\nax = subplot()\n\n_ = ax.plot(mgrid[0:1:0.01], beta(1, 2).pdf(mgrid[0:1:0.01]))\n\n\n\n\n\nIf I start out with a much denser prior, like \\(\\pi \\sim \\text{Beta}(10, 10)\\)…\n\n\nPlotting code\nax = subplot()\n\n_ = ax.plot(mgrid[0:1:0.01], beta(10, 10).pdf(mgrid[0:1:0.01]))\n\n\n\n\n\n… the shifts to \\(\\pi \\mid X = 1 \\sim \\text{Beta}(11, 10)\\) and \\(\\pi \\mid X = 0 \\sim \\text{Beta}(10, 11)\\) are much smaller.\n\n\nPlotting code\nax = subplot()\n\nax.plot(mgrid[0:1:0.01], beta(10, 10).pdf(mgrid[0:1:0.01]), label=\"Prior: Beta(10, 10)\")\nax.plot(mgrid[0:1:0.01], beta(11, 10).pdf(mgrid[0:1:0.01]), label=\"Posterior after observing X = 1: Beta(11, 10)\")\nax.plot(mgrid[0:1:0.01], beta(10, 11).pdf(mgrid[0:1:0.01]), label=\"Posterior after observing X = 0: Beta(10, 11)\")\n\n_ = ax.legend()\n\n\n\n\n\nSo the stronger I believe something initially (e.g. that there is high density nearest to \\(0.5\\)), the less I can be swayed one way or another by a single piece of evidence.\n\nPredictive Distributions\nWe’ll use conjugacy extensively throughout this course. To give you a taste: one important place it will show up is in the context of making predictions about what we will see in the future (\\(x_\\text{new}\\)) based on what we’ve already seen (\\(\\mathbf{x}_\\text{old}\\)), which we can formulate using what’s know as the posterior predictive distribution.\n\\[\\begin{align*}p(x_\\text{new} \\mid \\mathbf{x}_\\text{old}) &= \\int p(x_\\text{new}, \\pi \\mid \\mathbf{x}_\\text{old})\\,\\mathrm{d}\\pi & \\text{definition of joint distribution}\\\\ &= \\int p(x_\\text{new}\\mid \\pi; \\mathbf{x}_\\text{old})p(\\pi \\mid \\mathbf{x}_\\text{old})\\,\\mathrm{d}\\pi & \\text{definition of conditional probability}\\\\ &= \\int p(x_\\text{new}\\mid \\pi)p(\\pi \\mid \\mathbf{x}_\\text{old})\\,\\mathrm{d}\\pi & \\text{conditional independence assumption}\\\\ &= \\int \\mathcal{L}(\\pi \\mid x_\\text{new})p(\\pi \\mid \\mathbf{x}_\\text{old})\\,\\mathrm{d}\\pi  & \\text{definition of $\\mathcal{L}$}\\\\ &= \\mathbb{E}\\left[\\mathcal{L}(\\Pi \\mid x_\\text{new})\\mid \\mathbf{X}\\right] & \\text{definition of conditional expectation}\\\\\\end{align*}\\]\nIn the context of our running example, this can be read “if I’ve observed pronouns with cases \\(\\mathbf{x}_\\text{old}\\), the probability that the next pronoun I observe \\(x_\\text{new}\\) will be high can be found by taking the conditional expectation of the likelihood \\(\\mathcal{L}(\\Pi \\mid x_\\text{new})\\) (a function of the random variable \\(\\Pi\\)) given \\(\\mathbf{X}_\\text{old}\\).”\nWe know by slightly extending what we saw above that:\n\\[p(\\pi \\mid \\mathbf{x}; \\alpha, \\beta) = \\text{Beta}\\left(\\pi; \\alpha + \\sum_i x_{\\text{old}, i}, \\beta + \\sum_i 1 - x_{\\text{old}, i}\\right)\\]\nAnd since \\(p(x_\\text{new}\\mid \\pi) = \\text{Bernoulli}(x_\\text{new}; \\pi)\\) by the work we did to prove the beta-Bernoulli conjugacy, we know that:\n\\[p(x_\\text{new}\\mid \\pi; \\mathbf{x}_\\text{old})p(\\pi \\mid \\mathbf{x}_\\text{old}) = \\frac{\\pi^{\\alpha + x_\\text{new} + \\sum_i x_{\\text{old}, i} - 1}(1-\\pi)^{\\beta + (1-x_\\text{new}) +\\sum_i 1 - x_{\\text{old}, i}-1}}{\\mathrm{B}\\left(\\alpha + \\sum_i x_{\\text{old}, i}, \\beta  +\\sum_i 1 - x_{\\text{old}, i}\\right)}\\]\nSo:\n\\[\\begin{align*}p(x_\\text{new} \\mid \\mathbf{x}_\\text{old}) &= \\int \\frac{\\pi^{\\alpha + x_\\text{new} + \\sum_i x_{\\text{old}, i} - 1}(1-\\pi)^{\\beta + (1-x_\\text{new}) +\\sum_i 1 - x_{\\text{old}, i}-1}}{\\mathrm{B}\\left(\\alpha + \\sum_i x_{\\text{old}, i}, \\beta  +\\sum_i 1 - x_{\\text{old}, i}\\right)}\\,\\mathrm{d}\\pi\\\\ &= \\frac{\\int \\pi^{\\alpha + x_\\text{new} + \\sum_i x_{\\text{old}, i} - 1}(1-\\pi)^{\\beta + (1-x_\\text{new}) +\\sum_i 1 - x_{\\text{old}, i}-1} \\,\\mathrm{d}\\pi}{\\mathrm{B}\\left(\\alpha + \\sum_i x_{\\text{old}, i}, \\beta  +\\sum_i 1 - x_{\\text{old}, i}\\right)}\\\\ &= \\frac{\\mathrm{B}\\left(\\alpha + x_\\text{new} + \\sum_i x_{\\text{old}, i}, \\beta + (1-x_\\text{new}) +\\sum_i 1 - x_{\\text{old}, i}\\right)}{\\mathrm{B}\\left(\\alpha + \\sum_i x_{\\text{old}, i}, \\beta  +\\sum_i 1 - x_{\\text{old}, i}\\right)}\\\\\\end{align*}\\]\nThis form is exactly like what we had when computing the computing \\(p(x)\\), and the same logic for reducing it can be deployed here.\n\\[p(x_\\text{new} \\mid \\mathbf{x}_\\text{old}) = \\text{BetaBern}\\left(x_\\text{new}; \\alpha + \\sum_i x_{\\text{old}, i}, \\beta + \\sum_i 1- x_{\\text{old}, i}\\right) = \\text{Bern}\\left(x_\\text{new}; \\frac{\\alpha + \\sum_i x_{\\text{old}, i}}{\\alpha + \\beta + N}\\right)\\]\nThis is of course not a coincidence: the evidence \\(p(x) = \\int p(x\\mid \\pi)p(\\pi)\\,\\mathrm{d}\\pi\\) is always the prior predictive distribution, which is just like the posterior predictive distribution, but without the conditioning on prior data.\n\\[p(x) = \\mathbb{E}\\left[\\mathcal{L}(\\Pi \\mid x)\\right]\\]\n\n\n\nBeyond conjugacy\nIt is often the case that we cannot derive the posterior \\(p(\\theta \\mid \\mathbf{x})\\) analytically–i.e. without any integrals, as we did above. For instance, suppose we wanted to compute the evidence/prior predictive \\(p(\\mathbf{x})\\) from our example above, but instead of assuming that the prior \\(p(\\pi)\\) was beta-distributed, we wanted to assume it was distributed logit-normal.\n\\[p(\\pi; \\mu, \\sigma) \\propto \\frac{\\exp\\left(-\\frac  {(\\text{logit}(\\pi)-\\mu )^2}{2\\sigma^2}\\right)}{\\pi(1-\\pi)}\\]\n\nfrom numpy import inf\nfrom scipy.stats import rv_continuous, norm\nfrom scipy.special import logit, expit\n\nclass logitnorm_gen(rv_continuous):\n    \"\"\"A logit-normal generator\n    \n    See https://stackoverflow.com/a/73084994\n    \"\"\"\n    \n    def _argcheck(self, m, s):\n        return (s &gt; 0.) & (m &gt; -inf)\n    \n    def _pdf(self, x, m, s):\n        return norm(loc=m, scale=s).pdf(logit(x))/(x*(1-x))\n    \n    def _cdf(self, x, m, s):\n        return norm(loc=m, scale=s).cdf(logit(x))\n    \n    def _rvs(self, m, s, size=None, random_state=None):\n        return expit(m + s*random_state.standard_normal(size))\n    \n    def fit(self, data, **kwargs):\n        return norm.fit(logit(data), **kwargs)\n\nlogitnorm = logitnorm_gen(a=0.0, b=1.0, name=\"logitnorm\")\n\nThe logit-normal can capture many beta-like shapes, including both sparse and dense distributions and unimodal and bimodal distributions.\n\n\nPlotting code\nax = subplot()\n\nprobability = mgrid[0.01:1.0:0.01]\n\nmu_sigma = [\n    (0.0, 0.5),\n    (1.5, 0.5),\n    (0.0, 5.0)\n]\n\nfor mu, sigma in mu_sigma:\n    ax.plot(\n        probability, \n        logitnorm(mu, sigma).pdf(probability),\n        label=f\"LogitNormal({mu}, {sigma})\"\n    )\n    \nax.legend()\n\nax.set_xlabel(\"Probability\")\n_ = ax.set_ylabel(\"Density\")\n\n\n\n\n\nIn this case, we won’t be able to map this to a known distribution. We need to resort to approximating it.\n\\[\\begin{align*}\np(\\mathbf{x}) &= \\int p(\\mathbf{x} \\mid \\pi)p(\\pi; \\mu, \\sigma)\\,\\mathrm{d}\\pi\\\\\n&\\propto \\int \\pi^{\\sum_i x_i}(1-\\pi)^{\\sum_i (1-x_i) }\\frac{\\exp\\left(-\\frac  {(\\text{logit}(\\pi)-\\mu )^2}{2\\sigma^2}\\right)}{\\pi(1-\\pi)}\\,\\mathrm{d}\\pi\\\\\n&\\propto \\int \\pi^{\\sum_i x_i - 1}(1-\\pi)^{\\sum_i (1-x_i) - 1}\\exp\\left(-\\frac  {(\\text{logit}(\\pi)-\\mu )^2}{2\\sigma^2}\\right)\\,\\mathrm{d}\\pi\\\\\n\\end{align*}\\]\n\nMonte Carlo Integration\nOne way to do this is by brute force using some form of numerical integration–e.g. a Monte Carlo integration technique. In this case, we sample many (say, \\(K\\)) values \\(\\pi_k\\) from the logit-normal prior (which, I will assert, we know how to sample from), evaluate the likelihood under \\(\\pi_k\\), then average those likelihoods.\n\\[p(\\mathbf{x}) \\approx \\frac{1}{K}\\sum_{k=1}^K p(\\mathbf{x} \\mid \\pi_k) = \\frac{1}{K}\\sum_{k=1}^N \\pi_k^{\\sum_i x_i}(1-\\pi_k)^{\\sum_i (1-x_i) }\\]\n\nfrom numpy import ndarray, log\nfrom scipy.special import logsumexp\nfrom scipy.stats import bernoulli\n\ndef bernoulli_logit_normal_log_evidence(x: ndarray, mu: float, sigma: float, n_approx: int=1_000) -&gt; float:\n    \"\"\"The log-evidence of the data under a Bernoulli likelihood with logit-normal prior\n    \n    Parameters\n    ----------\n    x\n        The data\n    mu\n        The mean log-odds for the logit-normal\n    sigma\n        The standard deviation in the log-odds for the logit-normal\n    n_approx\n        The number of samples to draw in approximating the evidence\n    \"\"\"\n    n, = x.shape\n    \n    return logsumexp([\n        bernoulli(pi_bar_k).logpmf(x).sum()\n        for pi_bar_k in logitnorm(mu, sigma).rvs(n_approx)\n    ]) - log(n_approx)\n\nKeeping the number of observations \\(N\\) fixed, we can then plot the approximate log-evidence in terms of the proportion of true observations for different settings of the logit-normal parameters (\\(\\mu\\) and \\(\\sigma\\)).7\n\n\nPlotting code\nfrom numpy.random import seed\n\nseed(4329)\n\nax = subplot()\n\nmus = arange(-4, 5)\nsigmas = mgrid[0.1:1.1:0.1]\n\nfor mu in mus:\n    log_evidence = [\n        bernoulli_logit_normal_log_evidence(data, mu, sigma)\n        for sigma in sigmas\n    ]\n    ax.plot(sigmas, log_evidence, label=f\"LogitNormal({mu}, \"+ r\"$\\sigma$)\")\n\nax.legend()\n\nax.set_title(\"Log-evidence under different LogitNormal priors\")\nax.set_xlabel(r\"$\\sigma$\")\n_ = ax.set_ylabel(r\"$\\log p(\\mathbf{x})$\")\n\n\n\n\n\nThis approach works because we can sample \\(\\pi_k\\) from the prior. But it becomes hairy in the case where we don’t know how to draw such samples. For instance, suppose we want to compute the posterior predictive \\(p(x_\\text{new} \\mid \\mathbf{x}_\\text{old})\\).\n\\[p(x_\\text{new} \\mid \\mathbf{x}_\\text{old}) = \\int p(x_\\text{new}  \\mid \\pi)p(\\pi \\mid \\mathbf{x}_\\text{old})\\,\\mathrm{d}\\pi\\]\nIn this case, we need to be able to sample from the posterior \\(p(\\pi \\mid \\mathbf{x}_\\text{old})\\). But we don’t know how to sample from the posterior because, as we just saw, it doesn’t have a known distribution. One idea–the core idea of importance sampling–is to sample candidate \\(\\pi'_k\\)s from some proposal distribution \\(q(\\pi')\\) that we know how to sample from (e.g. in this case, the uniform is a reasonable choice) and then weight the average we aim to compute in the appropriate way. To see why this works, note that we can rewrite \\(p(x_\\text{new} \\mid \\mathbf{x}_\\text{old})\\) as an expectation of \\(\\Pi' \\sim q(\\cdot)\\).\n\\[\\begin{align*}\np(x_\\text{new} \\mid \\mathbf{x}_\\text{old}) &= \\int p(\\mathbf{x} \\mid \\pi)p(\\pi \\mid \\mathbf{x})\\,\\mathrm{d}\\pi\\\\\n&= \\int p(\\mathbf{x} \\mid \\pi)p(\\pi \\mid \\mathbf{x})\\frac{q(\\pi)}{q(\\pi)}\\,\\mathrm{d}\\pi\\\\\n&= \\int p(\\mathbf{x} \\mid \\pi')\\frac{p(\\pi' \\mid \\mathbf{x})}{q(\\pi')}q(\\pi')\\,\\mathrm{d}\\pi'\\\\\n&= \\mathbb{E}\\left[p(\\mathbf{x} \\mid \\Pi')\\frac{p(\\Pi' \\mid \\mathbf{x})}{q(\\Pi')}\\right]\n\\end{align*}\\]\nThis rewrite then allows us to sample from the proposal distribution–rather than the actual distribution–in approximating \\(p(x_\\text{new} \\mid \\mathbf{x}_\\text{old})\\) using Monte Carlo integration. We merely need to reweight the sample by \\(\\frac{p(\\pi \\mid \\mathbf{x})}{q(\\pi)}\\) to account for the fact that we are sampling from a different distribution.8\n\\[p(x_\\text{new} \\mid \\mathbf{x}_\\text{old}) \\approx \\frac{1}{K}\\sum_{k=1}^K p(x_\\text{new} \\mid \\pi'_k)\\frac{p(\\pi'_k \\mid \\mathbf{x}_\\text{old})}{q(\\pi'_k)}\\]\nNow, one thing you might have noticed is that we actually have to approximate two integrals to compute \\(p(x_\\text{new} \\mid \\mathbf{x}_\\text{old})\\): (i) the integral over the posterior we just handled; and (ii) the integral over the prior, which is implicit in the denominator of the posterior–the evidence \\(p(\\mathbf{x})\\) in \\(p(\\pi \\mid \\mathbf{x}) = \\frac{p(\\mathbf{x} \\mid \\pi)p(\\pi)}{p(\\mathbf{x})}\\). In principle, because the \\(p(\\mathbf{x})\\) is a constant relative to the first integral, we can pull it out and just compute it once.\n\\[p(x_\\text{new} \\mid \\mathbf{x}_\\text{old}) \\approx \\frac{1}{Kp(\\mathbf{x})}\\sum_{k=1}^N p(x_\\text{new} \\mid \\pi'_k)\\frac{p(\\mathbf{x}_\\text{old}\\mid\\pi'_k)p(\\pi'_k)}{q(\\pi'_k)}\\]\nBut since we don’t really care about it in the context of computing \\(p(x_\\text{new} \\mid \\mathbf{x}_\\text{old})\\), it would be nice if we could ignore it altogether. One way to do this is to take a different approach to sampling that attempts to actually produce a set of samples from the posterior, rather than drawing samples from some other distribution and subsequently reweighting them (as in importance sampling).\n\n\nMarkov Chain Monte Carlo\nMarkov chain Monte Carlo (MCMC) methods attempt to sample from the posterior directly. The idea behind MCMC is to start from some sample \\(\\theta\\) and then propose a new sample \\(\\theta'\\) conditioned on \\(\\theta\\) that we accept or reject based on how (i) probable that sample is under the distribution we are attempting to sample from; and (ii) how probable the previous sample was under the distribution we are attempting to sample from. If we accept the proposal, we log it and use it to condition the proposal of the new sample; otherwise, we try again using \\(\\theta\\) to condition the new proposal. Together, the sequence of \\(\\theta\\)s is our sample from the posterior.\nMCMC still requires us to evaluate the distribution of interest at each sample; but because it relies on comparison of the probabilities of the current sample and the proposal, the constant terms in that comparison cancel each other out–meaning we don’t need to worry about computing quantities, like the evidence \\(p(\\mathbf{x})\\), that we’re not interested in.\n\nMetropolis-Hastings samplers\nOne simple family of methods that can be useful in getting an intuition for how MCMC work are those that use the Metropolis-Hastings algorithm (MH). I’ll walk through how an MH sampler can be built for the example above; but know that, for the remainder of the course, we will use STAN to automatically construct and deploy samplers that use Hamiltonian Monte Carlo, which has various benefits over simpler approaches but which is somewhat different from the simple MH algorithm I’ll present here.\nSimilar to importance sampling, the basic idea behind the MH algorithm is to define some proposal distribution \\(q(\\theta' \\mid \\theta)\\) for generating proposals. Unlike in importance sampling, this distribution is generally conditioned on the previous sample \\(\\theta_{k-1}\\). We start the sampler by choosing some initial sample \\(\\theta_0\\). Then, for each sample \\(k\\) we’d like to draw we:\n\nSample a candidate \\(\\theta'_k \\sim q(\\cdot \\mid \\theta_{k-1})\\)\nCalculate the acceptance ratio \\(\\alpha_k = \\frac{p(\\theta'_k \\mid \\mathbf{x})q(\\theta'_k \\mid \\theta_{k-1})}{p(\\theta_{k-1} \\mid \\mathbf{x})q(\\theta_{k-1} \\mid \\theta'_k)}\\)\nSample whether to accept the proposal \\(a_k \\sim \\text{Bernoulli}(\\min(\\alpha_k, 1))\\)\nIf \\(a_k\\), set \\(\\theta_k = \\theta'_k\\); otherwise \\(\\theta_k = \\theta_{k-1}\\)\n\nIn the case of our Bernoulli-logit normal model, we could define a relatively simple proposal distribution \\(\\mathcal{U}(l_k, u_k)\\), where \\(l_k \\equiv \\max\\left(0, \\theta_{k-1} - \\frac{\\delta}{2}\\right)\\), \\(u_k \\equiv \\min\\left(1, \\theta_{k-1} + \\frac{\\delta}{2}\\right)\\), and \\(\\delta\\) is a parameter of the sampler. This proposal distribution ensures that the proposal \\(\\pi'_k \\in [0, 1]\\) and that we only ever propose samples at most \\(\\frac{\\delta}{2}\\) from \\(\\pi_{k-1}\\).9\n\nfrom numpy import array, exp, corrcoef\nfrom scipy.stats import uniform\n\nclass BernoulliLogitNormalPosteriorMHSampler:\n    \"\"\"A Metropolis-Hastings sampler for a Bernoulli-LogitNormal model\n    \n    Parameters\n    ----------\n    mu\n        mean log-odds for LogitNormal\n    sigma\n        standard deviation for LogitNormal\n    \"\"\"\n    def __init__(self, mu: float, sigma: float):\n        self.mu = mu\n        self.sigma = sigma\n        \n    def _initialize(self, x: ndarray, n_samples: int, delta: float):\n        # save the data `x` and sampler parameter `delta`\n        self.x = x\n        self.delta = delta\n        \n        # initialize the samples to -inf so it is easier to detect bugs\n        # in the sampler implementation\n        self.samples = zeros(n_samples) - inf\n        \n        # set the initial sample to the mean of the data (the MLE)\n        self.sample[0] = x.mean()\n        \n        # initialize the log unnormalized posterior for the samples \n        # to -inf\n        self.lup = zeros(n_samples) - inf\n        \n        # set the initial log unnormalized posterior to the log \n        # unnormalized posterior for the initial sample\n        self.lup[0] = self._log_unnormalized_posterior(self.samples[0])\n    \n    def fit(self, x: ndarray, n_samples: int = 20_000, delta: float = 0.1, \n            burnin: int = 2_000, thinning: int = 100, \n            verbosity: int = 0) -&gt; 'BernoulliLogitNormalPosteriorMHSampler':\n        self._initialize(x, n_samples, delta)\n        \n        acceptance_count = 0\n        \n        for k in range(1, n_samples):\n            # sample proposal\n            pi_prime_k = self._propose(k)\n            \n            # log transition probabilities\n            ltp_f, ltp_b = self._log_transition_prob(pi_prime_k, k)\n            \n            # log unnormalized posterior for pi_prime_k\n            lup = self._log_unnormalized_posterior(pi_prime_k)\n            \n            # log acceptance ratio\n            lar = (lup + ltp_f) - (self.lup[k-1] + ltp_b)\n            \n            # acceptance probability\n            ap = min(exp(lar), 1)\n            \n            # sample whether to accept\n            accept, = bernoulli(ap).rvs(1)\n            \n            # save sample\n            if accept:\n                self.samples[k] = pi_prime_k\n                self.lup[k] = lup\n                \n                acceptance_count += 1\n                \n            else:\n                self.samples[k] = self.samples[k-1]\n                self.lup[k] = self.lup[k-1]\n\n            if verbosity and k and not (k % verbosity):\n                print(f\"Sample {k}\")\n                print(f\"Acceptance proportion: {round(acceptance_count / k, 2)}\")\n                print(f\"Sample:                {round(self.samples[k], 2)}\")\n                print()\n                \n        # throw out burn-in samples and thin samples\n        self.samples = self.samples[burnin::thinning]\n                \n        if verbosity:\n            autocorrelation = corrcoef(self.samples[:-1], self.samples[1:])[1,0]\n            print(f\"Autocorrelation: {autocorrelation}\")\n            print()\n                \n        return self\n            \n    def _propose(self, k: int) -&gt; float:\n        l, u = self._proposal_bounds(\n            self.samples[k-1], self.delta\n        )\n        \n        # uniform parameterized by (loc, loc + scale)\n        pi_prime_k, = uniform(l, u - l).rvs(1)\n        \n        return pi_prime_k\n    \n    def _log_transition_prob(self, pi_prime_k: float, k: int) -&gt; float:\n        # forward proposal bounds\n        l_f, u_f = self._proposal_bounds(\n            self.samples[k-1], self.delta\n        )\n        \n        # forward log transition probability\n        ltp_f = uniform(l_f, u_f - l_f).logpdf(pi_prime_k)\n        \n        # backward proposal bounds\n        l_b, u_b = self._proposal_bounds(\n            pi_prime_k, self.delta\n        )\n        \n        # backward log transition probability\n        ltp_b = uniform(l_b, u_b - l_b).logpdf(self.samples[k-1])\n        \n        return ltp_f, ltp_b\n        \n    def _log_unnormalized_posterior(self, pi: float):\n        log_likelihood = bernoulli(pi).logpmf(self.x).sum()\n        log_prior = logitnorm(self.mu, self.sigma).logpdf(pi)\n        \n        return log_likelihood + log_prior\n    \n    def _proposal_bounds(self, pi: float, delta: float) -&gt; Tuple[float]:\n        d = delta/2\n        a, b = pi + array([-d, d])\n        \n        return max(a, 0), min(b, 1)\n\nWe’ll fit this using a \\(\\text{LogitNormal}(0, 1)\\) prior.10\n\nseed(302928)\n\nmh_sampler = BernoulliLogitNormalPosteriorMHSampler(0., 1.)\n\nFor comparison, a \\(\\text{LogitNormal}(0, 1)\\) prior has a relatively similar shape to a \\(\\text{Beta}(2, 2)\\) prior.\n\n\nPlotting code\nax = subplot()\n\nprobability = mgrid[0.01:1.0:0.01]\n\nax.plot(\n    probability, \n    logitnorm(0, 1).pdf(probability),\n    label=f\"LogitNormal(0, 1)\"\n)\n\nax.plot(\n    probability, \n    beta(2, 2).pdf(probability),\n    label=f\"Beta(2, 2)\"\n)\n    \nax.legend()\n\nax.set_xlabel(\"Probability\")\n_ = ax.set_ylabel(\"Density\")\n\n\n\n\n\nIf we run this sampler and then plot the posterior samples, we get an approximation to the posterior distribution that is very close to the analytically computable posterior distribution under the assumption that the prior is distributed beta.\n\n_ = mh_sampler.fit(data, delta=0.01)\n\n&lt;__main__.BernoulliLogitNormalPosteriorMHSampler at 0xffff61e92c50&gt;\n\n\n\n\nPlotting code\nax = subplot()\n\nax.set_xlim(0, 1)\n\nax.hist(mh_sampler.samples, bins=10, density=True, label=\"Approximate posterior under LogitNorm(0, 1) prior\")\nax.plot(\n    mgrid[0.01:1.0:0.01], \n    beta(\n        2 + data.sum(), \n        2 + (1-data).sum()).pdf(mgrid[0.01:1.0:0.01]\n    ), \n    label=\"True posterior under Beta(2, 2) prior\"\n)\n\nax.legend()\n\nax.set_title(r\"Approximate posterior distribution of $\\pi$\")\nax.set_xlabel(r\"$p(\\pi \\mid \\mathbf{x})$\")\n_ = ax.set_ylabel(\"Density\")\n\n\n\n\n\n\n\nImplementing samplers in STAN\nIt is quite rare to implement MCMC samplers by hand nowadays. In general, we would rather use some software package that allows us to specify our desired distributional assumptions and then builds a sampler programmatically based on those assumptions. STAN, which is the package we will use, is a popular choice for doing this. Other packages for doing this in python are pymc and pyro.\nThe way we construct a model in STAN is by declaring the form of the data (including both the data we are modeling and any parameters of the priors) and the distributional assumptions that make up the model. These are specified in program blocks.\nThe data block specifies what the inputs STAN can expect to receive look like.\ndata {\n    int N;                             // number of datapoints\n    real mu;                           // prior mean\n    real sigma;                        // prior standard deviation\n    int&lt;lower=0, upper=1&gt; x[N];        // datapoints \n}\nThe parameters block specifies which parameters STAN will need to sample.\nparameters {\n    real logodds;                      // log-odds of success\n}\nIn our case, we are specifying an auxiliary variable logodds that corresponds to \\(\\text{logit}(\\pi) = \\log\\frac{\\pi}{1 - \\pi}\\). The reason we are doing it this way is that \\(\\pi \\sim \\text{LogitNormal}(\\mu, \\sigma)\\) is equivalent to saying that \\(\\text{logit}(\\pi) \\sim \\mathcal{N}(\\mu, \\sigma)\\), and STAN does not specify a logit-normal distribution in its standard library of distributions. So what we will do it sample logodds \\(= \\text{logit}(\\pi)\\), then compute \\(\\text{logit}^{-1}(\\)logodds\\() = \\text{logit}^{-1}(\\text{logit}(\\pi)) = \\pi\\), which we can do using STAN’s transformed parameters block.\nThe transformed parameters block specifies which transformations of the sampled parameters are needed in parameterizing some other distribution.11\ntransformed parameters {\n    real pi = inv_logit(logodds);      // probability of success\n}\nIn this case, we use it to compute \\(\\pi = \\text{logit}^{-1}(\\)logodds\\()\\) from a sampled logodds deterministically.\nFinally, model block specifies the distributional assumptions of the model.12\nmodel {\n    logodds ~ normal(mu, sigma);\n    x ~ bernoulli(pi);\n}\nIn our case, we state that logodds \\(\\sim \\text{LogitNormal}(\\mu, \\sigma)\\) and \\(X_i \\sim \\text{Bernoulli}(\\pi)\\).13\nTo interface with STAN, which maps the above model specification to C++ code, we will use cmdstanpy, which is a light wrapper around cmdstan. cmdstan provides tools for executing the sampler code built by STAN, and cmdstanpy provides wrappers around those tools.\n\n\nSilence STAN logger\nimport logging\nlogger = logging.getLogger('cmdstanpy')\nlogger.addHandler(logging.NullHandler())\nlogger.propagate = False\nlogger.setLevel(logging.CRITICAL)\n\n\n\nfrom cmdstanpy import CmdStanModel\n\nstan_model = CmdStanModel(\n    stan_file=\"bernoulli-logit-normal-model.stan\"\n)\nmodel_data = {\n    \"N\": data.shape[0],\n    \"mu\": 0.0,\n    \"sigma\": 1.0,\n    \"x\": data\n}\nmodel_fit = stan_model.sample(\n    data=model_data, \n    iter_warmup=10_000, iter_sampling=10_000,\n    show_progress=False,\n    seed=304938\n)\n\nWe can then use arviz to quickly plot the posteriors for the parameters. And again, we get something very similar to what we observed with our Metropolis-Hastings sampler.\n\nfrom arviz import plot_posterior\n\n_ = plot_posterior(model_fit)"
  },
  {
    "objectID": "foundational-concepts-in-probability-and-statistics/statistical-inference.html#footnotes",
    "href": "foundational-concepts-in-probability-and-statistics/statistical-inference.html#footnotes",
    "title": "Statistical Inference",
    "section": "Footnotes",
    "text": "Footnotes\n\n\nWe won’t use it here, but the pronoun relative frequencies visualized here are derived from pronoun_count below using {p: c / pronoun_count.total() for p, c in pronoun_count.items()}.↩︎\nI’m using \\(\\mathcal{L}_\\mathbf{x}(\\pi)\\) to emphasize that \\(\\mathcal{L}\\) is parameterized by \\(\\mathbf{x}\\). Another notation, which means the same thing but which I think is initially more confusing, is \\(\\mathcal{L}(\\pi \\mid \\mathbf{x})\\). I will return to why this notation makes sense in a second.↩︎\nIf you’re not familiar with this direct proportionality notation, \\(x \\propto y\\) just means that there is some non-zero constant \\(k\\) such that \\(x = ky\\).↩︎\nNote that this implies that \\(p(\\theta \\mid \\mathbf{x}) \\propto p(\\theta, \\mathbf{x})\\).↩︎\nNote, again, the use of a pipe for the PMF of \\(X\\) and a semicolon for the PDF of \\(\\Pi\\). This notation is used to denote that \\(\\pi\\) is the value of some random variable, whereas \\(\\alpha\\) and \\(\\beta\\) are given by some oracle–namely, us.↩︎\nIndeed, we’ve already seen another: it turns out that the negative binomial distribution can be viewed as a compound probability distribution.↩︎\nNote that each proportion \\(p \\in \\left\\{\\frac{1}{N}, \\frac{2}{N}, \\ldots, 1\\right\\}\\) corresponds to \\({N \\choose pN}\\) possible \\(\\mathbf{x}\\)s but that the log-evidence must be the same for each such \\(\\mathbf{x}\\) if the likelihood is Bernoulli.↩︎\nTo develop additional intuition for why this reweighting is necessary: consider a very simple case where we are trying to approximate the expectation \\(\\mathbb{E}[U] = \\int u\\,p(u)\\,\\mathrm{d}u\\) of a uniform random variable \\(U \\sim \\mathcal{U}(0, 1)\\) with importance sampling. (We would never do this–not least because we can easily compute the expected value analytically–but it is useful for illustrating the point.) And suppose we chose as our proposal distribution \\(U'_k \\sim \\text{Beta}(2, 1)\\). If we didn’t reweight by \\(\\frac{\\mathcal{U}(u'_k; 0, 1)}{\\text{Beta}(u'_k; 2, 1)} = \\frac{1}{\\text{Beta}(u'_k; 2, 1)}\\), we’d end with the expectation of \\(U'_k\\), which is \\(\\frac{2}{3}\\), not \\(U\\), which is \\(\\frac{1}{2}\\)!↩︎\nAnother good alternative would be a \\(\\text{LogitNormal}\\left(\\text{logit}^{-1}(\\pi_{k-1}), \\sigma\\right)\\), where \\(\\sigma\\) is analogous to \\(\\delta\\) above, or a \\(\\text{Beta}(\\nu\\pi_{k-1}, \\nu(1-\\pi_{k-1}))\\), where \\(\\nu\\) is (inversely) analogous to \\(\\delta\\).↩︎\nIn light of the amount of data we have, the prior is not going to matter very much.↩︎\nSTAN also provides an anologous transformed data block for transformations of the input data.↩︎\nThere is an additional available kind of program block: the useful and important generated quantities block, which I will not cover here.↩︎\nThe indexation on the latter is implicit in STAN’s vectorization conventions.↩︎"
  },
  {
    "objectID": "island-effects/index.html",
    "href": "island-effects/index.html",
    "title": "Module 1: Island Effects",
    "section": "",
    "text": "Availability\n\n\n\nThis section will be available Monday, 19 June 2023. Please complete the below reading prior to that date.\n\n\n\n\n\n\n\n\nReading\n\n\n\n\nSprouse et al. (2016) on variation in the strength of island effects on acceptability judgments. We will use the data collected for that paper, which can be found here, in this module.\nSprouse (2018) on the relationship between acceptability and grammaticality. We will specifically be concerned with his discussion of what apparent gradience in acceptability implies about discreteness v. continuity in grammatical representations.\n\n\n\n\n\n\n\nReferences\n\nSprouse, Jon. 2018. “Acceptability Judgments and Grammaticality, Prospects and Challenges.” In The Impact of the Chomskyan Revolution in Linguistics, edited by Norbert Hornstein, Howard Lasnik, Pritty Patel-Grosz, and Charles Yang, 195–224. Berlin, Boston: De Gruyter Mouton. https://doi.org/doi:10.1515/9781501506925-199.\n\n\nSprouse, Jon, Ivano Caponigro, Ciro Greco, and Carlo Cecchetto. 2016. “Experimental Syntax and the Variation of Island Effects in English and Italian.” Natural Language & Linguistic Theory 34: 307–44. https://doi.org/10.1007/s11049-015-9286-8."
  },
  {
    "objectID": "projective-content/index.html",
    "href": "projective-content/index.html",
    "title": "Module 2: Projective Content",
    "section": "",
    "text": "Availability\n\n\n\nThis section will be available Thursday, 22 June 2023. Please complete the below reading prior to that date.\n\n\n\n\n\n\n\n\nReading\n\n\n\nData: Degen and Tonhauser (2021) on how prior beliefs modulate projectivity inferences. We will use the data collected for that paper, which can be found here, in this module.\nTheory: Degen and Tonhauser (2022) on whether there is a discrete category of factive predicates. As shown in Kane, Gantt, and White (2022), the main conceit of the paper–that there is no such discrete category–does not hold up under empirical scrutiny. We will rather be concerned with their discussion–broadly, but most specifically in Section 4–about the sources of gradience.\n\n\n\n\n\n\nReferences\n\nDegen, Judith, and Judith Tonhauser. 2021. “Prior Beliefs Modulate Projection.” Open Mind 5 (September): 59–70. https://doi.org/10.1162/opmi_a_00042.\n\n\n———. 2022. “Are There Factive Predicates? An Empirical Investigation.” Language 98 (3): 552–91. https://doi.org/10.1353/lan.0.0271.\n\n\nKane, Benjamin, Will Gantt, and Aaron Steven White. 2022. “Intensional Gaps: Relating Veridicality, Factivity, Doxasticity, Bouleticity, and Neg-Raising.” Semantics and Linguistic Theory 31 (January): 570–605. https://doi.org/10.3765/salt.v31i0.5137."
  },
  {
    "objectID": "selection/index.html",
    "href": "selection/index.html",
    "title": "Selection",
    "section": "",
    "text": "Reading\n\n\n\nData: White and Rawlins (2020) on collecting a broad-coverage acceptability judgment dataset focused on complement clauses and White and Rawlins (2016) on using that dataset to develop a computational model of selection. We will use the data collected for those papers, which can be found here, in this module.\nTheory: Lohninger and Wurmbrand (to appear) on the typology of complement clauses. We will specifically be concerned with their hypothesis that the distributional complement clauses is constrained by a monotonicity constraint relating ordered semantic types to ordered syntactic types.\nTELL ENT ENT PROP\nB       B      B       B      I         I\nsomeone told   someone that   something happened\n#!wget http://megaattitude.io/projects/mega-acceptability/mega-acceptability-v1.zip -P data/\n#!unzip data/mega-acceptability-v1.zip -d data/\n\ndata_dir = \"./data/mega-acceptability-v1/\"\nimport os\nimport pandas as pd\n\ndef load_data(fname: str, verbose: bool = True) -&gt; pd.DataFrame:\n    # read the raw data skipping comment rows at the beginning\n    data = pd.read_csv(fname, sep=\"\\t\")\n    \n    if verbose:\n        n_datapoints = data.shape[0]\n        print(f\"The full dataset has {n_datapoints} datapoints.\")\n    \n    # remove non-native speakers\n    data = data.query(\"nativeenglish\")\n    \n    if verbose:\n        n_datapoints_native = data.shape[0]\n        print(f\"Removing {n_datapoints - n_datapoints_native} \"\n              \"responses from nonnative speakers.\")\n    \n    # remove NaN judgments\n    data = data.query(\"~response.isnull()\")\n    \n    if verbose:\n        n_datapoints_nonnull = data.shape[0]\n        print(f\"Removing {n_datapoints_native - n_datapoints_nonnull} NA responses.\")\n    \n    return data\ndata = load_data(os.path.join(data_dir, \"mega-acceptability-v1.tsv\"))\n\ndata\n\nThe full dataset has 250000 datapoints.\nRemoving 600 responses from nonnative speakers.\nRemoving 10 NA responses.\n\n\n\n\n\n\n\n\n\nparticipant\nlist\npresentationorder\nverb\nframe\nresponse\nnativeenglish\nsentence\n\n\n\n\n0\n4\n862\n1\nturn_out\nNP was Ved whichNP to VP\n2.0\nTrue\nSomeone was turned out which thing to do.\n\n\n1\n381\n862\n1\nturn_out\nNP was Ved whichNP to VP\n1.0\nTrue\nSomeone was turned out which thing to do.\n\n\n2\n395\n862\n1\nturn_out\nNP was Ved whichNP to VP\n2.0\nTrue\nSomeone was turned out which thing to do.\n\n\n3\n621\n862\n1\nturn_out\nNP was Ved whichNP to VP\n1.0\nTrue\nSomeone was turned out which thing to do.\n\n\n4\n527\n862\n1\nturn_out\nNP was Ved whichNP to VP\n1.0\nTrue\nSomeone was turned out which thing to do.\n\n\n...\n...\n...\n...\n...\n...\n...\n...\n...\n\n\n249995\n113\n928\n50\nmadden\nNP Ved about NP\n4.0\nTrue\nSomeone maddened about something.\n\n\n249996\n32\n928\n50\nmadden\nNP Ved about NP\n2.0\nTrue\nSomeone maddened about something.\n\n\n249997\n544\n928\n50\nmadden\nNP Ved about NP\n1.0\nTrue\nSomeone maddened about something.\n\n\n249998\n727\n928\n50\nmadden\nNP Ved about NP\n7.0\nTrue\nSomeone maddened about something.\n\n\n249999\n294\n928\n50\nmadden\nNP Ved about NP\n1.0\nTrue\nSomeone maddened about something.\n\n\n\n\n249390 rows × 8 columns\nWhite and Rawlins (2016) model the ordinal acceptability judgments \\(r_i\\) associated with a sentence \\(s_i\\) to be a function of the probability \\(\\alpha_{vf}\\) that the main clause verb \\(v = \\text{verb}(i)\\) in \\(s_i\\) is acceptable in the syntactic frame \\(f = \\text{frame}(i)\\) instantiated in \\(s_i\\).1 They model this probability as a function of two other kinds of probability: (i) the probability \\(\\lambda_{vs}\\) that a particular verb \\(v\\) can have a particular semantic type signature \\(s\\); and (ii) the probability \\(\\mu_{sf}\\) that a particular semantic type signature \\(s\\) can be mapped onto a particular syntactic frame \\(f\\).\nThe basic idea is that we should predict a verb to be good–modulo other factors, such as its case assignment properties (pesetsky_zero_1991?)–in a particular syntactic frame insofar as it can have at least one semantic type signature that maps onto that frame. That is, they define the probability \\(\\alpha_{vf}\\) that a main clause verb \\(v\\) is acceptable in a syntactic frame \\(f\\) to be \\(p\\left(\\bigvee_s l_{vs} \\land m_{sf}\\right)\\), where:\n\\[\\begin{align*}\nl_{vs} &= \\begin{cases}\n\\top & \\text{if } v \\text{ can have semantic type signature } s\\\\\n\\bot & \\text{otherwise}\n\\end{cases}\\\\\nm_{sf} &= \\begin{cases}\n\\top & \\text{if } s \\text{ can map onto syntactic frame } f\\\\\n\\bot & \\text{otherwise}\n\\end{cases}\n\\end{align*}\\]\nInsofar as a verb’s having a particular type signature is independent of that type signature mapping onto a particular syntactic frame, this probability can be factored into an expression in terms of \\(\\lambda_{vs}\\) and \\(\\mu_{sf}\\):\n\\[\\begin{align*}\np\\left(\\bigvee_s l_{vs} \\land m_{sf}\\right) &= p\\left(\\lnot\\lnot\\bigvee_s l_{vs} \\land m_{sf}\\right)\\\\\n&= 1 - p\\left(\\lnot\\bigvee_s l_{vs} \\land m_{sf}\\right)\\\\\n&= 1 - p\\left(\\bigwedge_s \\lnot\\left[ l_{vs} \\land m_{sf}\\right]\\right)\\\\\n&= 1 - \\prod_s p\\left(\\lnot\\left[ l_{vs} \\land m_{sf}\\right]\\right)\\\\\n&= 1 - \\prod_s 1 - p\\left(l_{vs} \\land m_{sf}\\right)\\\\\n&= 1 - \\prod_s 1 - p\\left(l_{vs}\\right)p\\left(m_{sf}\\right)\\\\\n&= 1 - \\prod_s 1 - \\lambda_{vs}\\mu_{sf}\\\\\n\\end{align*}\\]\nImportantly, they assume: (a) that verbs can be compatible with multiple semantic type signatures; (b) that multiple semantic type signatures can map onto the same frame; and (c) that multiple frames can be mapped onto by the same semantic type signature. So \\(\\sum_s \\lambda_{vs}\\) and \\(\\sum_s \\mu_{sf}\\) can be anywhere between \\(0\\) and the number of type signatures, and \\(\\sum_f \\mu_{sf}\\) can be anywhere between \\(0\\) and the number of syntactic frames. None of the three need to be \\(1\\).\nSolving for \\(\\lambda_{vs}\\) and \\(\\mu_{sf}\\), from which \\(\\alpha_{vf}\\) can be computed deterministically, is an instance of a matrix factorization problem–of which principal component analysis [PCA; Pearson (1901)], factor analysis, and postive/non-negative matrix factorization [NMF; Paatero and Tapper (1994)] are common forms.\nfrom numpy import ndarray\nfrom pandas import CategoricalDtype\n\ndef hash_series(series: pd.Series, categories: Optional[list[str]] = None, indexation: int=1) -&gt; tuple[ndarray, ndarray]:\n    \"\"\"Hash a series to numeric codes\n    \n    Parameters\n    ----------\n    column\n        The series to hash\n    index\n        The starting index (defaults to 1)\n    \"\"\"\n    # enforce 0- or 1-indexation\n    if indexation not in [0, 1]:\n        raise ValueError(\"Must choose either 0- or 1-indexation.\")\n    \n    # convert the series to a category\n    if categories is None:\n        category_series = series.astype(\"category\")\n    else:\n        cat_type = CategoricalDtype(categories=categories)\n        category_series = series.astype(cat_type)\n    \n    # get the hash\n    hash_map = category_series.cat.categories.values\n    \n    # map to one-indexed codes\n    hashed_series = (category_series.cat.codes + indexation).values\n    \n    return hash_map, hashed_series\nimport cmdstanpy, arviz\nfrom cmdstanpy import CmdStanModel\nfrom typing import Optional\nfrom enum import Enum\nfrom dataclasses import dataclass\nfrom arviz import InferenceData\n\nclass FitType(Enum):\n    OPTIMIZE = 0\n    SAMPLE = 1\n\n@dataclass\nclass SelectionData:\n    N_verb: int\n    N_frame: int\n    N_component: int\n    N_subj: int\n    N_resp: int\n    N_resp_levels: int\n    verb: ndarray\n    frame: ndarray\n    subj: ndarray\n    resp: ndarray\n    \nclass UnconstrainedSelectionModel:\n    stan_file = \"./models/fuzzy-logic-factorization.stan\"\n    data_class = SelectionData\n    \n    def __init__(self, n_component: int):\n        self.model = CmdStanModel(stan_file=self.stan_file)\n        self.n_component = n_component\n        \n    def construct_model_data(self, data: pd.DataFrame):\n        self.verb_hash_map, verb_hashed = hash_series(data.verb)\n        self.frame_hash_map, frame_hashed = hash_series(data.frame)\n        self.subj_hash_map, subj_hashed = hash_series(data.participant)\n        \n        model_data = {\n            \"N_verb\": self.verb_hash_map.shape[0],\n            \"N_frame\": self.frame_hash_map.shape[0],\n            \"N_component\": self.n_component,\n            \"N_subj\": self.subj_hash_map.shape[0],\n            \"N_resp\": data.shape[0],\n            \"N_resp_levels\": 7,\n            \"verb\": verb_hashed,\n            \"frame\": frame_hashed,\n            \"subj\": subj_hashed,\n            \"resp\": data.response.astype(int).values\n        }\n        \n        return model_data\n        \n    def _validate_data(self):\n        self.data_class(**self.model_data)\n\n    def fit(\n        self, \n        data: pd.DataFrame,\n        fit_type: FitType = FitType.OPTIMIZE,\n        save_dir: Optional[str] = None,\n        verbose: bool = True, \n        show_progress: bool = True\n    ) -&gt; InferenceData:\n        self.model_data = self.construct_model_data(data)\n        \n        self._validate_data()\n        \n        if verbose:\n            print(\"Fitting model...\")\n        \n        self.fit_type = fit_type\n        \n        if fit_type == FitType.OPTIMIZE:\n            self.raw_model_fit = self.model.optimize(\n                data=self.model_data\n            )\n        else:\n            self.raw_model_fit = self.model.sample(\n                data=self.model_data, \n                show_progress=show_progress\n            )\n    \n        if save_dir is not None:\n            if verbose:\n                print(\"Saving model...\")\n\n            self.save(save_dir)\n        \n        if verbose:\n            print(\"Saving model...\")\n    \n        return self\n    \n    def pointwise_log_likelihoods(self, data: Optional[pd.DataFrame] = None, **kwargs) -&gt; InferenceData:\n        if data is None:\n            model_data = self.model_data\n        else:\n            model_data = self.construct_model_data(data, **kwargs)\n            \n        log_likelihoods = self.model.generate_quantities(\n            data=model_data, \n            previous_fit=self.raw_model_fit\n        )\n\n        return arviz.from_cmdstanpy(log_likelihoods)\n    \n    @property\n    def model_fit(self):\n        if fit_type == FitType.OPTIMIZE:\n            return self.raw_model_fit\n        else:\n            return arviz.from_cmdstanpy(self.raw_model_fit)\n    \n    def save(self, save_dir: str = \".\"):\n        self.raw_model_fit.save_csvfiles(save_dir)\n    \n    @classmethod\n    def from_csv(cls, path: str, **kwargs):\n        model = cls(**kwargs)\n        model.raw_model_fit = cmdstanpy.from_csv(path)\nmodel = UnconstrainedSelectionModel(2, 1., False).fit(data, fit_type=FitType.OPTIMIZE)\n\nTypeError: FuzzyLogicFactorizationModel.__init__() takes 2 positional arguments but 4 were given\nimport seaborn as sns\n\nfrom scipy.stats import spearmanr\n\ndata[\"prediction\"] = model.raw_model_fit.stan_variable('mu')\n\n_ = sns.boxplot(data, x=\"response\", y=\"prediction\")\n\nspearmanr(data[[\"response\", \"prediction\"]])\n\nSignificanceResult(statistic=0.40889891447222454, pvalue=0.0)\nmodel.raw_model_fit.stan_variables()\n\n{'verb_component_prior_aux': array([0.128443, 0.125146, 0.656217, 0.779327, 0.827608, 0.312784,\n        0.848003, 0.808027, 0.422028, 0.375185, 0.353681, 0.327297,\n        0.733399, 0.854325, 0.778634, 0.227325, 0.146691, 0.721576,\n        0.527884, 0.123827, 0.275521, 0.370464, 0.702175, 0.879695,\n        0.138056, 0.174648, 0.21029 , 0.766008, 0.151918, 0.292663]),\n 'frame_component_prior_aux': array([0.128859, 0.439508, 0.856828, 0.384938, 0.652028, 0.662436,\n        0.824644, 0.492884, 0.45846 , 0.13276 , 0.347303, 0.768129,\n        0.386184, 0.876037, 0.26281 , 0.127104, 0.329268, 0.743779,\n        0.685283, 0.393859, 0.327524, 0.212908, 0.138822, 0.342837,\n        0.870582, 0.866983, 0.29064 , 0.391456, 0.875311, 0.81953 ]),\n 'verb_component_prior_precision': array([3.94606 , 6.85934 , 2.14684 , 0.355818, 4.316   , 0.66685 ,\n        2.00714 , 2.95657 , 0.277982, 0.313856, 3.66564 , 3.61452 ,\n        0.270871, 6.10048 , 0.198073, 0.690347, 0.306669, 0.487583,\n        0.321813, 0.260728, 0.31567 , 2.29999 , 2.5018  , 0.404016,\n        1.23719 , 4.43367 , 0.811716, 2.26288 , 4.82592 , 0.685407]),\n 'frame_component_prior_precision': array([2.47689 , 6.94865 , 1.14166 , 0.836653, 0.262048, 3.33315 ,\n        1.06894 , 2.26159 , 0.192062, 2.89519 , 0.906216, 0.373096,\n        2.43317 , 0.250202, 0.304647, 0.292793, 2.11231 , 0.964812,\n        2.65006 , 1.22376 , 2.49388 , 1.91038 , 1.1461  , 0.1658  ,\n        1.44303 , 4.07296 , 2.55249 , 3.40739 , 6.50941 , 0.165849]),\n 'verb_component': array([[0.631036, 0.12458 , 0.750635, ..., 0.713654, 0.701122, 0.859162],\n        [0.484222, 0.319344, 0.861388, ..., 0.580126, 0.725599, 0.86963 ],\n        [0.851271, 0.499822, 0.655394, ..., 0.187742, 0.133366, 0.73629 ],\n        ...,\n        [0.456762, 0.502419, 0.210684, ..., 0.217777, 0.839811, 0.631872],\n        [0.134225, 0.769278, 0.559535, ..., 0.195162, 0.213416, 0.876293],\n        [0.207543, 0.879065, 0.863831, ..., 0.855847, 0.12572 , 0.339096]]),\n 'frame_component': array([[0.148117, 0.139249, 0.867981, ..., 0.217972, 0.787618, 0.690592],\n        [0.143749, 0.607432, 0.713306, ..., 0.49488 , 0.72556 , 0.812185],\n        [0.239083, 0.560894, 0.251543, ..., 0.14582 , 0.198369, 0.138268],\n        ...,\n        [0.584786, 0.405192, 0.493362, ..., 0.797333, 0.353267, 0.154806],\n        [0.298372, 0.119673, 0.287615, ..., 0.747307, 0.389407, 0.160099],\n        [0.66831 , 0.50375 , 0.194715, ..., 0.608931, 0.436724, 0.751809]]),\n 'scale': 0.342677,\n 'subject_intercept': array([ 4.74424e-01,  5.81169e-01,  1.52451e-01, -1.21523e+00,\n        -3.76642e-01,  4.12773e-01,  4.93730e-01, -1.55746e+00,\n         4.30370e-01, -2.45055e-03, -4.16315e-01, -9.36667e-01,\n        -1.57720e+00,  8.99032e-01, -3.84752e-01, -7.86858e-01,\n         5.51128e-01, -8.23691e-01,  2.46000e-01, -9.24073e-01,\n        -5.02015e-01,  5.28516e-01,  7.43493e-03, -6.26881e-02,\n        -1.12118e+00, -8.09475e-01,  8.53874e-01,  3.55306e-01,\n        -1.24594e+00, -6.87277e-02, -1.80899e-01, -1.91844e-01,\n         3.68925e-01, -1.21469e+00, -9.09536e-01, -1.11137e+00,\n         1.25902e-01, -3.76982e-01,  7.98636e-01,  5.91311e-02,\n        -6.42357e-01,  2.30568e-01, -5.81096e-01,  3.53952e-01,\n         2.48313e-01, -1.33410e+00,  7.01760e-01,  6.26869e-01,\n        -1.04620e+00, -6.86099e-03,  6.30465e-01,  8.49885e-01,\n        -1.13165e+00, -2.04142e+00,  3.30557e-01,  9.89475e-01,\n         5.87273e-01, -8.70097e-01,  1.64817e+00, -3.46082e-01,\n         2.48271e-01, -1.45393e-01,  7.38582e-01, -3.39631e-01,\n         9.56582e-02, -7.41979e-01,  6.49592e-01,  9.33503e-01,\n         1.56984e+00, -4.53466e-01,  5.06329e-01, -5.76661e-01,\n         2.65088e+00,  9.89681e-01,  1.07587e+00, -1.29228e+00,\n         4.34748e-01,  1.30630e-01,  5.28397e-02, -1.84634e+00,\n        -3.37688e-02, -5.73385e-01, -1.37377e+00, -3.23291e-01,\n         5.50752e-01, -1.52814e+00,  7.78625e-01,  2.76436e-01,\n         3.18751e-01, -2.71143e-01,  2.58047e-01, -5.05047e-01,\n         5.30805e-01,  3.67817e-01,  2.02014e-02, -1.44350e+00,\n         3.49213e-02,  2.71423e-01,  5.93516e-01,  6.83710e-01,\n        -8.02496e-01, -1.08427e+00, -7.12690e-01, -5.94339e-01,\n         1.18571e+00, -1.60786e+00,  5.32612e-02,  7.92068e-01,\n        -6.67420e-02,  8.86533e-02,  4.38447e-01,  1.93246e-02,\n         4.69271e-01,  1.50089e-01, -6.52321e-03, -7.05430e-01,\n         1.02084e+00, -1.44481e-01,  1.34385e+00, -7.06620e-01,\n         5.99348e-01,  2.23753e-01,  3.03024e-01, -1.16437e+00,\n         6.20510e-01,  2.39010e-01,  6.33210e-01,  7.83420e-02,\n        -5.35018e-01, -7.68897e-01,  2.48338e-01, -8.21896e-01,\n        -1.50753e-02,  7.70642e-01,  4.07584e-01, -3.21323e-01,\n         2.71655e-01, -5.90605e-02,  4.25167e-01,  3.13657e-02,\n        -8.97341e-01, -1.77354e+00,  8.26726e-01,  1.76854e+00,\n        -5.74292e-01,  5.09806e-01,  7.04516e-01, -8.08557e-03,\n        -9.93954e-01,  8.03876e-02,  6.90031e-01,  4.02817e-01,\n        -7.98484e-01, -8.91539e-01,  1.28409e-01,  1.71990e-01,\n         7.75928e-01, -1.03386e+00,  4.42372e-02,  5.15516e-01,\n        -3.44331e-01,  1.18200e-03,  1.13494e+00, -4.79905e-02,\n        -2.73264e-01, -5.49827e-01, -2.60540e-01,  2.46635e-01,\n         6.07760e-01,  7.34930e-01,  3.75429e-01,  3.40623e-01,\n         4.57374e-02,  1.63316e-01, -6.37417e-01, -3.88078e-01,\n         9.41364e-02, -8.36724e-02,  5.30396e-01,  5.32977e-01,\n        -7.62135e-02, -5.23548e-01, -1.02387e+00,  6.36379e-01,\n        -1.52251e+00,  1.21847e-01, -2.27075e-01, -1.19180e+00,\n         8.35557e-01, -8.33588e-01, -1.19962e-01,  2.15247e-01,\n        -7.90993e-01, -3.38465e-01,  6.49465e-01, -9.55126e-01,\n        -3.13049e-02,  1.81868e+00,  8.47810e-02, -2.25852e+00,\n         2.29785e-01, -6.79092e-01, -3.57089e-02,  1.18436e+00,\n         3.88629e-01, -1.56359e-01, -9.52949e-01,  1.04602e+00,\n         1.24202e+00,  9.83614e-01, -2.74759e-02,  6.20111e-01,\n         5.98930e-01,  2.17615e-01,  7.86091e-01, -8.29147e-01,\n         6.39468e-01, -1.25558e+00,  9.26507e-03, -3.13464e-01,\n         9.38088e-01,  2.27649e+00, -2.53768e+00, -3.83406e-01,\n         2.79527e-01,  6.11449e-01,  6.82550e-01,  3.97554e-01,\n         4.47691e-01, -5.54276e-01,  1.76410e-01,  8.73556e-02,\n        -3.99629e-01,  6.94054e-01,  3.43673e-01,  1.01187e+00,\n        -2.18517e+00, -5.70515e-01, -6.79002e-01,  2.22539e-01,\n         4.84307e-01,  2.40932e+00, -6.47600e-01,  6.68794e-01,\n         6.12225e-01,  5.45909e-01,  6.54368e-01,  1.03091e-02,\n        -1.41465e-01,  1.56109e-01, -1.41005e+00,  7.13663e-01,\n         1.11277e-01,  3.64858e-01,  3.34982e-01,  6.26717e-01,\n         5.26949e-01, -4.01259e-01,  9.06606e-01, -1.19428e+00,\n         1.52844e-01,  1.01377e+00,  6.43483e-01,  6.97471e-01,\n         1.14382e+00, -3.99871e-03,  2.66114e-01, -1.49591e-01,\n         2.57018e-01, -4.66524e-01,  9.44353e-01,  2.17188e-01,\n         8.85961e-01,  2.14621e-02,  1.02294e+00,  6.70271e-01,\n        -5.41427e-01, -1.48982e-01, -3.07123e-01, -1.10756e+00,\n        -3.00867e-01,  3.96404e-01,  1.59119e-01, -3.03103e-01,\n         5.77373e-02, -8.40116e-01, -5.53462e-01,  8.28390e-01,\n        -4.80625e-01, -1.49606e+00,  1.87902e-01, -1.46884e+00,\n        -6.33657e-01, -3.71626e-01, -8.77436e-01, -7.03373e-02,\n         7.40037e-01, -8.93051e-01,  1.30231e+00, -1.45159e-01,\n        -2.01342e-01, -1.97197e+00, -5.74940e-01,  8.54658e-01,\n        -1.43819e-01, -7.21665e-02, -5.45656e-01,  1.07217e+00,\n        -6.01677e-01, -1.59161e+00,  4.54926e-01, -1.59611e+00,\n         2.19739e-01,  4.70924e-01, -5.36177e-01,  7.58519e-01,\n         1.27801e-01,  4.78080e-01,  2.33537e-01, -6.89422e-01,\n         8.83141e-01,  4.86207e-01,  2.37032e-01,  8.08333e-01,\n         7.32945e-01, -1.17114e+00,  7.33238e-01, -1.08420e+00,\n         1.93273e+00,  6.09959e-01,  1.83113e+00,  6.52965e-01,\n         1.24981e+00, -2.20897e-01, -8.82339e-02, -8.73349e-01,\n         7.39357e-01, -7.77731e-02,  7.29637e-01, -1.15229e+00,\n         8.94273e-02,  2.04990e-01,  5.52298e-02, -1.13349e+00,\n         8.61106e-01, -4.88224e-01,  9.01410e-01, -9.71639e-01,\n         2.77285e-01, -1.21580e-01, -7.44914e-01,  8.31934e-01,\n         2.40882e-01,  6.88906e-01, -7.45428e-01,  6.96323e-02,\n        -1.30449e-01, -1.05073e+00,  5.51754e-02,  7.47091e-01,\n        -1.19242e+00, -2.65441e-01, -2.56910e-01,  4.35275e-01,\n        -1.23404e-01,  9.67246e-02,  2.44612e-01, -9.98314e-01,\n         1.17133e-01,  1.50953e-01,  3.72173e-01,  1.81027e+00,\n         6.08010e-01,  1.65044e-01,  6.97150e-01, -8.59175e-01,\n         3.64691e-01, -9.03866e-01, -1.71463e-01, -4.97181e-01,\n         3.59801e-01,  2.02395e-01, -6.40316e-01, -1.36781e+00,\n         6.25449e-01,  3.91780e-01,  1.22762e-01, -2.09249e+00,\n         1.59385e-01,  1.02802e+00,  1.30957e+00,  5.12622e-01,\n        -3.10065e-03,  1.38047e+00,  6.46599e-01,  1.27330e+00,\n         1.47127e+00, -1.94907e-01,  1.02943e+00, -1.27448e-01,\n         6.99052e-01, -1.70971e-01,  2.70797e-01, -4.46774e-01,\n        -2.18086e-01,  1.76370e-01,  3.67291e-01,  7.24871e-01,\n         6.20429e-01,  4.54635e-01,  1.60206e-01,  2.11376e-01,\n         6.58752e-01, -1.21890e+00, -3.25728e+00, -6.34088e-01,\n         3.30526e-01,  3.92794e-01,  8.37157e-01, -8.29547e-02,\n         1.07893e+00, -3.17053e-01, -1.09768e+00, -8.34819e-01,\n         3.79134e-01,  1.58639e-01,  3.88338e-01, -1.26107e+00,\n        -1.44337e+00, -6.61995e-01,  1.56509e-01,  1.07669e+00,\n         4.32753e-01, -4.59803e-01, -3.60443e-01,  1.37046e+00,\n        -1.08646e+00, -7.79049e-01, -8.56338e-01,  7.26129e-01,\n         1.11191e+00, -5.38990e-01,  8.07547e-01, -5.00520e-01,\n         9.30688e-01, -1.08224e+00, -2.32093e-01,  1.09179e+00,\n        -1.07688e-01, -1.43090e+00, -3.02642e-01,  7.92652e-01,\n         9.86079e-02,  6.58361e-01, -1.05491e+00,  8.25960e-01,\n         1.26836e+00,  5.04173e-01,  8.12961e-01,  4.23600e-01,\n         1.54567e+00, -1.27906e+00, -2.46772e-01, -6.27626e-01,\n        -1.20863e+00,  8.53035e-01, -1.93384e+00, -1.37296e+00,\n         7.02432e-03, -1.33295e+00, -3.05969e-01,  4.15330e-01,\n         4.14983e-01,  3.42292e-01, -1.29219e+00,  1.79922e-01,\n         2.98742e-02, -8.96372e-01,  3.42554e-01, -6.75668e-01,\n        -8.03111e-02,  7.92982e-01,  1.09564e+00,  5.07590e-01,\n        -3.43324e-01,  5.83436e-01, -8.66205e-01,  4.49343e-01,\n         2.74063e-01, -1.07467e-03, -8.82549e-01,  3.26919e-02,\n        -9.19501e-01,  1.00034e+00,  8.26838e-01,  3.25850e-01,\n        -2.18428e-01,  3.44479e-01, -5.93609e-01,  5.44990e-01,\n         4.69017e-01,  5.32558e-01, -5.76181e-01, -3.87983e-02,\n        -1.38106e-02,  8.28738e-02,  6.83411e-01, -5.76905e-01,\n         8.58287e-01,  1.16795e+00,  9.24057e-01,  1.14211e+00,\n         4.92365e-02,  1.29232e-01,  8.43683e-02,  1.75745e-01,\n         4.00143e-02,  6.23554e-01,  1.75570e-01, -1.96493e+00,\n        -7.44102e-01, -1.19723e+00,  6.60265e-01,  2.02981e+00,\n         7.68875e-01,  5.95512e-02, -2.64178e+00,  1.04027e-01,\n        -4.58022e-02,  1.01061e+00, -6.00788e-01, -5.27978e-01,\n         9.55317e-01,  1.01556e+00,  1.24528e-01, -7.53803e-01,\n         1.64385e-01,  1.13961e-01, -2.21407e-01, -4.54925e-01,\n        -4.62257e-01, -1.72978e-01, -1.51815e-01, -1.03305e+00,\n         4.59110e-01, -3.58224e-02,  1.29174e-01,  1.17854e+00,\n        -7.00523e-01,  1.18655e-01,  4.62443e-01, -2.73184e-01,\n         4.26115e-01,  6.13271e-01, -9.68027e-02,  4.41299e-01,\n        -6.01965e-01,  3.65829e-01,  3.65260e-01, -1.10523e+00,\n         2.34591e-01,  8.73458e-01,  3.58993e-02, -5.87541e-03,\n        -8.15921e-01,  5.31774e-01, -3.70548e-02,  2.39167e-01,\n        -6.25066e-01,  2.41151e-01,  2.02517e-01,  1.17971e+00,\n        -1.19871e+00, -3.86237e-01,  1.93197e-01,  3.59750e-01,\n        -2.99647e-01, -1.87421e-01,  3.84670e+00, -4.39198e-01,\n         6.66417e-01,  6.64133e-01, -1.23445e+00,  4.13822e-02,\n         9.10363e-01,  7.03194e-01,  6.37879e-01, -1.54531e+00,\n        -1.93263e+00,  5.77746e-01,  1.29742e+00, -2.80598e-01,\n        -7.05573e-01, -3.06071e+00, -4.75422e-01,  3.65198e-01,\n         9.74521e-01,  7.32553e-01, -8.00326e-01,  4.41971e-01,\n        -1.95516e-01, -2.43647e-01, -6.74946e-02, -1.44551e-01,\n        -1.31030e-01,  5.22529e-01,  2.52823e-01, -1.03373e-01,\n        -6.31948e-01, -2.81622e-01, -9.36986e-04,  1.54589e-02,\n        -5.68423e-01,  3.00506e-01,  4.62269e-01, -3.53738e-01,\n        -2.06421e+00,  2.69334e-01,  3.93483e-01, -1.14338e+00,\n         1.07983e+00,  5.48180e-01, -5.45344e-01,  3.05104e-02,\n         3.15502e-01, -1.58942e+00, -9.85861e-01,  1.49249e-01,\n        -7.88658e-01,  6.68504e-01,  5.33568e-01,  7.36544e-01,\n        -1.05825e+00,  1.02985e-01, -2.35514e+00, -7.23614e-01,\n        -6.70479e-01, -1.46119e-01,  4.97112e-01, -1.04240e+00,\n         7.24753e-01,  5.18291e-01, -1.37861e+00, -1.04266e+00,\n         4.86643e-01,  3.66984e-01,  7.86917e-01, -1.19986e+00,\n        -9.10797e-02, -3.21514e-01,  6.13457e-01, -4.11578e-01,\n        -7.19788e-02, -5.84740e-01, -1.54333e+00,  9.77076e-01,\n         5.75926e-01, -1.00221e+00, -3.25447e-01, -1.46595e+00,\n        -6.01940e-01, -7.13286e-01, -6.50424e-01,  7.77025e-01,\n         6.20243e-01,  1.30215e-01,  2.77166e-03,  5.73520e-01,\n        -9.29842e-01, -6.83950e-01,  5.97183e-01,  1.02583e+00,\n         2.38601e-01, -2.39362e-01,  1.32720e-01,  4.07196e-01,\n         7.34207e-01,  3.55592e-01,  3.64512e-01,  3.96730e-01,\n         4.66226e-01, -7.16174e-01,  8.75962e-02,  2.02811e-01,\n        -4.34386e-01, -8.45573e-01,  1.04871e+00,  5.96921e-01,\n        -1.73109e+00,  7.61483e-01,  6.69625e-01,  1.85631e-01,\n         2.67182e-01,  1.09866e+00, -5.32408e-01,  6.28556e-01,\n         8.70480e-01, -1.96992e+00,  6.84554e-01, -3.95174e-01,\n         2.01807e-01,  2.72352e-01, -5.72349e-01,  4.86605e-01,\n         4.87756e-01,  3.66553e-01,  3.28475e-01,  3.75401e-01,\n         5.53631e-01,  6.53921e-01, -1.49613e+00, -6.38289e-01,\n        -1.65964e+00,  3.01679e-01,  8.20036e-03, -7.31041e-01,\n        -7.63256e-02, -3.52873e-01,  1.07270e-01,  1.01285e+00,\n        -1.52660e-01, -7.00161e-02, -8.24873e-01, -4.52995e-01,\n        -3.28376e-01, -4.90847e-01, -2.89744e-01]),\n 'cutpoints': array([-0.720339,  0.18709 ,  0.552617,  0.906846,  1.3986  ,  2.15084 ]),\n 'verb_component_prior_mean': array([1.28443e-01, 1.60741e-02, 1.05481e-02, 8.22040e-03, 6.80327e-03,\n        2.12795e-03, 1.80451e-03, 1.45810e-03, 6.15357e-04, 2.30873e-04,\n        8.16554e-05, 2.67256e-05, 1.96005e-05, 1.67452e-05, 1.30384e-05,\n        2.96395e-06, 4.34786e-07, 3.13732e-07, 1.65614e-07, 2.05075e-08,\n        5.65024e-09, 2.09321e-09, 1.46980e-09, 1.29298e-09, 1.78503e-10,\n        3.11753e-11, 6.55585e-12, 5.02183e-12, 7.62907e-13, 2.23275e-13]),\n 'verb_component_prior_alpha': array([5.06843e-01, 1.10258e-01, 2.26451e-02, 2.92497e-03, 2.93629e-02,\n        1.41903e-03, 3.62190e-03, 4.31096e-03, 1.71058e-04, 7.24609e-05,\n        2.99320e-04, 9.66002e-05, 5.30920e-06, 1.02154e-04, 2.58255e-06,\n        2.04616e-06, 1.33335e-07, 1.52970e-07, 5.32966e-08, 5.34687e-09,\n        1.78361e-09, 4.81436e-09, 3.67715e-09, 5.22383e-10, 2.20843e-10,\n        1.38221e-10, 5.32149e-12, 1.13638e-11, 3.68172e-12, 1.53034e-13]),\n 'verb_component_prior_beta': array([3.43922 , 6.74908 , 2.1242  , 0.352893, 4.28663 , 0.665431,\n        2.00352 , 2.95226 , 0.277811, 0.313784, 3.66534 , 3.61443 ,\n        0.270865, 6.10038 , 0.19807 , 0.690345, 0.306669, 0.487583,\n        0.321812, 0.260728, 0.31567 , 2.29999 , 2.5018  , 0.404016,\n        1.23719 , 4.43367 , 0.811716, 2.26288 , 4.82592 , 0.685407]),\n 'frame_component_prior_mean': array([1.28859e-01, 5.66346e-02, 4.85261e-02, 1.86795e-02, 1.21796e-02,\n        8.06819e-03, 6.65339e-03, 3.27935e-03, 1.50345e-03, 1.99599e-04,\n        6.93213e-05, 5.32477e-05, 2.05634e-05, 1.80143e-05, 4.73435e-06,\n        6.01754e-07, 1.98138e-07, 1.47371e-07, 1.00991e-07, 3.97762e-08,\n        1.30277e-08, 2.77370e-09, 3.85050e-10, 1.32009e-10, 1.14925e-10,\n        9.96380e-11, 2.89588e-11, 1.13361e-11, 9.92260e-12, 8.13187e-12]),\n 'frame_component_prior_alpha': array([3.19170e-01, 3.93534e-01, 5.54003e-02, 1.56283e-02, 3.19164e-03,\n        2.68925e-02, 7.11207e-03, 7.41656e-03, 2.88757e-04, 5.77876e-04,\n        6.28201e-05, 1.98665e-05, 5.00343e-05, 4.50722e-06, 1.44231e-06,\n        1.76189e-07, 4.18530e-07, 1.42186e-07, 2.67632e-07, 4.86764e-08,\n        3.24894e-08, 5.29883e-09, 4.41308e-10, 2.18872e-11, 1.65840e-10,\n        4.05822e-10, 7.39170e-11, 3.86265e-11, 6.45902e-11, 1.34866e-12]),\n 'frame_component_prior_beta': array([2.15772 , 6.55512 , 1.08626 , 0.821024, 0.258857, 3.30626 ,\n        1.06183 , 2.25418 , 0.191774, 2.89461 , 0.906153, 0.373076,\n        2.43312 , 0.250198, 0.304646, 0.292793, 2.11231 , 0.964812,\n        2.65006 , 1.22376 , 2.49388 , 1.91038 , 1.1461  , 0.1658  ,\n        1.44303 , 4.07296 , 2.55249 , 3.40739 , 6.50941 , 0.165849]),\n 'verb_frame': array([[0.999849, 0.999951, 0.999031, ..., 0.998878, 0.999747, 0.999946],\n        [0.999996, 0.999996, 0.999937, ..., 0.999911, 0.999997, 0.999995],\n        [0.999773, 0.999885, 0.999436, ..., 0.999494, 0.999845, 0.99987 ],\n        ...,\n        [0.99999 , 0.999953, 0.999848, ..., 0.999734, 0.999978, 0.99993 ],\n        [0.999919, 0.999907, 0.999864, ..., 0.999264, 0.999826, 0.999921],\n        [0.999754, 0.999943, 0.999812, ..., 0.99994 , 0.999983, 0.99995 ]]),\n 'mu': array([-0.20531  , -0.325849 ,  1.5518   , ...,  0.0194879, -0.319544 ,\n        -0.462354 ])}\ntorch.tensor??\n\n\nDocstring:\ntensor(data, *, dtype=None, device=None, requires_grad=False, pin_memory=False) -&gt; Tensor\nConstructs a tensor with no autograd history (also known as a \"leaf tensor\", see :doc:`/notes/autograd`) by copying :attr:`data`.\n.. warning::\n    When working with tensors prefer using :func:`torch.Tensor.clone`,\n    :func:`torch.Tensor.detach`, and :func:`torch.Tensor.requires_grad_` for\n    readability. Letting `t` be a tensor, ``torch.tensor(t)`` is equivalent to\n    ``t.clone().detach()``, and ``torch.tensor(t, requires_grad=True)``\n    is equivalent to ``t.clone().detach().requires_grad_(True)``.\n.. seealso::\n    :func:`torch.as_tensor` preserves autograd history and avoids copies where possible.\n    :func:`torch.from_numpy` creates a tensor that shares storage with a NumPy array.\nArgs:\n    data (array_like): Initial data for the tensor. Can be a list, tuple,\n        NumPy ``ndarray``, scalar, and other types.\nKeyword args:\n    dtype (:class:`torch.dtype`, optional): the desired data type of returned tensor.\n        Default: if ``None``, infers data type from :attr:`data`.\n    device (:class:`torch.device`, optional): the device of the constructed tensor. If None and data is a tensor\n        then the device of data is used. If None and data is not a tensor then\n        the result tensor is constructed on the CPU.\n    requires_grad (bool, optional): If autograd should record operations on the\n        returned tensor. Default: ``False``.\n    pin_memory (bool, optional): If set, returned tensor would be allocated in\n        the pinned memory. Works only for CPU tensors. Default: ``False``.\nExample::\n    &gt;&gt;&gt; torch.tensor([[0.1, 1.2], [2.2, 3.1], [4.9, 5.2]])\n    tensor([[ 0.1000,  1.2000],\n            [ 2.2000,  3.1000],\n            [ 4.9000,  5.2000]])\n    &gt;&gt;&gt; torch.tensor([0, 1])  # Type inference on data\n    tensor([ 0,  1])\n    &gt;&gt;&gt; torch.tensor([[0.11111, 0.222222, 0.3333333]],\n    ...              dtype=torch.float64,\n    ...              device=torch.device('cuda:0'))  # creates a double tensor on a CUDA device\n    tensor([[ 0.1111,  0.2222,  0.3333]], dtype=torch.float64, device='cuda:0')\n    &gt;&gt;&gt; torch.tensor(3.14159)  # Create a zero-dimensional (scalar) tensor\n    tensor(3.1416)\n    &gt;&gt;&gt; torch.tensor([])  # Create an empty tensor (of size (0,))\n    tensor([])\nType:      builtin_function_or_method\n@dataclass\nclass SelectionModelParameters:\n    n_verb: int\n    n_frame: int\n    n_subj: int\n    n_resp_levels: int\n    \n@dataclass\nclass UnconstrainedSelectionModelParameters(SelectionModelParameters):\n    n_component: int\n\n@dataclass\nclass SelectionData:\n    verb: ndarray\n    frame: ndarray\n    subj: ndarray\n    resp: ndarray\nimport torch\nfrom torch import Tensor\n\ndef ordered_logistic_likelihood(value: Tensor, jumps: Tensor, center: bool = True) -&gt; Tensor:\n    \"\"\"Compute the ordered logistic likelihood given a value\n    \n    Parameters\n    ----------\n    value\n        The value to compute the likelihood for \n        (shape: batch_size)\n    jumps\n        The distance between cutpoints \n        (shape: batch_size x number of response levels - 1)\n\n    Returns\n    -------\n    log_likelihood\n        the ordered logistic log-likelihood\n    \"\"\"\n    cutpoints = torch.cumsum(jumps, 1) \n    \n    if center:\n        cutpoints = cutpoints - cutpoints.mean()\n    \n    cdfs = torch.sigmoid(cutpoints - value[:,None])\n\n    low_prob = torch.cat(\n        [torch.zeros([cdfs.shape[0], 1]), cdfs],\n        axis=1\n    )\n    high_prob = torch.cat(\n        [cdfs, torch.ones([cdfs.shape[0], 1])],\n        axis=1\n    )\n    \n    return high_prob - low_prob\nclass UnconstrainedSelectionModel(torch.nn.Module):\n    parameter_class = UnconstrainedSelectionModelParameters\n    data_class = SelectionData\n    \n    def __init__(self, parameters: UnconstrainedSelectionModelParameters):\n        super().__init__()\n        \n        self.model_parameters = parameters\n        \n        self.verb_component_aux = torch.nn.Parameter(\n            torch.randn([\n                parameters.n_verb, parameters.n_component\n            ]), \n            requires_grad=True\n        )\n        self.frame_component_aux = torch.nn.Parameter(\n            torch.randn([\n                parameters.n_frame, parameters.n_component\n            ]), \n            requires_grad=True\n        )\n        \n        self.log_jumps = torch.nn.Parameter(\n            torch.ones([\n                parameters.n_subj, parameters.n_resp_levels-1\n            ]), \n            requires_grad=True\n        )\n        \n\n    def forward(self, data: SelectionData):\n        verb_frame_prob = self.verb_frame_prob(data.verb, data.frame)\n        verb_frame_logodds = torch.log(verb_frame_prob) - torch.log(1. - verb_frame_prob)\n        \n        jumps = self.jumps[data.subj]\n        \n        return ordered_logistic_likelihood(\n            verb_frame_logodds, jumps\n        )\n    \n    def verb_frame_prob(\n        self, \n        verb_idx: Optional[ndarray] = None, \n        frame_idx: Optional[ndarray] = None\n    ) -&gt; Tensor:\n        if verb_idx is not None or frame_idx is not None:\n            return 1. - torch.prod(\n                1. - self.verb_component_prob[verb_idx,:] * \n                     self.frame_component_prob[frame_idx,:],\n                axis=1\n            )\n        elif verb_idx is None and frame_idx is not None:\n            return 1. - torch.prod(\n                1. - self.verb_component_prob[:,None,:] * \n                     self.frame_component_prob[:,frame_idx,:],\n                axis=2\n            )\n        elif verb_idx is not None and frame_idx is None:\n            return 1. - torch.prod(\n                1. - self.verb_component_prob[verb_idx,None,:] * \n                     self.frame_component_prob[None,:,:],\n                axis=2\n            )\n        else:\n            return 1. - torch.prod(\n                1. - self.verb_component_prob[:,None,:] * \n                     self.frame_component_prob[None,:,:],\n                axis=2\n            )       \n    \n    @property\n    def verb_component_prob(self) -&gt; Tensor:\n        return torch.sigmoid(self.verb_component_aux)\n    \n    @property\n    def frame_component_prob(self) -&gt; Tensor:\n        return torch.sigmoid(self.frame_component_aux)\n    \n    @property\n    def jumps(self):\n        return torch.exp(self.log_jumps)\nfrom abc import ABC, abstractmethod\n\nclass SelectionModelTrainer(ABC):\n    data_class = SelectionData\n    \n    @abstractmethod\n    def construct_model_parameters(self, data: pd.DataFrame) -&gt; SelectionModelParameters:\n        raise NotImplementedError\n        \n    def construct_model_data(self, data: pd.DataFrame) -&gt; SelectionData:            \n        if hasattr(self, \"frame_hash_map\"):\n            _, frame_hashed = hash_series(data.frame, self.frame_hash_map, indexation=0)\n        else:\n            self.frame_hash_map, frame_hashed = hash_series(data.frame, indexation=0)\n            \n        if hasattr(self, \"verb_hash_map\"):\n            _, verb_hashed = hash_series(data.verb, self.verb_hash_map, indexation=0)\n        else:\n            self.verb_hash_map, verb_hashed = hash_series(data.verb, indexation=0)\n\n        if hasattr(self, \"subj_hash_map\"):\n            _, subj_hashed = hash_series(data.participant, self.subj_hash_map, indexation=0)\n        else:\n            self.subj_hash_map, subj_hashed = hash_series(data.participant, indexation=0)\n        \n        model_data = {\n            \"verb\": verb_hashed,\n            \"frame\": frame_hashed,\n            \"subj\": subj_hashed,\n            \"resp\": data.response.astype(int).values - 1\n        }\n        \n        return self.data_class(**model_data)\n    \n    def _initialize_model(self, data: pd.DataFrame):\n        model_parameters = self.construct_model_parameters(data)\n        \n        return self.model_class(model_parameters)\n    \n    def fit(\n        self, data: pd.DataFrame, batch_size=1000, n_epochs:int=1000, \n        lr: float = 1e-5, verbosity: int=100\n    ) -&gt; UnconstrainedSelectionModel:\n        # necessary for initializing hashes\n        self.model_data = self.construct_model_data(data)\n        self.model = self._initialize_model(data)\n        \n        optimizer = torch.optim.Adam(self.model.parameters(), lr=lr)\n        \n        for e in range(n_epochs):\n            data_shuffled = data.sample(frac=1.).reset_index(drop=True)\n            \n            n_batches = int(data_shuffled.shape[0]/batch_size)\n        \n            epoch_total_loss = 0.\n        \n            correlations = []\n            \n            for i in range(n_batches):\n                lower_bound = i*batch_size\n                \n                if i == (n_batches - 1):\n                    upper_bound = data_shuffled.shape[0]\n                else:\n                    upper_bound = (i+1)*batch_size\n\n                data_sub = self.construct_model_data(data_shuffled.iloc[lower_bound:upper_bound])\n                target = torch.tensor(data_sub.resp)\n\n                optimizer.zero_grad()\n\n                probs = self.model(data_sub)\n                logprobs = torch.log(probs)\n\n                loss = self.loss_function(logprobs, target)\n\n                # compute correlation between expected value and target\n                expected_value = torch.sum(\n                    torch.arange(1, probs.shape[1]+1)[None,:] * probs, \n                    axis=1\n                )\n                corr = torch.corrcoef(\n                    torch.cat([\n                        expected_value[None,:], \n                        target[None,:]\n                    ], axis=0)\n                )\n                correlations.append(corr[0,1].item())\n                \n                loss.backward()\n\n                optimizer.step()\n                \n                epoch_total_loss += loss.item()\n                \n            if verbosity and not e % verbosity:\n                print(f\"Epoch:       {e}\")\n                print(f\"Loss:        {np.round(epoch_total_loss, 2)}\")\n                print(f\"Mean corr.:  {np.round(np.mean(correlations), 2)}\")\n                print()\n                \n        \n        return self\n    \n    def expected_value(self, data: pd.DataFrame):\n        model_data = self.construct_model_data(data)\n        probs = self.model(model_data)\n        \n        expected_value = torch.sum(\n            torch.arange(1, 8)[None,:] * probs, \n            axis=1\n        )\n        \n        return expected_value\n    \n    def likelihood(self, data: pd.DataFrame):\n        model_data = self.construct_model_data(data)\n        probs = self.model(model_data)\n        \n        return probs[model_data.resp]\n    \n    def predict(self, data: pd.DataFrame):\n        model_data = self.construct_model_data(data)\n        probs = self.model(model_data)\n        \n        return probs[model_data.resp]\nclass UnconstrainedSelectionModelTrainer(SelectionModelTrainer):\n    parameter_class = UnconstrainedSelectionModelParameters\n    model_class = UnconstrainedSelectionModel\n    \n    def __init__(self, n_component: int):\n        self.n_component = n_component\n        \n        self.loss_function = torch.nn.CrossEntropyLoss(reduction=\"sum\")\n    \n    def construct_model_parameters(self, data: pd.DataFrame) -&gt; UnconstrainedSelectionModelParameters:\n        model_parameters = {\n            \"n_verb\": self.verb_hash_map.shape[0],\n            \"n_frame\": self.frame_hash_map.shape[0],\n            \"n_subj\": self.subj_hash_map.shape[0],\n            \"n_resp_levels\": 7,\n            \"n_component\": self.n_component\n        }\n        \n        return self.parameter_class(**model_parameters)\n    \nm = UnconstrainedSelectionModelTrainer(2)\nm.fit(data)\n\nEpoch:       0\nLoss:        1147684.59\nMean corr.:  0.03\n\nEpoch:       100\nLoss:        950132.16\nMean corr.:  0.19\n\nEpoch:       200\nLoss:        792799.86\nMean corr.:  0.28\n\n\n\nKeyboardInterrupt:\nfrom scipy.stats import spearmanr\n\ndata[\"expected_value\"] = m.expected_value(data).data\n\n_ = sns.boxplot(data, x=\"response\", y=\"expected_value\")\n\nspearmanr(data[[\"response\", \"expected_value\"]])\n\nSignificanceResult(statistic=0.42813175602327286, pvalue=0.0)\n#sns.clustermap(pd.DataFrame(m.model.frame_component_prob.data, index=m.frame_hash_map), cmap=\"vlag\", yticklabels=True)\nsns.clustermap(pd.DataFrame(m.model.verb_component_prob.data, index=m.verb_hash_map), cmap=\"vlag\", yticklabels=True)\n@dataclass\nclass ConstrainedSelectionModelParameters(SelectionModelParameters):\n    n_clause_component: int\n    n_nonclause_component: int\nimport torch\nfrom torch import Tensor\n\nclass ConstrainedSelectionModel(torch.nn.Module):\n    parameter_class = ConstrainedSelectionModelParameters\n    \n    def __init__(self, parameters: ConstrainedSelectionModelParameters):\n        super().__init__()\n        \n        self.model_parameters = parameters\n        \n        self.verb_clause_aux = torch.nn.Parameter(\n            torch.randn([parameters.n_verb]), \n            requires_grad=True\n        )\n        self.verb_nonclause_aux = torch.nn.Parameter(\n            torch.randn([\n                parameters.n_verb, parameters.n_nonclause_component\n            ]), \n            requires_grad=True\n        )\n        \n        self.frame_clause_aux = torch.nn.Parameter(\n            torch.randn([parameters.n_frame]), \n            requires_grad=True\n        )\n        self.frame_nonclause_aux = torch.nn.Parameter(\n            torch.randn([\n                parameters.n_frame, parameters.n_nonclause_component\n            ]), \n            requires_grad=True\n        )\n        \n        self.log_clause_jumps = torch.nn.Parameter(\n            torch.ones(parameters.n_clause_component-1), \n            requires_grad=True\n        )\n        \n        self.log_jumps = torch.nn.Parameter(\n            torch.ones([\n                parameters.n_subj, parameters.n_resp_levels-1\n            ]), \n            requires_grad=True\n        )\n        \n\n    def forward(self, data: SelectionData):\n        verb_frame_prob = self.verb_frame_prob(data.verb, data.frame)\n        verb_frame_logodds = torch.log(verb_frame_prob) - torch.log(1. - verb_frame_prob)\n        \n        jumps = self.jumps[data.subj]\n        \n        return ordered_logistic_likelihood(\n            verb_frame_logodds, jumps\n        )\n   \n    def verb_frame_prob(\n        self, \n        verb_idx: Optional[ndarray] = None, \n        frame_idx: Optional[ndarray] = None\n    ) -&gt; Tensor:\n        return self.verb_frame_clause_prob(verb_idx, frame_idx) *\\\n               self.verb_frame_nonclause_prob(verb_idx, frame_idx)\n\n    def verb_frame_clause_prob(\n        self, \n        verb_idx: Optional[ndarray] = None, \n        frame_idx: Optional[ndarray] = None\n    ) -&gt; Tensor:\n        if verb_idx is not None or frame_idx is not None:\n            return 1. - torch.prod(\n                1. - self.verb_clause_component_prob[verb_idx,:] * \n                     self.frame_clause_component_prob[frame_idx,:],\n                axis=1\n            )\n        elif verb_idx is None and frame_idx is not None:\n            return 1. - torch.prod(\n                1. - self.verb_clause_component_prob[:,None,:] * \n                     self.frame_clause_component_prob[:,frame_idx,:],\n                axis=2\n            )\n        elif verb_idx is not None and frame_idx is None:\n            return 1. - torch.prod(\n                1. - self.verb_clause_component_prob[verb_idx,None,:] * \n                     self.frame_clause_component_prob[None,:,:],\n                axis=2\n            )\n        else:\n            return 1. - torch.prod(\n                1. - self.verb_clause_component_prob[:,None,:] * \n                     self.frame_clause_component_prob[None,:,:],\n                axis=2\n            ) \n\n    def verb_frame_nonclause_prob(\n        self, \n        verb_idx: Optional[ndarray] = None, \n        frame_idx: Optional[ndarray] = None\n    ) -&gt; Tensor:\n        if verb_idx is not None or frame_idx is not None:\n            return 1. - torch.prod(\n                1. - self.verb_nonclause_component_prob[verb_idx,:] * \n                     self.frame_nonclause_component_prob[frame_idx,:],\n                axis=1\n            )\n        elif verb_idx is None and frame_idx is not None:\n            return 1. - torch.prod(\n                1. - self.verb_nonclause_component_prob[:,None,:] * \n                     self.frame_nonclause_component_prob[:,frame_idx,:],\n                axis=2\n            )\n        elif verb_idx is not None and frame_idx is None:\n            return 1. - torch.prod(\n                1. - self.verb_nonclause_component_prob[verb_idx,None,:] * \n                     self.frame_nonclause_component_prob[None,:,:],\n                axis=2\n            )\n        else:\n            return 1. - torch.prod(\n                1. - self.verb_nonclause_component_prob[:,None,:] * \n                     self.frame_nonclause_component_prob[None,:,:],\n                axis=2\n            )       \n    \n    @property\n    def verb_clause_component_prob(self) -&gt; Tensor:\n        return ordered_logistic_likelihood(\n            self.verb_clause_aux, self.clause_jumps[None,:]\n        )\n    \n    @property\n    def frame_clause_component_prob(self) -&gt; Tensor:\n        return ordered_logistic_likelihood(\n            self.frame_clause_aux, self.clause_jumps[None,:]\n        )\n    \n    @property\n    def verb_nonclause_component_prob(self) -&gt; Tensor:\n        return torch.sigmoid(self.verb_nonclause_aux)\n    \n    @property\n    def frame_nonclause_component_prob(self) -&gt; Tensor:\n        return torch.sigmoid(self.frame_nonclause_aux)\n\n    @property\n    def clause_jumps(self):\n        return torch.exp(self.log_clause_jumps)\n    \n    @property\n    def jumps(self):\n        return torch.exp(self.log_jumps)\nclass ConstrainedSelectionModelTrainer(SelectionModelTrainer):\n    parameter_class = ConstrainedSelectionModelParameters\n    model_class = ConstrainedSelectionModel\n    \n    def __init__(self, n_clause_component: int, n_nonclause_component: int):\n        self.n_clause_component = n_clause_component\n        self.n_nonclause_component = n_nonclause_component\n        \n        self.loss_function = torch.nn.CrossEntropyLoss(reduction=\"sum\")\n    \n    def construct_model_parameters(self, data: pd.DataFrame) -&gt; UnconstrainedSelectionModelParameters:\n        model_parameters = {\n            \"n_verb\": self.verb_hash_map.shape[0],\n            \"n_frame\": self.frame_hash_map.shape[0],\n            \"n_subj\": self.subj_hash_map.shape[0],\n            \"n_resp_levels\": 7,\n            \"n_clause_component\": self.n_clause_component,\n            \"n_nonclause_component\": self.n_nonclause_component\n        }\n        \n        return self.parameter_class(**model_parameters)\n    \nm = ConstrainedSelectionModelTrainer(3, 2)\nm.fit(data)\n\nEpoch:       0\nLoss:        1078181.55\nMean corr.:  0.02\n\n\n\nKeyboardInterrupt:\nsns.clustermap(pd.DataFrame(m.model.frame_clause_component_prob.data, index=m.frame_hash_map), yticklabels=True)\n#sns.clustermap(pd.DataFrame(m.model.verb_component_prob.data, index=m.verb_hash_map), cmap=\"vlag\", yticklabels=True)\n\nValueError: The condensed distance matrix must contain only finite values.\nordered_logistic_likelihood??\n\n\nSignature:\nordered_logistic_likelihood(\n    value: torch.Tensor,\n    jumps: torch.Tensor,\n    center: bool = True,\n) -&gt; torch.Tensor\nSource:   \ndef ordered_logistic_likelihood(value: Tensor, jumps: Tensor, center: bool = True) -&gt; Tensor:\n    \"\"\"Compute the ordered logistic likelihood given a value\n    \n    Parameters\n    ----------\n    value\n        The value to compute the likelihood for \n        (shape: batch_size)\n    jumps\n        The distance between cutpoints \n        (shape: batch_size x number of response levels - 1)\n    Returns\n    -------\n    log_likelihood\n        the ordered logistic log-likelihood\n    \"\"\"\n    cutpoints = torch.cumsum(jumps, 1) \n    \n    if center:\n        cutpoints = cutpoints - cutpoints.mean()\n    \n    cdfs = torch.sigmoid(cutpoints - value[:,None])\n    low_prob = torch.cat(\n        [torch.zeros([cdfs.shape[0], 1]), cdfs],\n        axis=1\n    )\n    high_prob = torch.cat(\n        [cdfs, torch.ones([cdfs.shape[0], 1])],\n        axis=1\n    )\n    \n    return high_prob - low_prob\nFile:      /tmp/ipykernel_31725/3045571987.py\nType:      function"
  },
  {
    "objectID": "selection/index.html#footnotes",
    "href": "selection/index.html#footnotes",
    "title": "Selection",
    "section": "Footnotes",
    "text": "Footnotes\n\n\nIn fact, not all predicates found in their sentences are necessarily verbs. Some–e.g. annoy–are likely to be (deverbal) adjectives in some frames. We’ll continue to just refer to these predicates as verbs.↩︎"
  },
  {
    "objectID": "thematic-roles/index.html",
    "href": "thematic-roles/index.html",
    "title": "Module 4: Thematic Roles",
    "section": "",
    "text": "Availability\n\n\n\nThis section will be available Thursday, 29 June 2023. Please complete the below reading prior to that date.\n\n\n\n\n\n\n\n\nReading\n\n\n\nData: Reisinger et al. (2015) and White et al. (2020) on collecting corpus annotations of the proto-role properties proposed by Dowty (1991). We will use the Universal Decompositional Semantics (UDS) dataset (v2.0 Gantt, Glass, and White 2022), which is packaged with the decomp toolkit, available here.\nTheory: Levin and Rappaport Hovav (2005, Ch. 2) on the explanatory role of generalized thematic roles.\n\n\n\n\n\n\nReferences\n\nDowty, David. 1991. “Thematic Proto-Roles and Argument Selection.” Language 67 (3): 547–619. https://doi.org/10.2307/415037.\n\n\nGantt, William, Lelia Glass, and Aaron Steven White. 2022. “Decomposing and Recomposing Event Structure.” Transactions of the Association for Computational Linguistics 10 (January): 17–34. https://doi.org/10.1162/tacl_a_00445.\n\n\nLevin, Beth, and Malka Rappaport Hovav. 2005. Argument Realization. Cambridge: Cambridge University Press.\n\n\nReisinger, Drew, Rachel Rudinger, Francis Ferraro, Craig Harman, Kyle Rawlins, and Benjamin Van Durme. 2015. “Semantic Proto-Roles.” Transactions of the Association for Computational Linguistics 3: 475–88. https://doi.org/10.1162/tacl_a_00152.\n\n\nWhite, Aaron Steven, Elias Stengel-Eskin, Siddharth Vashishtha, Venkata Subrahmanyan Govindarajan, Dee Ann Reisinger, Tim Vieira, Keisuke Sakaguchi, et al. 2020. “The Universal Decompositional Semantics Dataset and Decomp Toolkit.” In Proceedings of the Twelfth Language Resources and Evaluation Conference, 5698–5707. Marseille, France: European Language Resources Association. https://aclanthology.org/2020.lrec-1.699."
  }
]