[
  {
    "objectID": "index.html",
    "href": "index.html",
    "title": "About",
    "section": "",
    "text": "This site contains materials for a course on Representation Learning for Syntactic and Semantic Theory given by Aaron Steven White at the 2023 Linguistic Society of America Institute, held at the University of Massachusetts, Amherst from June 19–July 14, 2023."
  },
  {
    "objectID": "index.html#about-the-course",
    "href": "index.html#about-the-course",
    "title": "About",
    "section": "About the course",
    "text": "About the course\nExperimental methods and corpus annotation are becoming increasingly important tools in the development of syntactic and semantic theories. And while regression-based approaches to the analysis of experimental and corpus data are widely known, methods for inducing expressive syntactic and semantic representations from such data remain relatively underused. Such methods have only recently become feasible due to advances in machine learning and the availability of large-scale datasets of acceptability and inference judgments; and they hold promise because they allow theoreticians (i) to design analyses directly in terms of the theoretical constructs of interest and (ii) to synthesize multiple sources and types of data within a single model.\nThe broad area of machine learning that techniques for syntactic and semantic representation induction come from is known as representation learning; and while such techniques are now common in the natural language processing (NLP) literature, their use is largely confined either to models focused on particular NLP tasks, such as question answering or information extraction, or to ‘probing’ the representations of existing NLP models. As such, it remains difficult to see this literature’s relevance for theoreticians. This course aims to demonstrate that relevance by focusing on the use of representation learning for developing syntactic and semantic theories."
  },
  {
    "objectID": "index.html#about-the-instructor",
    "href": "index.html#about-the-instructor",
    "title": "About",
    "section": "About the instructor",
    "text": "About the instructor\nAaron Steven White is an Associate Professor of Linguistics and Computer Science at the University of Rochester, where he directs the Formal and Computational Semantics lab (FACTS.lab). His research investigates the relationship between linguistic expressions and conceptual categories that undergird the human ability to convey information about possible past, present, and future configurations of things in the world.\nIn addition to being a principal investigator on numerous federally funded grants and contracts, White is the recipient of a National Science Foundation Faculty Early Career Development (CAREER) award. His work has appeared in a variety linguistics, cognitive science, and natural language processing venues, including Semantics & Pragmatics, Glossa, Language Acquisition, Cognitive Science, Cognitive Psychology, Transactions of the Association for Computational Linguistics, and Empirical Methods in Natural Language Processing."
  },
  {
    "objectID": "index.html#about-the-site",
    "href": "index.html#about-the-site",
    "title": "About",
    "section": "About the site",
    "text": "About the site\nThe site itself is built using Quarto. The source files for this site are available on github at aaronstevenwhite/representation-learning-course. See Installation for information on how to run the code documented here."
  },
  {
    "objectID": "index.html#acknowledgments",
    "href": "index.html#acknowledgments",
    "title": "About",
    "section": "Acknowledgments",
    "text": "Acknowledgments\nThe development of these course materials builds on collaborations between Aaron Steven White and a variety of other researchers:\n\nModule 1 of this course builds on unpublished collaborative research with Jon Sprouse. A version of this work was presented as a poster at WCCFL34.\nModule 2 builds on unpublished collaborative research with Julian Grove, who led the development of the models covered in that module.\nModule 3 builds on collaborative research with Kyle Rawlins as well as the rest of the MegaAttitude Project team.\nModule 4 builds on work with Kyle Rawlins and Ben Van Durme as well as the rest of the Decompositional Semantics Initiative team–with specific acknowledgment of Will Gantt and Elias Stengel-Eskin for their work on the decomp toolkit.\n\nIt was additionally supported by multiple National Science Foundation grants:\n\nThe MegaAttitude Project: Investigating selection and polysemy at the scale of the lexicon (BCS-1748969/BCS-1749025)\nComputational Modeling of the Internal Structure of Events (BCS-2040831/BCS-2040820)\nThe typology of subordinate clauses: A case study (BCS-2214933)\nCAREER: Logical Form Induction (BCS/IIS-2237175)"
  },
  {
    "objectID": "index.html#license",
    "href": "index.html#license",
    "title": "About",
    "section": "License ",
    "text": "License \nRepresentation Learning for Syntactic and Semantic Theory by Aaron Steven White is licensed under a Creative Commons Attribution-ShareAlike 4.0 International License. Based on a work at https://github.com/aaronstevenwhite/representation-learning-course."
  },
  {
    "objectID": "installation.html",
    "href": "installation.html",
    "title": "Installation",
    "section": "",
    "text": "The site itself is built using Quarto. The source files for this site are available on github at aaronstevenwhite/representation-learning-course. You can obtain the files by cloning this repo.\nAll further code on this page assumes that you are inside of this cloned repo."
  },
  {
    "objectID": "installation.html#installing-quarto-and-extensions",
    "href": "installation.html#installing-quarto-and-extensions",
    "title": "Installation",
    "section": "Installing Quarto and extensions",
    "text": "Installing Quarto and extensions\nTo build this site, you will need to install Quarto as well as its include-code-files extension.\nquarto add quarto-ext/include-code-files\nquarto add shafayetShafee/line-highlight\nThis extension is mainly used for including external STAN files."
  },
  {
    "objectID": "installation.html#building-the-docker-container",
    "href": "installation.html#building-the-docker-container",
    "title": "Installation",
    "section": "Building the Docker container",
    "text": "Building the Docker container\nAll pages that have executed code blocks are generated from jupyter notebooks, which were run within a Docker container constructed using the Dockerfile contained in this repo.\nFROM jupyter/datascience-notebook:notebook-6.5.4\n\n\n\nRUN pip install --upgrade pip cmdstanpy==1.1.0 arviz==0.15.1 torch==2.0.1 'transformers[torch]' &&\\\n\n    python -c \"from cmdstanpy import install_cmdstan; install_cmdstan(version='2.32.2')\"\nAssuming you have Docker installed, the image can be built using:\ndocker build -t representation-learning-course .\nA container based on this image can then be constructed using:\ndocker run -it --rm -p 8888:8888 -v \"${PWD}\":/home/jovyan/work representation-learning-course\nTo access jupyter, simply copy the link provided when running this command. You can change the port that docker forwards to by changing the first 8888 in the -p 8888:8888 option. Just remember to correspondingly change the port you attempt to access in your browser."
  },
  {
    "objectID": "motivations.html",
    "href": "motivations.html",
    "title": "Motivations",
    "section": "",
    "text": "At their core, syntactic and semantic theories are (at least) explanations of judgments about strings–i.e. elements of the set \\(\\Sigma^* = \\bigcup_{i=0}^\\infty \\Sigma^i\\) for some vocabulary \\(\\Sigma\\).1 One kind of judgment we are often concerned with is acceptability (see Schütze 2016 and references therein): introspective judgments of strings’ well-formedness relative to a language, context of use, etc.   For example, in a context where a host is asking a guest what they would like in addition to coffee, (1) is clearly well-formed (or acceptable), while (2) is clearly not (Ross 1967; see Sprouse and Villata 2021 and references therein).\nAnother kind of judgment we are often concerned with–particularly in semantic theory–is about inferential relationships between strings (see Davis and Gillon 2004, Ch. 4 and references therein).   For example, in a context where someone uses (3) and their addressee both trusts the user and doesn’t know that (4), the addressee will tend to infer that (4)–i.e. the content of the subordinate clause in (3) (see White 2019 and references therein).\nOne important property we want syntactic and semantic theories to have is observational adequacy (Chomsky 1964): for any string \\(s \\in \\Sigma^*\\), we can predict how acceptable someone who knows the language will find \\(s\\) relative to a particular context; and for any pair of strings \\(s, s' \\in \\Sigma^*\\) that person judges acceptable, we can predict whether that person judges \\(s'\\) to be inferable from \\(s\\) and vice versa–again, relative to a particular context.2\nIn addition to observational adequacy, we tend to want theories that are parsimonious. A common way of moving forward in this respect is to posit methods for mapping vocabulary elements and strings to a more or less constrained set of abstractions for use in predicting the relationship between a string and judgments of its acceptability or inferential relationships to other strings.3\nThese abstractions may take a wide variety of forms:\nThis course covers techniques both for learning such abstractions (or representations) from experimental and/or corpus data–with a focus on acceptability and inference judgment data–and for quantitatively assessing the observational adequacy and parsimony of some set of assumptions about the nature of those representations.\nThis approach is motivated by the mutually supportive goals of enabling syntacticians and semanticists to:\nMy aim in this course is to give you the conceptual and practical tools to understand (what I take to be) the theoretically relevant portions of the computational modeling literature and to provide you with a jumping off point from which to begin your research journey into it. You should not expect the course to provide you with a comprehensive overview of the literature in a particular area–even the areas that we will use as case studies. For example, I am not going to cover all the ways that researchers have modeled island effects. Rather, I will demonstrate how to incrementally develop hypothesis-driven models that can help us answer particular theoretical questions."
  },
  {
    "objectID": "motivations.html#footnotes",
    "href": "motivations.html#footnotes",
    "title": "Motivations",
    "section": "Footnotes",
    "text": "Footnotes\n\n\nDepending on your persuasion, the vocabulary \\(\\Sigma\\) might be a set of words; or it might be a set of morphemes. Nothing’s going to hinge on this distinction in this course.↩︎\nWe may furthermore want explanations that handle inference judgements between strings that are judged to be degraded in some sense (Higginbotham 1985; Berwick et al. 2011).↩︎\nDefinition of a set of vocabulary elements and segmentation of a string into those elements is already a highly nontrivial form of abstraction. This course will generally presuppose that the correct segmentations are given.↩︎"
  },
  {
    "objectID": "methodological-approach.html",
    "href": "methodological-approach.html",
    "title": "Methodological Approach",
    "section": "",
    "text": "This course is highly methodologically opinionated in taking a hypothesis-driven approach to representation learning, rather than the now common analysis-driven approach seen in much work at the intersection of computational linguistics and natural language processing (see Baroni 2022; Pavlick 2023 and references therein). Hypothesis-driven approaches to representation learning are distinguished from analysis-driven approaches in that they aim to finely delineate hypotheses about the nature of a phenomenon in terms of the constraints they place on the representations to be learned. In contrast, analysis-driven approaches aim to learn highly expressive representations and then extract generalizations about those representations post hoc.\nThis methodological distinction is roughly analogous to one observed in the theoretical syntax literature–a distinction classically exemplified by work in transformational grammar in the 1970s and 1980s. For background: transformational grammars are extremely expressive–generating the recursively enumerable languages (Peters and Ritchie 1973). But it is relatively well accepted that natural languages are a subset of a much smaller class of languages–itself a strict subset of the context sensitive languages (Joshi, Shanker, and Weir 1990). Insofar as one is merely interested in observational adequacy, there isn’t really a reason not to use a highly expressive formalism, like a transformational grammar; but insofar as one is interested in specifying “…the observed data…in terms of significant generalizations that express underlying regularities in the language” (Chomsky 1964, 63)–e.g. to obtain descriptive adequacy–then it is necessary to go beyond simply specifying an observationally adequate transformational grammar.\nOn the one hand, one might implement this idea by stating metaanalytical generalizations about the observationally adequate analyses in the too-expressive formalism, with the ultimate goal of reifying those generalizations as constraints on the formalism (see Chomsky 1973 et seq). This approach is similar to what I refer to above as analysis-driven representation learning.\nOn the other hand, one might attempt to take a more constrained formalism–e.g. some mildly context sensitive formalism, such as combinatory categorial grammars (Steedman 1996) or minimalist grammars (Stabler 1997)–and ask how well that formalism can cover the data. This approach is similar to what I refer to above as hypothesis-driven representation learning–the approach taken in this course.\n\n\n\n\nReferences\n\nBaroni, Marco. 2022. “On the Proper Role of Linguistically Oriented Deep Net Analysis in Linguistic Theorising.” In Algebraic Structures in Natural Language. CRC Press.\n\n\nChomsky, Noam. 1964. “Current Issues in Linguistic Theory.” Edited by J. Fodor and J. Katz. The Structure of Language. New York: Prentice Hall.\n\n\n———. 1973. “Conditions on Transformations.” In A Festschrift for Morris Halle, edited by S. Anderson and P. Kiparsky, 232–86. New York: Holt, Rinehart, & Winston.\n\n\nJoshi, Aravind, Vijay K. Shanker, and David Weir. 1990. “The Convergence of Mildly Context-Sensitive Grammar Formalisms.” MS-CIS-90-01. Philadelphia: Department of Computer; Information Science, University of Pennsylvania. https://repository.upenn.edu/cis_reports/539.\n\n\nPavlick, Ellie. 2023. “Symbols and Grounding in Large Language Models.” Philosophical Transactions of the Royal Society A: Mathematical, Physical and Engineering Sciences 381 (2251). https://doi.org/10.1098/rsta.2022.0041.\n\n\nPeters, P. Stanley, and R. W. Ritchie. 1973. “On the Generative Power of Transformational Grammars.” Information Sciences 6 (January): 49–83. https://doi.org/10.1016/0020-0255(73)90027-3.\n\n\nStabler, Edward. 1997. “Derivational Minimalism.” In Logical Aspects of Computational Linguistics, edited by Christian Retoré, 68–95. Lecture Notes in Computer Science. Berlin, Heidelberg: Springer. https://doi.org/10.1007/BFb0052152.\n\n\nSteedman, Mark. 1996. Surface Structure and Interpretation. Cambridge, MA: MIT Press."
  },
  {
    "objectID": "course-structure-and-content.html",
    "href": "course-structure-and-content.html",
    "title": "Course Structure and Content",
    "section": "",
    "text": "This course is partitioned into four modules, each structured around a case study of an empirical phenomenon that has proven important in developing syntactic and semantic theories. As the course progresses, we will develop and implement increasingly more expressive statistical models that encode interpretable assumptions about the constructs (representations) that might explain these phenomena. We will begin in Module 1 with models that minimally extend standard generalized linear mixed effects models and end in Module 4 with models that integrate large language models as a subcomponent."
  },
  {
    "objectID": "course-structure-and-content.html#module-1-island-effects",
    "href": "course-structure-and-content.html#module-1-island-effects",
    "title": "Course Structure and Content",
    "section": "Module 1: Island Effects",
    "text": "Module 1: Island Effects\nIn Module 1, we will focus on island effects. Island effects are modulations of acceptability that arise when a dependency crosses into particular kinds of constitutents. We classify these constitutents as islands.   For example, one type of island effect is observed when a WH dependency crosses into a coordinate structure, as in (2) from Motivations. Compare (2) with (1), which would be used to express the same question and is much better.\n\nWhat would you like with your coffee?\nWhat would you like and your coffee?\n\nOur main question will be whether–once we adjust for various potential sources of noise in judgments to sentences like (1) and (2)–there is clear evidence one way or another for whether islands are the product of a discrete or continuous representation and/or process."
  },
  {
    "objectID": "course-structure-and-content.html#module-2-projective-content",
    "href": "course-structure-and-content.html#module-2-projective-content",
    "title": "Course Structure and Content",
    "section": "Module 2: Projective Content",
    "text": "Module 2: Projective Content\nIn Module 2, we will focus on projective content. Projective content is propositional content associated with a linguistic expression that a comprehender infers a user of some containing expression to be committed to irrespective of inference-modifying linguistic operators, such as negation (not, no, none, etc.), found in that containing expression.    For instance, from uses of both (3) and (4)—which both contain (5) as a subexpression—comprehenders tend to infer that (5), even though (4) contains negation.\n\nJo liked that Bo left.\nJo didn’t like that Bo left.\nBo left.\n\nIn these cases, we say that the content of the clause embedding under like projects. Our main question will be whether inferences about projective content are undergirded by some discrete representation and/or process–as has been classically assumed–or whether they are better modeled as fundamentally continuous in nature."
  },
  {
    "objectID": "course-structure-and-content.html#module-3-argument-selection",
    "href": "course-structure-and-content.html#module-3-argument-selection",
    "title": "Course Structure and Content",
    "section": "Module 3: Argument Selection",
    "text": "Module 3: Argument Selection\nIn Module 3, we will focus on argument selection.     Our aim will be to explain why certain predicates are acceptable when paired with certain kinds of arguments but not others. For example, (7) and (6), are generally judged acceptable, suggesting that think and see are compatible with finite declarative subordinate clauses, such as that Bo left.\n\nJo saw that Bo left.\nJo thought that Bo left.\n\nBut while (8) is generally judged acceptable, suggesting that that see is additionally compatible with bare infinitive subordinate clauses, (9) is generally judged unacceptable, suggesting that think is not.\n\nJo saw Bo leave.\nJo thought Bo leave.\n\nAt least two things are generally assumed to determine the arguments a predicate is compatible with: the kind of meaning it has and idiosyncratic knowledge about the predicate. We will compare classes of models that constrain kinds of meanings in various ways."
  },
  {
    "objectID": "course-structure-and-content.html#module-4-thematic-roles",
    "href": "course-structure-and-content.html#module-4-thematic-roles",
    "title": "Course Structure and Content",
    "section": "Module 4: Thematic Roles",
    "text": "Module 4: Thematic Roles\nIn Module 4, we will focus on thematic roles–investigating, in particular, different theories of generalized thematic roles. Generalized thematic roles–such as AGENT and PATIENT–contrast with individual thematic roles–such as BREAKER and BREAKEE–and are often posited in order to explain how individual thematic roles are linked to particular syntactic positions.   For instance, in expressing that a BREAKER caused a BREAKEE to be broken, we find predicates like break in (10), which realize the BREAKER in subject position and BREAKEE in object position, but not predicates like shbreak that do the inverse–i.e. such that (11) means the same thing as (10)?\n\nThe boy broke the vase.\nThe vase shbroke the boy.\n\nOne kind of explanation posited in the literature is that individual thematic roles are grouped into generalized thematic roles and that the generalized thematic role an individual thematic role falls into determines which syntactic position that individual thematic role is associated with. Theories differ as to what generalized thematic roles exist, how they ar related to each other, and how they determine the association of individual thematic roles with syntactic positions."
  },
  {
    "objectID": "course-structure-and-content.html#preliminaries",
    "href": "course-structure-and-content.html#preliminaries",
    "title": "Course Structure and Content",
    "section": "Preliminaries",
    "text": "Preliminaries\nBefore starting on the main content of the course, it will be useful to cover an array of foundational concepts in probability and statistics. These notes will be excessively formal and pedantic–taking you from the definition of a probability space in terms of the the Kolmogorov axioms, through the formal definition of a random variable and probability distribution, up to the implementation of simple Metropolis-Hastings-based samplers.\nI do not expect you to know most of this stuff to this level of formality already; and for the most part, I will not stay at the level of formality found in this section anywhere else in the course. The purpose of these notes is mainly to act as a reference for cases where including a more formal explanation of a concept in the main body of the course notes would detract from the flow."
  },
  {
    "objectID": "foundational-concepts-in-probability-and-statistics/index.html",
    "href": "foundational-concepts-in-probability-and-statistics/index.html",
    "title": "What is a probability?",
    "section": "",
    "text": "A probability is a measurement of a possibility (relative to a range of possibilities). Probability theory is a way of formalizing this idea. The most common such formalization–the Kolmogorov axioms–can be thought of as defining: (i) what it means to be a possibility; and (ii) what it means to measure a possibility.1"
  },
  {
    "objectID": "foundational-concepts-in-probability-and-statistics/index.html#what-it-means-to-be-a-possibility",
    "href": "foundational-concepts-in-probability-and-statistics/index.html#what-it-means-to-be-a-possibility",
    "title": "What is a probability?",
    "section": "What it means to be a possibility",
    "text": "What it means to be a possibility\nThe Kolmogorov axioms start by specifying a set \\(\\Omega\\) that contains all and only the things that can possibly happen. This set is known as the sample space. So what it means to be a possibility is a brute fact: it’s all and only the things in \\(\\Omega\\).\nThat’s very abstract, so let’s consider a few examples relevant to this class:\n\n\\(\\Omega\\) could the set of all phonemes in a language (or some subset thereof)–e.g. the English vowels \\(\\Omega = \\{\\text{e, i, o, u, æ, ɑ, ɔ, ə, ɛ, ɪ, ʊ}\\}\\).\n\\(\\Omega\\) could be the set of all pairs of first and second formants–represented as all pairs of positive real numbers \\(\\mathbb{R}_+^2\\).2\n\\(\\Omega\\) could be the set of all strings of phonemes in a language–e.g. if \\(\\Sigma\\) is the set of phonemes, then \\(\\Omega = \\Sigma^* = \\bigcup_{i=0}^\\infty \\Sigma^i\\).\n\\(\\Omega\\) could be the set of all strings of morphemes in a language–e.g. if \\(\\Sigma\\) is the set of morphemes, then \\(\\Omega = \\Sigma^* = \\bigcup_{i=0}^\\infty \\Sigma^i\\).\n\\(\\Omega\\) could be the set of all grammatical derivations for a grammar \\(G\\)–e.g. if \\(G = \\langle \\Sigma, V, R, S \\rangle\\) (with \\(R \\subseteq V \\times (V \\cup \\Sigma \\cup \\{\\epsilon\\})^+\\)) is a context free grammar, then \\(\\Omega = \\bigcup_{s \\in L_G} P_G(s)\\), where \\(L_G\\) is the language generated by \\(G\\) and \\(P_G\\) is a parser for \\(G\\).\n\nThe axioms then move forward by defining classes of possibilities \\(F \\subseteq \\Omega\\), which together form a classification of possibilities \\(\\mathcal{F} \\subseteq 2^\\Omega\\). These classes of possibilities are known as events and the classification of possibilities is known as the event space. It is events, which can contain just a single possibility, that we measure the probability of.3\n\nTwo event spaces for (a subset of) English pronouns\nThe event space is where interesting linguistic structure enters the picture. Let’s look at a few examples of event spaces that assume that the sample space is the following set of pronouns of English: \\(\\Omega = \\{\\text{I}, \\text{me}, \\text{you}, \\text{they}, \\text{them}, \\text{it}, \\text{she}, \\text{her}, \\text{he}, \\text{him}, \\text{we}, \\text{us}\\}\\).\n\nemptyset = frozenset()\npronouns = frozenset({\n    \"I\", \"me\", \n    \"you\", \n    \"they\", \"them\", \n    \"it\", \n    \"she\", \"her\", \n    \"he\", \"him\", \n    \"we\", \"us\",\n})\n\n\nThe person event space\nOne possible event space distinguishes these pronouns with respect to third v. non-third: \\(\\mathcal{F}_\\text{person} = \\{F_\\text{[+third]}, F_\\text{[-third]}, \\Omega, \\emptyset\\}\\), with \\(F_\\text{[+third]} = \\{\\text{they}, \\text{them}, \\text{it}, \\text{she}, \\text{her}, \\text{he}, \\text{him}\\}\\) and \\(F_\\text{[-third]} = \\Omega - F_\\text{[+third]}\\).\n\nthird = frozenset({\"they\", \"them\", \"it\", \"she\", \"her\", \"he\", \"him\",})\nnonthird = pronouns - third\n\nf_person = frozenset({\n    frozenset(emptyset), \n    frozenset(third), frozenset(nonthird), \n    frozenset(pronouns)\n})\n\nYou’ll notice that beyond having just the set of third v. non-third pronouns in the event space, we also have the entire set of pronouns \\(\\Omega\\) itself alongside the empty set \\(\\emptyset\\). The reasons for this are technical: to make certain aspects of the formalization of what it means to measure possibilities work out nicely, we need the event space \\(\\mathcal{F}\\) to form what is known as a \\(\\sigma\\)-algebra on the sample space \\(\\Omega\\). All this means is that:\n\n\\(\\mathcal{F} \\subseteq 2^\\Omega\\)\n\\(E \\in \\mathcal{F}\\) iff \\(\\Omega - E \\in \\mathcal{F}\\) (closure under complement)\n\\(\\bigcup \\mathcal{E} \\in \\mathcal{F}\\) for all countable \\(\\mathcal{E} \\subseteq \\mathcal{F}\\) (closure under countable union)\n\\(\\bigcap \\mathcal{E} \\in \\mathcal{F}\\) for all countable \\(\\mathcal{E} \\subseteq \\mathcal{F}\\) (closure under countable intersection)\n\nYou can check that all of these conditions are satisfied for \\(\\mathcal{F}_\\text{person}\\) only if \\(\\Omega\\) and \\(\\emptyset\\) are both in \\(\\mathcal{F}\\). When \\(\\mathcal{F} \\subseteq 2^\\Omega\\) is a \\(\\sigma\\)-algebra, the pair \\(\\langle \\Omega, \\mathcal{F} \\rangle\\) is referred to as a measurable space. When \\(\\Omega\\) is finite–as it is here–we say that \\(\\langle \\Omega, \\mathcal{F} \\rangle\\) is more specifically a finite measurable space.\n\nfrom typing import Set, FrozenSet, Iterable\nfrom itertools import chain, combinations\nfrom functools import reduce\n\nSampleSpace = FrozenSet[str]\nEvent = FrozenSet[str]\nSigmaAlgebra = FrozenSet[Event]\n\ndef powerset(iterable: Iterable) -&gt; Iterable:\n    \"\"\"The power set of a set\n\n    See https://docs.python.org/3/library/itertools.html#itertools-recipes\n\n    Parameters\n    ----------\n    iterable\n        The set to take the power set of\n    \"\"\"\n    s = list(iterable)\n    return chain.from_iterable(combinations(s, r) for r in range(len(s)+1))\n\nclass FiniteMeasurableSpace:\n    \"\"\"A finite measurable space\n    \n    Parameters\n    ----------\n    atoms\n        The atoms of the space\n    sigma_algebra\n        The σ-algebra of the space    \n    \"\"\"\n    def __init__(self, atoms: SampleSpace, sigma_algebra: SigmaAlgebra):\n        self._atoms = atoms\n        self._sigma_algebra = sigma_algebra\n\n        self._validate()\n\n    def _validate(self):\n        for subset in self._sigma_algebra:\n            # check powerset condition\n            if not subset &lt;= self._atoms:\n                raise ValueError(\n                    \"All events must be a subset of the atoms. \"\n                    f\"{set(subset)} is an event but not a subset.\"\n                )\n\n            # check closure under complement\n            if not (self._atoms - subset) in self._sigma_algebra:\n                raise ValueError(\n                    \"The σ-algebra must be closed under complements. \"\n                    f\"{set(self._atoms - subset)} is the complement of {set(subset)}, \"\n                    \"which is an event, but it is not an event.\"\n                )\n\n        for subsets in powerset(self._sigma_algebra):\n            subsets = list(subsets)\n\n            # python doesn't like to reduce empty iterables\n            if not subsets:\n                continue\n\n            # check closure under finite union\n            union = frozenset(reduce(frozenset.union, subsets))\n            if union not in self._sigma_algebra:\n                raise ValueError(\n                    \"The σ-algebra must be closed under countable union. \"\n                    f\"{union} is a union of events {subsets} but not an event.\"\n                )\n\n            # check closure under finite intersection\n            intersection = frozenset(reduce(frozenset.intersection, subsets))\n            if intersection not in self._sigma_algebra:\n                raise ValueError(\n                    \"The σ-algebra must be closed under finite intersection. \"\n                    f\"{set(intersection)} is the intersection of events {subsets} but \"\n                    \"not an event.\"\n                )\n                \n        print(\"This pair is a finite measurable space.\")\n\n    @property\n    def atoms(self) -&gt; SampleSpace: \n        return self._atoms\n\n    @property\n    def sigma_algebra(self) -&gt; SigmaAlgebra:\n        return self._sigma_algebra\n\nThe \\(\\sigma\\)-algebra conditions are checked as part of initializing the implementation of FiniteMeasurableSpace, and so we see that \\(\\langle \\Omega, \\mathcal{F}_\\text{person}\\rangle\\) is a measurable space.\n\nperson_space = FiniteMeasurableSpace(pronouns, f_person)\n\nThis pair is a finite measurable space.\n\n\n\n\nThe case event space\nAnother possible event space that is slightly more interesting distinguishes pronouns with respect to case: \\(\\mathcal{F}_\\text{case} = \\{F_\\text{[+acc]}, F_\\text{[-acc]}, F_\\text{[+acc]} \\cap F_\\text{[-acc]}, \\Omega - F_\\text{[+acc]}, \\Omega - F_\\text{[-acc]}, \\Omega - [F_\\text{[+acc]} \\cap F_\\text{[-acc]}], \\Omega, \\emptyset\\}\\), with \\(F_\\text{[+acc]} = \\{\\text{me}, \\text{you}, \\text{them}, \\text{her}, \\text{him}, \\text{it}, \\text{us}\\}\\) and \\(F_\\text{[-acc]} = \\{\\text{I}, \\text{you}, \\text{they}, \\text{she}, \\text{he}, \\text{it}, \\text{we}\\}\\). Beyond the set of pronouns \\(\\Omega\\), the empty set \\(\\emptyset\\), the set of accusative pronouns \\(F_\\text{[+acc]}\\) and the set of non-accusative pronouns \\(F_\\text{[-acc]}\\), we additionally need:\n\nThe set of pronouns that can be either accusative or non-accusative \\(F_\\text{[+acc]} \\cap F_\\text{[-acc]} = \\{\\text{you}, \\text{it}\\}\\).\nThe set of non-accusatives that cannot be accusative \\(\\Omega - F_\\text{[+acc]} = \\{\\text{I}, \\text{they}, \\text{he}, \\text{she}, \\text{we}\\}\\)\nThe set of accusatives that cannot be non-accusative \\(\\Omega - F_\\text{[-acc]} = \\{{\\text{me}, \\text{them}, \\text{her}, \\text{us}, \\text{him}}\\}\\)\nThe set of pronouns that cannot be both accusative and non-accusative \\(\\Omega - [F_\\text{[+acc]} \\cap F_\\text{[-acc]}]\\).\n\nThe first set is required to be in \\(\\mathcal{F}_\\text{case}\\) according to condition 4 of being a \\(\\sigma\\)-algebra.4 The other three sets are required to be in \\(\\mathcal{F}_\\text{case}\\) according to condition 2 of being a \\(\\sigma\\)-algebra.5\n\nacc = frozenset({\"me\", \"you\", \"them\", \"her\", \"him\", \"it\", \"us\"})\nnonacc = frozenset({\"I\", \"you\", \"they\", \"she\", \"he\", \"it\", \"we\"})\n\nf_case = frozenset({\n    frozenset(emptyset), \n    frozenset(acc), frozenset(nonacc),\n    frozenset(acc & nonacc),\n    frozenset(pronouns - acc),\n    frozenset(pronouns - nonacc),\n    frozenset(pronouns - (acc & nonacc)),\n    frozenset(pronouns)\n})\n\ncase_space = FiniteMeasurableSpace(pronouns, f_case)\n\nThis pair is a finite measurable space.\n\n\n\n\n\nCombining event spaces\nGiven two measurable spaces with the same sample space, such as \\(\\mathcal{F}_\\text{person}\\) and \\(\\mathcal{F}_\\text{case}\\), we might want to combine them to create a measurable space \\(\\mathcal{F}_\\text{person-case}\\) that contains events such as \\(F_\\text{[+third,+acc]}\\).\n\n\n\n\n\n\nQuestion\n\n\n\nCan we define \\(\\mathcal{F}_\\text{person-case} \\equiv \\mathcal{F}_\\text{person} \\cup \\mathcal{F}_\\text{case}\\). If not, why not?\n\n\n\n\n\n\n\n\nAnswer\n\n\n\n\n\nWe cannot define \\(\\mathcal{F}_\\text{person-case} \\equiv \\mathcal{F}_\\text{person} \\cup \\mathcal{F}_\\text{case}\\). While Condition 1 above would be satisfied (that’s easy), we would be missing quite a few sets that Conditions 2-4 require. For instance, the third person accusative pronouns \\(F_\\text{[+third,+acc]} \\equiv F_\\text{[+third]} \\cap F_\\text{[+acc]}\\) would not be an event.\n\n\n\n\ntry:\n    person_space = FiniteMeasurableSpace(pronouns, f_person.union(f_case))\nexcept ValueError as e:\n    print(f\"ValueError: {e}\")\n\nValueError: The σ-algebra must be closed under countable union. frozenset({'he', 'me', 'we', 'I', 'they', 'it', 'she', 'you', 'us'}) is a union of events [frozenset({'they', 'he', 'it', 'she', 'you', 'we', 'I'}), frozenset({'me', 'we', 'I', 'you', 'us'})] but not an event.\n\n\nThis point demonstrates an important fact about \\(\\sigma\\)-algebras: if you design a classification based on some (countable) set of features like person and case, the constraint that \\(\\mathcal{F}\\) be a \\(\\sigma\\)-algebra on \\(\\Omega\\) implies that \\(\\mathcal{F}\\) contains events corresponding to all possible conjunctions (e.g. third and accusative) and disjunctions (e.g. third and/or accusative) of those features. So we need to extend \\(\\mathcal{F}_\\text{person} \\cup \\mathcal{F}_\\text{case}\\) with additional sets. We call this extension the \\(\\sigma\\)-algebra generated by the family of sets \\(\\mathcal{F}_\\text{person} \\cup \\mathcal{F}_\\text{case}\\), denoted \\(\\sigma\\left(\\mathcal{F}_\\text{person} \\cup \\mathcal{F}_\\text{case}\\right)\\).\n\ndef generate_sigma_algebra(family: SigmaAlgebra) -&gt; SigmaAlgebra:\n    \"\"\"Generate a σ-algebra from a family of sets\n    \n    Parameters\n    ----------\n    family\n        The family of sets from which to generate the σ-algebra\n    \"\"\"\n\n    sigma_algebra = set(family)\n    old_sigma_algebra = set(family)\n    \n    complete = False\n\n    while not complete:\n        for subsets in powerset(old_sigma_algebra):\n            subsets = list(subsets)\n\n            if not subsets:\n                continue\n\n            union = reduce(frozenset.union, subsets)\n            sigma_algebra.add(union)\n\n            intersection = reduce(frozenset.intersection, subsets)\n            sigma_algebra.add(intersection)\n\n        complete = sigma_algebra == old_sigma_algebra\n        old_sigma_algebra = set(sigma_algebra)\n\n    return frozenset(sigma_algebra)\n\nOne challenge is that generating this \\(\\sigma\\)-algebra for even relatively small families of sets can take a non-trivial amount of time. So for the remainder of this review, I’m going to cheat a bit and artificially distinguish the pronouns whose accusative and non-accusative variants are the same.\n\npronouns = frozenset({\n    \"I\", \"me\", \n    \"you_nonacc\", \"you_acc\", \n    \"they\", \"them\", \n    \"it_nonacc\", \"it_acc\", \n    \"she\", \"her\", \n    \"he\", \"him\", \n    \"we\", \"us\",\n})\n\nThis move allows us to define the event space more simply.\n\nacc = frozenset({\"me\", \"you_acc\", \"them\", \"her\", \"him\", \"it_acc\", \"us\"})\nnonacc = frozenset({\"I\", \"you_nonacc\", \"they\", \"she\", \"he\", \"it_nonacc\", \"we\"})\n\nf_case = frozenset({\n    frozenset(emptyset), \n    frozenset(acc), frozenset(nonacc),\n    frozenset(pronouns)\n})\n\ncase_space = FiniteMeasurableSpace(pronouns, f_case)\n\nThis pair is a finite measurable space.\n\n\nTo ensure that the person and case spaces have the same sample space, we will similarly need to redefine the person space.\n\nthird = frozenset({\"they\", \"them\", \"it_acc\", \"it_nonacc\", \"she\", \"her\", \"he\", \"him\"})\nnonthird = pronouns - third\n\nf_person = frozenset({\n    frozenset(emptyset), \n    frozenset(third), frozenset(nonthird), \n    frozenset(pronouns)\n})\n\nperson_space = FiniteMeasurableSpace(pronouns, f_person)\n\nThis pair is a finite measurable space.\n\n\nFinally, we can generate the \\(\\sigma\\)-algebra for our person-case space and check that it’s valid.\n\nf_person_case = generate_sigma_algebra(f_person | f_case)\n\nperson_case_space = FiniteMeasurableSpace(pronouns, f_person_case)\n\nThis pair is a finite measurable space.\n\n\n\n\nConsiderations around defining event spaces\nThis way of setting up sample spaces is useful when we have strong a priori assumptions we want to inject into our probability models. We’ll see cases of this assumption injection as we move through the course. In many cases, however, we want an event space that makes fewer assumptions. So when the sample space is finite–as it is here–we’ll often just default to \\(\\mathcal{F} \\equiv 2^\\Omega\\), which is the “finest” event space on \\(\\Omega\\) we can muster–i.e. it is a superset of all other possible event spaces. This sort of event space, which is often referred to as the discrete event space on \\(\\Omega\\), will tend to ignore potentially useful prior knowledge we have about the sample space–e.g. morphosyntactic features that pronouns have–though it is possible to represent that knowledge “in the measurement”, as we’ll see.\nWhen the sample space is infinite, things get a bit trickier: the powerset is uncountable for even a countably infinite sample space–something that we need to consider in the context of working with strings and derivations.6 This property can be a problem for reasons I’ll gesture at when we discuss continuous probability distributions. So in general, we won’t work with event spaces that are power sets of their corresponding sample space in this context. We’ll instead work with what are called Borel \\(\\sigma\\)-algebras. It’s not important to understand the intricacies of what a Borel \\(\\sigma\\)-algebra is; I’ll try to give you an intuition below."
  },
  {
    "objectID": "foundational-concepts-in-probability-and-statistics/index.html#what-it-means-to-measure-a-possibility",
    "href": "foundational-concepts-in-probability-and-statistics/index.html#what-it-means-to-measure-a-possibility",
    "title": "What is a probability?",
    "section": "What it means to measure a possibility",
    "text": "What it means to measure a possibility\nI said that a probability is a measurement of a possibility. We’ve now formalized what a possibility is in this context. Now let’s turn to the measurement part.\nThe Kolmogorov axioms build the notion of a probability measure from the more general concept of a measure. All a probability measure \\(\\mathbb{P}\\) is going to do is to map from some event in the event space (e.g. third pronoun, accusative pronoun, etc.) to a non-negative real value–with values corresponding to higher probabilities. So it is a function \\(\\mathbb{P}: \\mathcal{F} \\rightarrow \\mathbb{R}_+\\). This condition is the first of the Kolmogorov axioms.\n\n\\(\\mathbb{P}: \\mathcal{F} \\rightarrow \\mathbb{R}_+\\)\n\nYou might be used to thinking of probabilities as being between \\([0, 1]\\). This property is a consequence of the two other axioms:\n\nThe probability of the entire sample space \\(\\mathbb{P}(\\Omega) = 1\\) (the assumption of unit measure)\nGiven a countable collection of events \\(E_1, E_2, \\ldots \\in \\mathcal{F}\\) that is pairwise disjoint–i.e. \\(E_i \\cap E_j = \\emptyset\\) for all \\(i \\neq j\\)–\\(\\mathbb{P}\\left(\\bigcup_i E_i\\right) = \\sum_i \\mathbb{P}(E_i)\\) (the assumption of \\(\\sigma\\)-additivity)\n\n\nfrom typing import Dict\n\nclass ProbabilityMeasure:\n    \"\"\"A probability measure with finite support\n\n    Parameters\n    ----------\n    domain\n        The domain of the probability measure\n    measure\n        The graph of the measure\n    \"\"\"\n\n    def __init__(self, domain: FiniteMeasurableSpace, measure: Dict[Event, float]):\n        self._domain = domain\n        self._measure = measure\n\n        self._validate()\n\n    def __call__(self, event: Event) -&gt; float:\n        return self._measure[event]\n\n    def _validate(self):\n        # check that the measure covers the domain\n        for event in self._domain.sigma_algebra:\n            if event not in self._measure:\n                raise ValueError(\n                    \"Probability measure must be defined for all events.\"\n                )\n\n        # check the assumption of unit measure\n        if self._measure[frozenset(self._domain.atoms)] != 1:\n            raise ValueError(\n                \"The probability of the sample space must be 1.\"\n            )\n\n        # check assumption of 𝜎-additivity\n        for events in powerset(self._domain.sigma_algebra):\n            events = list(events)\n\n            if not events:\n                continue\n\n            if not any(e1.intersection(e2) for e1, e2 in combinations(events, 2)):\n                prob_union = self._measure[reduce(frozenset.union, events)]\n                prob_sum = sum(self._measure[e] for e in events)\n\n            if round(prob_union, 4) != round(prob_sum, 4):\n                raise ValueError(\n                    \"The measure does not satisfy 𝜎-additivity.\"\n                )\n                \n        print(\"This probability measure is valid for the given measurable space.\")\n\nOne example of a probability measure for our measurable space \\(\\langle \\Omega, \\mathcal{F}_\\text{person-case}\\rangle\\) is the uniform measure: \\(\\mathbb{P}(E) = \\frac{|E|}{|\\Omega|}\\).\n\nmeasure_person_case = ProbabilityMeasure(\n    person_case_space,\n    {e: len(e)/len(person_case_space.atoms) \n     for e in person_case_space.sigma_algebra} \n)\n\nThis probability measure is valid for the given measurable space.\n\n\nThese axioms imply that the range of \\(\\mathbb{P}\\) is \\([0, 1]\\), even if its codomain is \\(\\mathbb{R}_+\\); otherwise, it would have to be the case that \\(\\mathbb{P}(E) &gt; 1\\) for some \\(E \\subset \\Omega\\). (\\(E\\) would have to be a strict subset of \\(\\Omega\\), since \\(\\Omega \\supseteq E\\) for all \\(E \\in \\mathcal{F}\\) and \\(\\mathbb{P}(\\Omega) = 1\\) by definition.) But \\(\\mathbb{P}(E) &gt; 1\\) cannot hold, since \\(\\mathbb{P}(\\Omega - E)\\)–which must be defined, given that \\(\\mathcal{F}\\) is closed under complementation–is nonnegative; and thus \\(\\mathbb{P}(E) + \\mathbb{P}(\\Omega - E) &gt; \\mathbb{P}(\\Omega) = 1\\) contradicts the third axiom \\(\\mathbb{P}(E) + \\mathbb{P}(\\Omega - E) = \\mathbb{P}(E \\cup [\\Omega - E]) = \\mathbb{P}(\\Omega) = 1\\).\n(One reason the codomain of \\(\\mathbb{P}\\) is often specified as the more general \\(\\mathbb{R}_+\\)–rather than \\([0, 1]\\) is to make salient the fact that probabilities are analogous to other kinds of measurements, like weight, height, temperature, etc.)\nThese axioms also imply that \\(\\mathbb{P}(\\emptyset) = 0\\), since \\(\\mathbb{P}(\\Omega) = \\mathbb{P}(\\Omega \\cup \\emptyset) = \\mathbb{P}(\\Omega) + \\mathbb{P}(\\emptyset) = 1\\), and so \\(\\mathbb{P}(\\emptyset) = 1 - \\mathbb{P}(\\Omega) = 0\\)."
  },
  {
    "objectID": "foundational-concepts-in-probability-and-statistics/index.html#summing-up",
    "href": "foundational-concepts-in-probability-and-statistics/index.html#summing-up",
    "title": "What is a probability?",
    "section": "Summing up",
    "text": "Summing up\nWe will formalize a probability space as a triple \\(\\langle \\Omega, \\mathcal{F}, \\mathbb{P} \\rangle\\) with:\n\nA set \\(\\Omega\\) (the sample space)\nA \\(\\sigma\\)-algebra \\(\\mathcal{F}\\) (the event space), where:\n\n\\(\\mathcal{F} \\subseteq 2^\\Omega\\)\n\\(E \\in \\mathcal{F}\\) iff \\(\\Omega - E \\in \\mathcal{F}\\) (closure under complement)\n\\(\\bigcup \\mathcal{E} \\in \\mathcal{F}\\) for all countable \\(\\mathcal{E} \\subseteq \\mathcal{F}\\) (closure under countable union)\n\\(\\bigcap \\mathcal{E} \\in \\mathcal{F}\\) for all countable \\(\\mathcal{E} \\subseteq \\mathcal{F}\\) (closure under countable intersection)\n\nA probability measure \\(\\mathbb{P}\\), where:\n\n\\(\\mathbb{P}: \\mathcal{F} \\rightarrow \\mathbb{R}_+\\)\nThe probability of the entire sample space \\(\\mathbb{P}(\\Omega) = 1\\) (the assumption of unit measure)\nGiven a countable collection of events \\(E_1, E_2, \\ldots \\in \\mathcal{F}\\) that is pairwise disjoint–i.e. \\(E_i \\cap E_j = \\emptyset\\) for all \\(i \\neq j\\)–\\(\\mathbb{P}\\left(\\bigcup_i E_i\\right) = \\sum_i \\mathbb{P}(E_i)\\) (the assumption of \\(\\sigma\\)-additivity)\n\n\nIt is this core that we build on in developing probabilistic models. To develop these models, it is useful to develop a few additional definitions and theorems.\n\nMutual exclusivity\nTwo events \\(A \\in \\mathcal{F}\\) and \\(B \\in \\mathcal{F}\\) are mutually exclusive if they are disjoint: \\(A \\cap B = \\emptyset\\). This implies that \\(\\mathbb{P}(A \\cap B) = \\mathbb{P}(\\emptyset) = 0\\) for all mutually exclusive events \\(A\\) and \\(B\\).\n\nclass ProbabilityMeasure(ProbabilityMeasure):\n\n    def are_mutually_exclusive(self, *events: Iterable[Event]):\n        self._validate_events(events)\n        return not any(e1.intersection(e2) for e1, e2 in combinations(events, 2))\n\n    def _validate_events(self, events: Iterable[Event]):\n        for i, event in enumerate(events):\n            if event not in self._domain.sigma_algebra:\n                raise ValueError(f\"event{i} is not in the event space.\")\n\nIn our running example, the set of third-person pronouns \\(F_\\text{[+third]}\\) and the set of non-third person pronouns \\(F_\\text{[-third]}\\) are mutually exclusive events because \\(F_\\text{[+third]} \\cap F_\\text{[-third]} = \\emptyset\\).\n\nmeasure_person_case = ProbabilityMeasure(\n    person_case_space,\n    {e: len(e)/len(person_case_space.atoms) \n     for e in person_case_space.sigma_algebra} \n)\n\nmeasure_person_case.are_mutually_exclusive(third, nonthird)\n\nTrue\n\n\n\n\nJoint probability\nThe joint probability \\(\\mathbb{P}(A, B)\\) of two events \\(A \\in \\mathcal{F}\\) and \\(B \\in \\mathcal{F}\\) is defined as the probability of the intersection of those two events \\(\\mathbb{P}(A, B) = \\mathbb{P}(A \\cap B)\\), which must be defined given that \\(\\mathcal{F}\\) is closed under countable intersection.\n\nfrom typing import List\n\nclass ProbabilityMeasure(ProbabilityMeasure):\n\n    def __call__(self, *events: Iterable[Event]) -&gt; float:\n        self._validate_events(events)\n\n        intersection = reduce(frozenset.intersection, events)\n\n        return self._measure[intersection]\n\nIn our running example, the probability of a third-person accusative pronoun is the joint probability \\(\\mathbb{P}\\left(F_\\text{[+third]}, F_\\text{[+acc]}\\right)\\).\n\nmeasure_person_case = ProbabilityMeasure(\n    person_case_space,\n    {e: len(e)/len(person_case_space.atoms) \n     for e in person_case_space.sigma_algebra} \n)\n\nmeasure_person_case(frozenset(third), frozenset(acc))\n\n0.2857142857142857\n\n\n\n\nConditional probability\nThe probability of an event \\(A \\in \\mathcal{F}\\) conditioned on (or given) an event \\(B \\in \\mathcal{F}\\) is defined as \\(\\mathbb{P}(A \\mid B) = \\frac{\\mathbb{P}(A, B)}{\\mathbb{P}(B)}\\). Note that \\(\\mathbb{P}(A \\mid B)\\) is undefined if \\(\\mathbb{P}(B) = 0\\).\n\nclass ProbabilityMeasure(ProbabilityMeasure):\n\n    def __or__(self, conditions: Iterable[Event]) -&gt; ProbabilityMeasure:\n        condition = reduce(frozenset.intersection, conditions)\n\n        self._validate_condition(condition)\n\n        measure = {\n            event: self(event, condition)/self(condition) \n            for event in self._domain.sigma_algebra\n        }\n\n        return ProbabilityMeasure(self._domain, measure)\n\n    def _validate_condition(self, condition: Event):\n        if condition not in self._domain.sigma_algebra:\n            raise ValueError(\"The conditions must be in the event space.\")\n\n        if self._measure[condition] == 0:\n            raise ZeroDivisionError(\"Conditions cannot have probability 0.\")\n\nIn our running example, the probability that a pronoun is third-person given that it is accusative is the conditional probability \\(\\mathbb{P}\\left(F_\\text{[+third]} \\mid F_\\text{[+acc]}\\right) = \\frac{\\mathbb{P}\\left(F_\\text{[+third]}, F_\\text{[+acc]}\\right)}{\\mathbb{P}\\left(F_\\text{[+acc]}\\right)}\\).\n\nperson_case_measure = {\n    event: len(event)/len(person_case_space.atoms) \n    for event in person_case_space.sigma_algebra\n}\n\nmeasure_person_case = ProbabilityMeasure(\n    person_case_space,\n    person_case_measure \n)\n\nmeasure_given_back = measure_person_case | [acc]\n\nmeasure_given_back(third)\n\n0.5714285714285714\n\n\nFrom this definition, it immediately follows that \\(\\mathbb{P}(A, B) = \\mathbb{P}(A \\mid B)\\mathbb{P}(B) = \\mathbb{P}(B \\mid A)\\mathbb{P}(A)\\), which in turn implies Bayes’ theorem.\n\\[\\mathbb{P}(A \\mid B) = \\frac{\\mathbb{P}(A, B)}{\\mathbb{P}(B)} = \\frac{\\mathbb{P}(B \\mid A)\\mathbb{P}(A)}{\\mathbb{P}(B)}\\]\nBayes’ theorem will be very important in this course.\nAnother important consequence of the definition of conditional probability is the chain rule:\n\\[\\begin{align*}\\mathbb{P}(E_1, E_2, E_3, \\ldots, E_N) &= \\mathbb{P}(E_1)\\mathbb{P}(E_2 \\mid E_1)\\mathbb{P}(E_3 \\mid E_1, E_2)\\ldots\\mathbb{P}(E_N \\mid E_1, E_2, \\ldots, E_{N-1})\\\\ &= \\mathbb{P}(E_1)\\prod_{i=2}^N \\mathbb{P}(E_i\\mid E_1, \\ldots, E_{i-1})\\end{align*}\\]\nThe chain rule will also be very important in this course.\n\n\nIndependence\nAn event \\(A \\in \\mathcal{F}\\) is independent of an event \\(B \\in \\mathcal{F}\\) (under \\(\\mathbb{P}\\)) if \\(\\mathbb{P}(A \\mid B) = \\mathbb{P}(A)\\). A theorem that immediately follows from this definition is that \\(A\\) and \\(B\\) are independent under \\(\\mathbb{P}\\) if and only if \\(\\mathbb{P}(A, B) = \\mathbb{P}(A \\mid B)\\mathbb{P}(B) = \\mathbb{P}(A)\\mathbb{P}(B)\\).\n\nclass ProbabilityMeasure(ProbabilityMeasure):\n\n    def are_independent(self, *events):\n        self._validate_events(events)\n\n        joint = self(*events)\n        product = reduce(lambda x, y: x * y, [self(e) for e in events])\n\n        return joint == product\n\nIn our running example of an event space structured by person and case, assuming all pronouns are equiprobable, none of the events are independent. In the discrete event space, many events will be independent.\n\nmeasure_person_case = ProbabilityMeasure(\n    person_case_space,\n    {e: len(e)/len(person_case_space.atoms) \n     for e in person_case_space.sigma_algebra} \n)\n\nmeasure_person_case.are_independent(frozenset(third), frozenset(acc))\n\nTrue\n\n\nNote that independence is not the same as mutual exclusivity; indeed, mutually exclusive events are not independent, since \\(\\mathbb{P}(A \\mid B) = \\frac{\\mathbb{P}(A, B)}{\\mathbb{P}(B)} = \\frac{0}{\\mathbb{P}(B)} = 0\\) (or is undefined if \\(\\mathbb{P}(B) = 0\\)) regardless of \\(\\mathbb{P}(A)\\), and therefore either \\(\\mathbb{P}(A \\mid B)\\) does not equal \\(\\mathbb{P}(A)\\) or \\(\\mathbb{P}(B \\mid A)\\) is undefined (because \\(\\mathbb{P}(A) = 0\\)), even when \\(\\mathbb{P}(B)\\) is."
  },
  {
    "objectID": "foundational-concepts-in-probability-and-statistics/index.html#footnotes",
    "href": "foundational-concepts-in-probability-and-statistics/index.html#footnotes",
    "title": "What is a probability?",
    "section": "Footnotes",
    "text": "Footnotes\n\n\nWhat it means for a quantity to be a probability is a surprisingly contentious topic. It’s an interesting topic–and I encourage you to read about the various possibilities–but for the purposes of this course, we will tend to think of probabilities as a quantification of a degree of belief. This interpretation is sometimes referred to as the subjective or Bayesian interpretation.↩︎\nIf you’ve taken a phonetics course, you know that this definition overgenerates possibilities, since the values that the first and second formats can take on are constrained by the structure of the human vocal tract.↩︎\nDon’t ask me why, but \\(\\mathcal{F}\\) is standard notation for the event space. Why we don’t use \\(\\mathcal{E}\\) is beyond me. It might be some convention from measure theory I’m not aware of; or it might have to do with not confusing the event space with the expectation \\(\\mathbb{E}\\), which we’ll review below.↩︎\nThe analogous set \\(F_\\text{[+third]} \\cap F_\\text{[-third]}\\) for \\(\\mathcal{F}_\\text{person}\\) is already accounted for, since \\(F_\\text{[+third]}\\) and \\(F_\\text{[-third]}\\) are disjoint and thus \\(F_\\text{[+third]} \\cap F_\\text{[-third]} = \\emptyset\\), which is in \\(\\mathcal{F}_\\text{person}\\).↩︎\nCondition 4 of being a \\(\\sigma\\)-algebra requires \\(F_\\text{[+acc]} \\cup F_\\text{[-acc]} \\in \\mathcal{F}_\\text{person}\\) (among other unions), but we do not need to explicitly say this, since \\(F_\\text{[+acc]} \\cup F_\\text{[-acc]} = \\Omega\\), which is already specified to be in \\(\\mathcal{F}_\\text{case}\\).↩︎\nRemember that \\(2^{\\Sigma^*}\\) is the set of all languages on \\(\\Sigma\\); and the set of all languages, even when \\(\\Sigma\\) is finite, is uncountable.↩︎"
  },
  {
    "objectID": "foundational-concepts-in-probability-and-statistics/random-variables-and-probability-distributions.html",
    "href": "foundational-concepts-in-probability-and-statistics/random-variables-and-probability-distributions.html",
    "title": "Random variables and probability distributions",
    "section": "",
    "text": "Random variables and probability distributions together provide a way of classifying probability spaces. One reason this classification is useful for our purposes is that it makes it straightforward to decompose probability spaces with complex event spaces–e.g. event spaces on strings or grammatical derivations–into a collection of simpler probability spaces.\nWhen actually working with random variables and probability distributions, the line between the two is often blurred. This fact is particularly apparent when we consider how popular libraries like scipy (and its dependents) model the two. For this reason, I’m going to walk through some technicalities before showing any code."
  },
  {
    "objectID": "foundational-concepts-in-probability-and-statistics/random-variables-and-probability-distributions.html#random-variables",
    "href": "foundational-concepts-in-probability-and-statistics/random-variables-and-probability-distributions.html#random-variables",
    "title": "Random variables and probability distributions",
    "section": "Random variables",
    "text": "Random variables\nWe tend to think of random variables as fundamentally indeterminate in nature. We model this indeterminacy using a function. Specifically, we use a measurable function \\(X: \\Omega \\rightarrow A\\), where \\(\\langle \\Omega, \\mathcal{F} \\rangle\\) and \\(\\langle A, \\mathcal{G} \\rangle\\) are both measurable spaces, which just means that \\(\\Omega\\) and \\(A\\) are sets associated with \\(\\sigma\\)-algebras \\(\\mathcal{F}\\) and \\(\\mathcal{G}\\), respectively. Given \\(\\sigma\\)-algebras \\(\\mathcal{F}\\) and \\(\\mathcal{G}\\), this function must satisfy the constraint that:\n\\[\\{X^{-1}(E) \\mid E \\in \\mathcal{G}\\} \\subseteq \\mathcal{F}\\]\nThat is, every event \\(E\\) in the codomain space \\(\\mathcal{G} \\subseteq 2^A\\) must have a corresponding event \\(X^{-1}(E)\\) as its pre-image in the domain space \\(\\mathcal{F} \\subseteq 2^\\Omega\\).\nI’m using \\(\\langle \\Omega, \\mathcal{F} \\rangle\\) for the domain space to signal that the domain of a random variable is always the sample and event space of some probability space, which means that there will always be some probability space \\(\\langle \\Omega, \\mathcal{F}, \\mathbb{P} \\rangle\\) implicit in a random variable \\(X\\).\nFor our purposes, the codomain \\(A\\) of \\(X\\) will almost always be the real numbers \\(\\mathbb{R}\\) and \\(\\mathcal{G}\\) will be almost always be the Borel \\(\\sigma\\)-algebra on \\(\\mathbb{R}\\). As I mentioned above, knowing the fine details of what a Borel \\(\\sigma\\)-algebra is is not going to be necessary: all you really need to know is that it’s got every real interval, so \\(E \\in \\mathcal{G}\\) will always be an interval (and crucially, not just a single real number).\nTo ground this out, we can consider our running example of English pronouns again, where \\(\\Omega = \\left\\{\\text{I}, \\text{me}, \\text{you}_\\text{[+acc]}, \\text{you}_\\text{[-acc]}, \\text{they}, \\text{them}, \\text{it}_\\text{[+acc]}, \\text{it}_\\text{[-acc]} \\text{she}, \\text{her}, \\text{he}, \\text{him}, \\text{we}, \\text{us}\\right\\}\\).\n\npronouns = frozenset({\n    \"I\", \"me\", \n    \"you_nonacc\", \"you_acc\", \n    \"they\", \"them\", \n    \"it_nonacc\", \"it_acc\", \n    \"she\", \"her\", \n    \"he\", \"him\", \n    \"we\", \"us\",\n})\n\nSo \\(X(\\omega)\\), where \\(\\omega\\) is some pronoun, will be a real number. It’s important to note that \\(X\\) is being applied directly to a pronoun (rather than a set of pronouns in the event space) and resulting in a single real number (rather than an interval in the Borel \\(\\sigma\\)-algebra on the reals). I’m pointing this out because of the way we defined a random variable: in terms of the pre-image \\(X^{-1}(E)\\) of \\(E\\) under \\(X\\) (relativized to \\(\\sigma\\)-algebras \\(\\mathcal{F}\\) and \\(\\mathcal{G}\\)). \\(X^{-1}(E)\\) is a pre-image, not the value of an inverse, which will be important when we discuss discrete v. continuous random variables.\nIf we were to assume that the event space for our pronouns is the discrete event space \\(2^\\Omega\\), one possible (arbitrarily ordered) random variable is:\n\\[V = \\begin{bmatrix} \\text{I} \\rightarrow 1 \\\\ \\text{me} \\rightarrow 2 \\\\ \\text{you}_\\text{[+acc]} \\rightarrow 3 \\\\ \\text{you}_\\text{[-acc]} \\rightarrow 4 \\\\ \\text{they} \\rightarrow 5 \\\\ \\text{them} \\rightarrow 6 \\\\ \\text{it}_\\text{[+acc]} \\rightarrow 7 \\\\ \\text{it}_\\text{[-acc]} \\rightarrow 8 \\\\ \\text{she} \\rightarrow 9 \\\\ \\text{her} \\rightarrow 10 \\\\ \\text{he} \\rightarrow 11 \\\\ \\text{him} \\rightarrow 12 \\\\ \\text{we} \\rightarrow 13 \\\\ \\text{us} \\rightarrow 14 \\\\ \\end{bmatrix}\\]\nSo then, for example, \\(V^{-1}((-\\infty, 4)) = \\left\\{\\text{I}, \\text{me}, \\text{you}_\\text{[+acc]}\\right\\}\\), \\(V^{-1}((1, 5)) = \\left\\{\\text{me}, \\text{you}_\\text{[+acc]}, \\text{you}_\\text{[-acc]}\\right\\}\\), and \\(V^{-1}((11, \\infty)) = V^{-1}((-\\infty, 1)) = V^{-1}((1, 2)) = \\emptyset\\), all of which are in \\(\\mathcal{F} = 2^\\Omega\\).\n\nDiscrete v. continuous random variables\nAn important distinction among random variables is whether they are discrete or continuous.\n\nDiscrete random variables\nA discrete random variable is one whose range \\(X(\\Omega)\\)—i.e. the image of its domain—is countable. The random variable given above is thus countable, since \\(V(\\Omega) = \\{1, ..., 14\\}\\) is finite and therefore countable.\nA discrete random variable need not be finite. For instance, we often want to work with sample spaces consisting of all strings \\(\\Sigma^*\\) of primitive elements \\(\\Sigma\\)–e.g. phonemes, morphemes, etc.–in a language. In this case, we might be concerned with modeling the length of a string, and so wemight define a random variable \\(L: \\Sigma^* \\rightarrow \\mathbb{R}\\) that maps a string \\(\\omega \\in \\Sigma^*\\) to its length \\(L(\\omega)\\). Unlike \\(V\\), \\(L\\) has an infinite but countable range (assuming lengths are isomorphic with the natural numbers); and unlike \\(V\\), \\(L\\) is not injective: if \\(L(\\omega_1) = L(\\omega_2)\\), it is not guaranteed that \\(\\omega_1 = \\omega_2\\), since many strings share a length with other strings.\n\n\nContinuous random variables\nA continuous random variable is a random variable whose range is uncountable. One example of a continuous random variable (mentioned earlier) is one where \\(\\Omega\\) is the set of all pairs of first and second formant values. In this case, we’ll assume that \\(\\Omega\\) is just all pairs of positive real numbers \\(\\mathbb{R}_+^2\\).1\nIf we assume that the random variable \\(F: \\mathbb{R}_+^2 \\rightarrow \\mathbb{R}^2\\) is the identity function \\(F(\\mathbf{x}) = \\mathbf{x}\\), we get that \\(F\\) is a continuous random variable, since \\(\\mathbb{R}\\) is uncountable and \\(F^{-1}(E) = E \\in \\mathcal{F}\\)."
  },
  {
    "objectID": "foundational-concepts-in-probability-and-statistics/random-variables-and-probability-distributions.html#probability-distributions",
    "href": "foundational-concepts-in-probability-and-statistics/random-variables-and-probability-distributions.html#probability-distributions",
    "title": "Random variables and probability distributions",
    "section": "Probability distributions",
    "text": "Probability distributions\nA probability distribution is a compact description of a probability space \\(\\langle \\Omega, \\mathcal{F}, \\mathbb{P} \\rangle\\) in conjunction with a random variable whose domain is \\(\\Omega\\) (relative to \\(\\mathcal{F}\\)).\n\nDiscrete probability distributions\nIn the case of a discrete random variable \\(X\\) (e.g. our pronoun and string-length examples), we can fully describe its probability distribution using a probability mass function (PMF) \\(p_X: \\text{cod}(X) \\rightarrow \\mathbb{R}_+\\).This function is defined directly in terms of the random variable and the probability function \\(\\mathbb{P}\\):\n\\[p_X(x) \\equiv \\mathbb{P}(\\{\\omega \\in \\Omega \\mid X(\\omega) = x\\})\\]\nThese definitions are related to a notation that you might be familiar with: \\(\\mathbb{P}(X = x) \\equiv p_X(x)\\). This notation is often extended to other relations \\(\\mathbb{P}(X \\in E) = \\mathbb{P}(\\{\\omega \\in \\Omega \\mid \\omega \\in X^{-1}(E)\\})\\) or \\(\\mathbb{P}(X \\leq x) \\equiv \\mathbb{P}(\\{\\omega: X(\\omega) \\leq x\\})\\).\nThe latter of these is often used in defining the cumulative distribution function (CDF) \\(F_X: \\text{cod}(X) \\rightarrow \\mathbb{R}_+\\):\n\\[F_X(x) = \\mathbb{P}(X \\leq x) = \\sum_{y \\in X(\\Omega):y&lt;x} p_X(y)\\]\nThe PMF (and by extension the CDF) is parameterized in terms of the information necessary to define their outputs for all possible inputs \\(x \\in X(\\Omega)\\). This parameterization allows us to talk about families of distributions, which all share a functional form (modulo the values of the parameters). We’ll see a few examples of this below.\nIn scipy, discrete distributions are implemented using scipy.rv_discrete, either by direct instantiation or subclassing.\n\nfrom scipy.stats import rv_discrete\n\n\nFinite distributions\nWhen there are a finite number of values that the random variables can take, as in the example of \\(V\\) above, the probability of each possibility can simply be listed. One such distribution—or really family of distributions—that we will make extensive use of—indeed, the distribution that our pronoun random variable \\(V\\) from above has—is the categorical distribution.2 This distribution is parameterized by a list of probabilities \\(\\boldsymbol\\theta\\), where \\(\\theta_i\\) gives \\(p_V(i) = \\mathbb{P}(V = i) = \\mathbb{P}(\\{\\omega \\in \\Omega \\mid V(\\omega) = i\\}) = \\theta_i\\) and \\(\\sum_{i \\in V(\\Omega)} \\theta_i\\).3\n\nfrom numpy import arange\n\nidx = arange(14)\ntheta = (0.03, 0.09, 0.03, 0.12, 0.07, 0.28, 0.07, 0.05, 0.02, 0.02, 0.07, 0.08, 0.05, 0.02)\ncategorical = rv_discrete(name='categorical', values=(idx, theta))\n\nThe PMF is implemented as an instance method rv_discrete.pmf on this distribution.\n\n\nCode\nimport warnings\nfrom matplotlib.pyplot import subplot\n\nwarnings.filterwarnings('ignore')\n\npronouns_ordered = [\n    'us', 'they', 'them', r'you_[-acc]',\n    'he', 'I', r'it_[-acc]', 'me', 'him', 'she',\n    'we', r'it_[+acc]', r'you_[+acc]', 'her'\n]\n\nax = subplot()\nax.plot(pronouns_ordered, categorical.pmf(idx), 'ro', ms=12, mec='r')\nax.vlines(pronouns_ordered, 0, categorical.pmf(idx), colors='r', lw=4)\nax.set_xticklabels(pronouns_ordered, rotation=45, ha='right')\nax.set_ylabel(\"Probability\")\n_ = ax.set_title(\"PMF for categorical distribution on pronouns\")\n\n\n\n\n\nThe Bernoulli distribution, which we will also make extensive use of, is a special case of the categorical distribution where \\(|X(\\Omega)| = 2\\).\n\nfrom scipy.stats import bernoulli\n\nBy convention, \\(X(\\Omega) = \\{0, 1\\}\\). In this case, we need to specify the probability \\(\\pi\\) for only one value of \\(X\\), since the probability of the other must be \\(1- \\pi\\). Indeed, more generally, we need to specify only \\(|X(\\Omega)| - 1\\) values for a random variable \\(X\\) that is distributed categorical.\nImportantly, note that the condition that \\(|X(\\Omega)| = 2\\) is a condition on the range of \\(X\\), not on \\(\\Omega\\). So it may be that \\(|\\Omega| &gt; 2\\). Indeed, we would want this in the case where we had an event space like \\(\\mathcal{F}_\\text{case}\\), where \\(\\mathcal{F}_\\text{case} = \\{F_\\text{[+acc]}, F_\\text{[-acc]}, \\Omega, \\emptyset\\}\\), with \\(F_\\text{[+acc]} = \\{\\text{me}, \\text{you}_\\text{[+acc]}, \\text{them}, \\text{her}, \\text{him}, \\text{it}_\\text{[+acc]}, \\text{us}\\}\\) and \\(F_\\text{[-acc]} = \\Omega - F_\\text{[+acc]}\\).\nWe then might say that:\n\\[X(\\omega) = \\begin{cases}\n1 & \\text{if } \\omega \\in F_\\text{[+acc]}\\\\\n0 & \\text{otherwise}\n\\end{cases}\\]\nThat is, the function that maps a pronoun to whether it is accusative or not is a Bernoulli random variable.\n\nbern = bernoulli(0.27)\n\n\n\nCode\nax = subplot()\nax.plot([\"[–acc]\", \"[+acc]\"], bern.pmf([0, 1]), 'ro', ms=12, mec='r')\nax.vlines([\"[–acc]\", \"[+acc]\"], 0, bern.pmf([0, 1]), colors='r', lw=4)\nax.set_ylabel(\"Probability\")\n_ = ax.set_title(\"PMF for Bernoulli distribution on pronoun case\")\n\n\n\n\n\n\n\n\n\n\n\nQuestion\n\n\n\nSuppose we did not include the case specifications on you and it in \\(\\Omega\\), instead defining \\(\\mathcal{F}_\\text{case}\\) as we did here: \\(\\mathcal{F}_\\text{case} = \\{F_\\text{[+acc]}, F_\\text{[-acc]}, F_\\text{[+acc]} \\cap F_\\text{[-acc]}, \\Omega - F_\\text{[+acc]}, \\Omega - F_\\text{[-acc]}, \\Omega - [F_\\text{[+acc]} \\cap F_\\text{[-acc]}], \\Omega, \\emptyset\\}\\), with \\(F_\\text{[+acc]} = \\{\\text{me}, \\text{you}, \\text{them}, \\text{her}, \\text{him}, \\text{it}, \\text{us}\\}\\) and \\(F_\\text{[-acc]} = \\{\\text{I}, \\text{you}, \\text{they}, \\text{she}, \\text{he}, \\text{it}, \\text{we}\\}\\). How would \\(X\\) need to change?\n\n\n\n\n\n\n\n\nAnswer\n\n\n\n\n\nOne option is to say:\n\\[X(\\omega) = \\begin{cases}\n2 & \\text{if } \\omega \\in F_\\text{[+acc]} \\land \\omega \\in F_\\text{[-acc]}\\\\\n1 & \\text{if } \\omega \\in F_\\text{[+acc]} \\land \\omega \\not\\in F_\\text{[-acc]}\\\\\n0 & \\text{otherwise}\n\\end{cases}\\]\nAnother option is to say:\n\\[X(\\omega) = \\begin{cases}\n\\langle 1, 1 \\rangle & \\text{if } \\omega \\in F_\\text{[+acc]} \\land \\omega \\in F_\\text{[-acc]}\\\\\n\\langle 1, 0 \\rangle & \\text{if } \\omega \\in F_\\text{[+acc]} \\land \\omega \\not\\in F_\\text{[-acc]}\\\\\n\\langle 0, 1 \\rangle & \\text{otherwise}\\\\\n\\end{cases}\\]\n\n\n\nI’ll follow the convention of denoting the PMF of a particular kind of distribution using (usually shortened versions of) the distribution’s name, with the parameters following a semicolon.4\n\\[\\text{Cat}(x; \\boldsymbol\\theta) = p_X(x) = \\mathbb{P}(X = x) = \\mathbb{P}(\\{\\omega \\in \\Omega \\mid X(\\omega) = x\\}) = \\theta_x\\]\nTo express the above equivalences, I’ll often write:\n\\[X \\sim \\text{Cat}(\\boldsymbol{\\theta})\\]\nThis statement is read “\\(X\\) is distributed categorical with parameters \\(\\boldsymbol{\\theta}\\).”\nSo then the Bernoulli distribution would just be:\n\\[\\text{Bern}(x; \\pi) = \\begin{cases}\\pi & \\text{if } x = 1\\\\1 - \\pi & \\text{if } x = 0\\end{cases}\\]\nAnd if a random variable \\(X\\) is distributed Bernoulli with parameter \\(\\pi\\), we would write:\n\\[X \\sim \\text{Bern}(\\pi)\\]\nIt’s sometimes useful to write the PMF for the categorical and Bernoulli distributions as:\n\\[\\text{Cat}(x; \\boldsymbol\\theta) = \\prod_{i \\in V(\\Omega)} \\theta_i^{1_{\\{x\\}}[i]}\\]\n\\[\\text{Bern}(x; \\pi) = \\pi^{x}(1-\\pi)^{1-x}\\]\nwhere\n\\[1_A[x] = \\begin{cases}1 & \\text{if } x \\in A\\\\ 0 & \\text{otherwise}\\\\ \\end{cases}\\]\nIn an abuse of notation, I will sometimes write:\n\\[\\text{Cat}(x; \\boldsymbol\\theta) = \\prod_{i \\in V(\\Omega)} \\theta_i^{1_{x}[i]}\\]\nCategorical and Bernoulli distributions won’t be the only finite distributions we work with, but they will be the most common.\n\n\nCountably infinite distributions\nWhen there are a countably infinite number of values that a random variable can take, as in the example of string length \\(L\\) above, the probability of each possibility cannot simply be listed: we need some way of computing it for any value.\nHowever we compute these values, they must sum to one as required by the assumption of unit measure: \\(\\mathbb{P}(\\Omega) = 1\\). Since \\(\\mathbb{P}(\\Omega) = \\sum_{x \\in X(\\Omega)} p_X(x)\\), another way of stating this requirement is to say that the series \\(\\sum_{x \\in X(\\Omega)} p_X(x)\\) must converge to 1.\nOne example of such a series is a geometric series, such as \\(\\sum_{k=1}^\\infty \\frac{1}{2^k} = \\frac{1}{2} + \\frac{1}{4} + \\frac{1}{8} + \\ldots = 1\\).\n\nclass parameterless_geometric_gen(rv_discrete):\n    \"A special case of the geometric distribution without parameters\"\n    def _pmf(self, k):\n        return 2.0 ** -(k+1)\n\nparameterless_geometric = parameterless_geometric_gen(name=\"parameterless_geometric\")\n\nThis series gives us our first example of a probability distribution with infinite support–i.e. one that assigns a non-zero probability to an infinite (but countable) number of values of a random variable. So for instance, if we are considering our random variable \\(L\\) mapping strings to their lengths, \\(p_X(k) = \\frac{1}{2^k}\\) is a possible PMF for \\(L\\).5\n\n\nCode\nk = arange(10)\n\nax = subplot()\nax.plot(k, parameterless_geometric.pmf(k), 'ro', ms=12, mec='r')\nax.vlines(k, 0, parameterless_geometric.pmf(k), colors='r', lw=4)\nax.vlines(k, 0, parameterless_geometric.pmf(k), colors='r', lw=4)\nax.set_ylabel(\"Probability\")\n_ = ax.set_title(\"PMF of distribution defined by geometric series\")\n\n\n\n\n\nAs it stands, this distribution has no parameters, meaning that we have no control over how quickly the probabilities drop off. The geometric distribution provides us this control using a parameter to \\(\\pi \\in (0, 1]\\):\n\\[\\text{Geom}(k; \\pi) = (1-\\pi)^k\\pi\\]\n\nfrom scipy.stats import geom\n\nWhen \\(\\pi = \\frac{1}{2}\\), we get exactly the distribution above.\n\n\nCode\np = 0.5\n\nax = subplot()\nax.plot(k, geom(p).pmf(k+1), 'ro', ms=12, mec='r')\nax.vlines(k, 0, geom(p).pmf(k+1), colors='r', lw=4)\nax.set_ylabel(\"Probability\")\n_ = ax.set_title(f\"PMF of Geometric({p}) distribution\")\n\n\n\n\n\nAs \\(\\pi \\rightarrow 0\\), the distribution flattens out (or becomes denser).\n\n\nCode\np = 0.1\n\nax = subplot()\nax.plot(k, geom(p).pmf(k+1), 'ro', ms=12, mec='r')\nax.vlines(k, 0, geom(p).pmf(k+1), colors='r', lw=4)\nax.set_ylabel(\"Probability\")\n_ = ax.set_title(f\"PMF of Geometric({p}) distribution\")\n\n\n\n\n\nAnd as \\(\\pi \\rightarrow 1\\), it becomes sharper (or sparser).\n\n\nCode\np = 0.9\n\nax = subplot()\nax.plot(k, geom(p).pmf(k+1), 'ro', ms=12, mec='r')\nax.vlines(k, 0, geom(p).pmf(k+1), colors='r', lw=4)\nax.set_ylabel(\"Probability\")\n_ = ax.set_title(f\"PMF of Geometric({p}) distribution\")\n\n\n\n\n\nAt this point, it’s useful to pause for a moment to think about what exactly a parameter like \\(\\pi\\) is. I said above that random variables and probability distributions together provide a way of classifying probability spaces: in saying that \\(p_X(k) = (1-\\pi)^k\\pi\\) we are describing \\(\\mathbb{P}: \\mathcal{F} \\rightarrow \\mathbb{R}_+\\) by using \\(X\\) to abstract across whatever the underlying measurable space \\(\\langle \\Omega, \\mathcal{F} \\rangle\\) is. The distribution gives you the form of that description; the parameter \\(\\pi\\) gives the content of the description. Because the use of \\(X\\) is always implied, unless it really matters, I’m going to start dropping \\(X\\) from \\(p_X\\) unless I’m emphasizing the random variable in some way.\nThe \\(\\pi\\) parameter of a geometric distribution allows us to describe distributions that have a very particular shape–namely, ones where \\(\\forall k \\in \\mathbb{N}: p(k) &gt; p(k + 1)\\). But this isn’t always a good way of describing a particular distribution. For instance, for our string-length variable \\(L\\), it’s probably a pretty bad description regardless of what particular distribution on string lengths (type or token) we’re describing because 1 grapheme/phoneme words just aren’t more frequent than two grapheme/phoneme words. This point can be seen if we look at the distribution of word lengths at the type level in the CMU Pronouncing Dictionary, which contains phonemic transcriptions of English words.\n\nfrom urllib.request import urlopen\n\ncmudict_url = \"http://svn.code.sf.net/p/cmusphinx/code/trunk/cmudict/cmudict-0.7b\"\n\nwith urlopen(cmudict_url) as cmudict:\n    words = [\n        line.split()[1:] for line in cmudict if line[0] != 59\n    ]\n\n\n\nCode\nax = subplot()\n\nax.hist([len(w) for w in words], bins=32, density=True)\n\nax.set_title(\"Distribution of word length in phonemes\")\nax.set_xlabel(\"Word length in phonemes\")\n_ = ax.set_ylabel(\"Relative frequency\")\n\n\n\n\n\nOne such distribution that give us more flexibility in this respect is the negative binomial distribution, which is a very useful for modeling token frequency in text (Church and Gale 1995). This distribution effectively generalizes the geometric by allowing us to control the exponent on \\(\\pi\\) with a new parameter \\(r\\).\n\\[\\text{NegBin}(k; \\pi, r) = {k+r-1 \\choose r-1}(1-\\pi)^{k}\\pi^{r}\\]\n\nfrom scipy.stats import nbinom\n\nThis added flexibility in turn requires us to add an additional term \\({k+r-1 \\choose r-1} = \\frac{(k+r-1)!}{(r-1)!\\,(k)!}\\) that ensures that the series \\(\\sum_{k=0}^\\infty \\text{NegBin}(k; \\pi, r)\\) converges to \\(1\\). The pieces of this term that do not include the value we’re computing the probability of–i.e. \\(\\frac{1}{(r-1)!}\\)–are often called the normalizing constant. We will make extensive use of this concept as the course moves forward.\nWhen \\(r = 1\\), we of course just get the geometric distribution. As such, if we keep \\(r = 1\\), manipulating \\(\\pi\\) will have the same effect we saw above.\n\np = 0.5\nr = 1\n\n\n\nCode\nax = subplot()\nax.plot(k, nbinom(r, p).pmf(k+1), 'ro', ms=12, mec='r')\nax.vlines(k, 0, nbinom(r, p).pmf(k+1), colors='r', lw=4)\nax.set_ylabel(\"Probability\")\n_ = ax.set_title(f\"PMF of NegBin({p}, {r}) distribution\")\n\n\n\n\n\nAs \\(r\\) grows, though, we get very different behavior: \\(p(k)\\) is no longer always greater than \\(p(k + 1)\\). Another way of saying this is that we can use \\(r\\) to shift the probability mass rightward.\n\np = 0.5\nr = 5\n\n\n\nCode\nax = subplot()\nax.plot(k, nbinom(r, p).pmf(k+1), 'ro', ms=12, mec='r')\nax.vlines(k, 0, nbinom(r, p).pmf(k+1), colors='r', lw=4)\nax.set_ylabel(\"Probability\")\n_ = ax.set_title(f\"PMF of NegBin({p}, {r}) distribution\")\n\n\n\n\n\nThe mass-shifting effect is modulated by \\(\\pi\\): it accelerates with small \\(\\pi\\)…\n\np = 0.1\nr = 5\n\n\n\nCode\nax = subplot()\nax.plot(k, nbinom(r, p).pmf(k+1), 'ro', ms=12, mec='r')\nax.vlines(k, 0, nbinom(r, p).pmf(k+1), colors='r', lw=4)\nax.set_ylabel(\"Probability\")\n_ = ax.set_title(f\"PMF of NegBin({p}, {r}) distribution\")\n\n\n\n\n\n…but decelerates with large \\(\\pi\\).\n\np = 0.9\nr = 5\n\n\n\nCode\nax = subplot()\nax.plot(k, nbinom(r, p).pmf(k+1), 'ro', ms=12, mec='r')\nax.vlines(k, 0, nbinom(r, p).pmf(k+1), colors='r', lw=4)\nax.set_ylabel(\"Probability\")\n_ = ax.set_title(f\"PMF of NegBin({p}, {r}) distribution\")\n\n\n\n\n\n\np = 0.9\nr = 40\n\n\n\nCode\nax = subplot()\nax.plot(k, nbinom(r, p).pmf(k+1), 'ro', ms=12, mec='r')\nax.vlines(k, 0, nbinom(r, p).pmf(k+1), colors='r', lw=4)\nax.set_ylabel(\"Probability\")\n_ = ax.set_title(f\"PMF of NegBin({p}, {r}) distribution\")\n\n\n\n\n\nWe won’t talk about how to fit a distribution to some data until later, when we talk about parameter estimation; but the negative binomial distribution can provide a reasonably good description of the empirical distribution of word lengths. One way to visualize this is to compare the empirical CDF with the CDF of the best fitting negative binomial.\n\nfrom numpy import ones, exp, round, mgrid\n\nfrom statsmodels.distributions.empirical_distribution import ECDF\nfrom statsmodels.discrete.discrete_model import NegativeBinomial\n\necdf = ECDF([len(w) for w in words])\nnegbin_fit = NegativeBinomial([len(w) for w in words], ones(len(words))).fit()\n\np = 1/exp(1+negbin_fit.params[0]*negbin_fit.params[1])\nr = exp(negbin_fit.params[0])*p/(1-p)\n\nprint(f\"p = {round(p, 2)}, r = {round(r, 2)}\")\n\nOptimization terminated successfully.\n         Current function value: 2.180477\n         Iterations: 22\n         Function evaluations: 24\n         Gradient evaluations: 24\np = 0.37, r = 3.71\n\n\n\n\nCode\nk = arange(30)\n\nax = subplot()\nax.plot(mgrid[1:30:0.1], ecdf(mgrid[1:30:0.1]), label=\"Empirical CDF\")\nax.plot(mgrid[1:30:0.1], nbinom(r, p).cdf(mgrid[1:30:0.1]), label=f\"Estimated CDF\\nNegBin({round(p, 2)}, {round(r, 2)})\")\nax.legend()\nax.set_title(\"CDF of word length in phonemes\")\nax.set_xlabel(\"Word length in phonemes\")\n_ = ax.set_ylabel(\"Cumulative relative frequency/probability\")\n\n\n\n\n\nA limiting case of the negative binomial distribution that you may be familiar with is the Poisson distribution.\n\\[\\text{Pois}(k; \\lambda) = \\frac{\\lambda^k\\exp(-\\lambda)}{k!}\\]\nThe Poisson distribution arises as \\(\\text{Pois}(k; \\lambda) = \\lim_{r \\rightarrow \\infty} \\text{NegBin} \\left(k; r, \\frac{\\lambda}{r + \\lambda}\\right)\\).\n\n\n\nContinuous probability distributions\nOnce we move to working with random variables that have an uncountable number of values–as in the case of our formant value example above, where \\(X: \\mathbb{R}_+^2 \\rightarrow \\mathbb{R}^2\\) is the identity function–we can no longer assign a non-zero probability to every value that variable takes. The intuition for why this is is that there are just too many numbers (e.g. too many possible formant values); and if we assigned non-zero probability to more than countably many of them, we’d end up with a sum across those numbers that doesn’t satisfy the assumption of \\(\\sigma\\)-additivity.6\nThis fact is why we require the event space for an uncountable sample space to be a Borel \\(\\sigma\\)-algebra. Remember that a Borel \\(\\sigma\\)-algebra for the reals will contain all the intervals we might want but not single real numbers. This assumption about the event space in turn means that we don’t need to worry about assigning non-zero probability to uncountably many values: indeed, we will always assign exactly zero probability to any particular real. (Well. Most of the time.) To restate this: every possibility in a real-valued sample space has probability zero: \\(\\forall x \\in \\Omega: \\mathbb{P}(x) = 0\\). This in turn means that a PMF isn’t going to be useful here.\nWhat we work with instead is a probability density function (PDF) \\(f_X: \\Omega \\rightarrow \\mathbb{R}_+\\). Note that the PMF, which I will usually denote \\(p\\) or \\(p_X\\), and the PDF, which I will usually denote \\(f\\) or \\(f_X\\), have the same function signature. It is important to note that they provide very different information: where the PMF tells you the probability of a particular possibility, the PDF does not, though it can be used to compute a probability: specifically, the probability of \\(X\\) taking on a value in some set. So it can be used to tell you \\(\\mathbb{P}(X \\in A)\\):\n\\[\\mathbb{P}(X \\in A) = \\int_A f_X(x) \\, \\mathrm{d}x\\]\nWhen the codomain of \\(X\\) is a single value (rather than a vector), we call the distribution univariate; otherwise, we call it multivariate. We can express univariate continuous distributions as:\n\\[\\mathbb{P}(a &lt; X &lt; b) = \\int_a^b f_X(x) \\, \\mathrm{d}x\\]\nThis expressions is a special case of the first:\n\\[\\mathbb{P}(a &lt; X &lt; b) = \\mathbb{P}(X \\in (a, b)) = \\int_{(a, b)} f_X(x) \\, \\mathrm{d}x\\]\nWe can in turn express the cumulative distribution function \\(F_X\\) in a similar way, but without a lower bound:\n\\[F_X(b) = \\mathbb{P}(X &lt; b) = \\int_{-\\infty}^b f_X(x) \\, \\mathrm{d}x\\]\nIt can sometimes be useful to express \\(\\mathbb{P}(a &lt; X &lt; b)\\) and \\(\\mathbb{P}(X &gt; x)\\) in terms of \\(F_X\\):\n\\[\\mathbb{P}(a &lt; X &lt; b) = F_X(b) - F_X(a)\\] \\[\\mathbb{P}(X &gt; x) = 1 - F_X(x)\\]\n\nUnivariate continuous uniform distribution\nThe simplest example of a continuous distribution is the univariate uniform distribution, which is parameterized by an infimum \\(a\\) and a supremum \\(b\\) and has a PDF:\n\\[\\mathcal{U}(x; a, b) = \\begin{cases}\\frac{1}{b - a} & \\text{if } x \\in [a, b] \\\\ 0 & \\text{otherwise}\\end{cases}\\]\n\nfrom scipy.stats import uniform\n\n\n\nCode\nu = uniform(0, 1)\n\nax = subplot()\n\nax.plot(\n    mgrid[-1:2:0.01], \n    u.pdf(mgrid[-1:2:0.01])\n)\nax.set_title(r\"PDF of $\\mathcal{U}(0, 1)$\")\n_ = ax.set_ylabel(\"Density\")\n\n\n\n\n\nYou’ll note that I’m using \\(\\mathcal{U}\\)–rather than something like \\(\\text{Unif}\\)–for the name of the PDF. Certain distributions, including the continuous uniform and the normal or gaussian, canonically have such names.\nYou’ll also note that \\(\\mathcal{U}(x; a, b)\\) is the PDF, not the PMF. This notational convention is common: for discrete distributions like the negative binomial \\(\\text{NegBin}\\) will be used to denote the PMF (or to express that a random variable has a particular distribution), while for continuous distributions like the continuous uniform, \\(\\mathcal{U}\\) will be used to denote the PDF (or to express that a random variable has a particular distribution).\nRemember that the PDF does not give you the probability of a value: the probability of a (continuous) uniformly distributed value \\(x\\) is not \\(\\frac{1}{b - a}\\), it is \\(0\\); \\(\\frac{1}{b - a}\\) is the value of the density at \\(x\\). This means that:\n\\[\\mathbb{P}(x &lt; X &lt; y) = \\int_x^y f_X(z)\\,\\mathrm{d}z = \\frac{\\min(y, b) - \\max(x, a)}{b - a}\\]\nwhere \\(a = \\inf \\{x \\in X(\\Omega) \\mid f_X(x) &gt; 0\\}\\) and \\(b = \\sup \\{x \\in X(\\Omega) \\mid f_X(x) &gt; 0\\}\\). So then, if \\(a=0\\) and \\(b=1\\), \\(\\mathbb{P}(0.25 &lt; X &lt; 0.75) = 0.5\\). This can be visualized by filling in the area we’re integrating.\n\n\nCode\nax = subplot()\n\nax.plot(\n    mgrid[-1:2:0.01], \n    u.pdf(mgrid[-1:2:0.01])\n)\n_ = ax.fill_between(\n    mgrid[0.25:0.75:0.01], \n    u.pdf(mgrid[0.25:0.75:0.01])\n)\nax.set_title(r\"Probability mass of (0.25, 0.75) under PDF of $\\mathcal{U}(0, 1)$\")\n_ = ax.set_ylabel(\"Density\")\n\n\n\n\n\nRather than define parameters relative to \\(X\\) every time we want to specify a probability, I’ll often write:\n\\[\\mathbb{P}(x &lt; X &lt; y; a, b) = \\int_x^y f_X(z)\\,\\mathrm{d}z = \\frac{\\min(y, b) - \\max(x, a)}{b - a}\\]\nOr:\n\\[\\mathbb{P}(x &lt; X &lt; y \\mid a, b) = \\int_x^y f_X(z)\\,\\mathrm{d}z = \\frac{\\min(y, b) - \\max(x, a)}{b - a}\\]\nWhether I use the semicolon or pipe will depend on context, as we’ll discuss below: it basically comes down to whether I’m assuming that \\(a\\) and \\(b\\) are the values of some underlying random variables–in which case, \\(\\mathbb{P}(x &lt; X &lt; y \\mid a, b)\\) is really shorthand for something like \\(\\mathbb{P}(x &lt; X &lt; y \\mid A=a, B=b)\\)–or whether they’re fixed values given by some oracle.\nThe CDF \\(F_X\\) for a uniform random variable \\(X\\) is then:\n\\[F_X(x) = \\mathbb{P}(X &lt; x; a, b) = \\int_{-\\infty}^x f_X(z)\\,\\mathrm{d}z = \\frac{\\min(\\max(x, a), b) - a}{b - a}\\]\n\n\nCode\nax = subplot()\n\nax.plot(\n    mgrid[-1:2:0.01], \n    uniform(0, 1).cdf(mgrid[-1:2:0.01])\n)\n\nax.set_title(r\"CDF of $\\mathcal{U}(0, 1)$\")\n_ = ax.set_ylabel(r\"Probability $\\mathbb{P}(X &lt; x)$\")\n\n\n\n\n\n\n\nBeta distribution\nLike the geometric distribution, the continuous uniform distribution doesn’t give us all the control we might want over the shape of the distribution. We can gain that additional control using a Beta distribution.\n\\[\\text{Beta}(x; \\alpha, \\beta) = \\begin{cases}\\frac{x^{\\alpha-1}(1-x)^{\\beta-1}} {\\mathrm{B}(\\alpha,\\beta)} & \\text{if } x \\in (0, 1)\\\\0 & \\text{otherwise}\\end{cases}\\]\nwhere \\(\\mathrm{B}(\\alpha,\\beta) = \\frac {\\Gamma (\\alpha)\\Gamma (\\beta)}{\\Gamma (\\alpha+\\beta)}\\), the normalizing constant, is known as the beta function and \\(\\Gamma\\) (the gamma function) generalizes the factorial function to real numbers: \\(\\Gamma(x+1) = x\\Gamma(x) = x!\\) for all positive natural numbers; and more generally, for positive really numbers \\(\\Gamma(x) = \\int_0^\\infty t^{x-1} e^{-t}\\,\\mathrm{d}t\\).\n\nfrom scipy.stats import beta\n\nThe beta distribution can be thought of as a generalization of the uniform distribution \\(\\mathcal{U}(0, 1)\\), since it is equivalent when \\(\\alpha = \\beta = 1\\).\n\na = 1\nb = 1\n\n\n\nCode\nax = subplot()\n\nax.plot(\n    mgrid[-1:2:0.01], \n    beta(a, b).pdf(mgrid[-1:2:0.01])\n)\n\nax.set_title(f\"PDF of Beta({a}, {b})\")\n_ = ax.set_ylabel(\"Density\")\n\n\n\n\n\nDefined this way, the beta distribution has support on (assigns non-zero values) only intervals in \\((0, 1)\\), but if we ever need support over an arbitrary finite interval \\((a, b)\\), we can simply add the bounds \\(a\\) and \\(b\\) to the parameterization.\n\\[\\text{Beta}(x; \\alpha, \\beta, a, b) = \\begin{cases}\\frac{\\left(\\frac{x - a}{b - a}\\right)^{\\alpha-1}\\left(1-\\frac{x - a}{b - a}\\right)^{\\beta-1}} {\\mathrm{B}(\\alpha,\\beta)} & \\text{if } x \\in (a, b)\\\\0 & \\text{otherwise}\\end{cases}\\]\nThis definition makes the beta distribution a true generalization of \\(\\mathcal{U}(a, b) = \\text{Beta}(1, 1, a, b)\\). We’ll mainly work with the two-parameter version for the sake of simplicity, and because for most use cases, we actually only need support on \\((0, 1)\\).\nManipulating the shape parameters \\(\\alpha\\) and \\(\\beta\\) introduces bias toward \\(0\\), \\(1\\), or \\(\\frac{\\alpha}{\\alpha + \\beta}\\). When \\(\\alpha = \\beta &gt; 1\\), we get more and more density closer to \\(\\frac{\\alpha}{\\alpha + \\beta} = 0.5\\). We say that these distributions are symmetric (and dense, for reasons I will discuss in a second).\n\ndense_symmetric_beta_params = [\n    (3, 3),\n    (5, 5),\n    (10, 10)\n]\n\n\n\nCode\nax = subplot()\n\nfor a, b in dense_symmetric_beta_params:\n    ax.plot(\n        mgrid[0:1:0.01], \n        beta(a, b).pdf(mgrid[0:1:0.01]),\n        label=f\"Beta({a}, {b})\"\n    )\n\nax.legend()\nax.set_title(r\"PDF of dense symmetric Beta\")\n_ = ax.set_ylabel(\"Density\")\n\n\n\n\n\nIf we increase \\(\\alpha\\) relative to \\(\\beta &gt; 1\\), we shift this density to the right; and if we increase \\(\\beta\\) relative to \\(\\alpha &gt; 1\\), we shift the density toward the left. We say that these are asymmetric.\n\ndense_asymmetric_beta_params = [\n    (5, 3),\n    (3, 5)\n]\n\n\n\nCode\nax = subplot()\n\nfor a, b in dense_asymmetric_beta_params:\n    ax.plot(\n        mgrid[0:1:0.01], \n        beta(a, b).pdf(mgrid[0:1:0.01]),\n        label=f\"Beta({a}, {b})\"\n    )\n\nax.legend()\nax.set_title(r\"PDF of dense asymmetric Beta\")\n_ = ax.set_ylabel(\"Density\")\n\n\n\n\n\nIn both cases, we have a bias against values nearer to \\(0\\) and \\(1\\) in proportion to how much greater than one the smaller of \\(\\alpha\\) and \\(\\beta\\) are.\nWhen either \\(\\alpha &gt; 1 \\geq \\beta\\) or \\(\\alpha \\leq 1 &lt; \\beta\\), we get bias toward values nearer to \\(1\\) or \\(0\\), respectively. We say that these distributions are sparse (in contrast to dense), but like the other beta distributions we’ve seen–besides \\(\\text{Beta}(1, 1)\\)–they are unimodal.\n\nsparse_unimodal_beta_params = [\n    (5, 1),\n    (1, 5)\n]\n\n\n\nCode\nax = subplot()\n\nfor a, b in sparse_unimodal_beta_params:\n    ax.plot(\n        mgrid[0:1:0.01], \n        beta(a, b).pdf(mgrid[0:1:0.01]),\n        label=f\"Beta({a}, {b})\"\n    )\n\nax.legend()\nax.set_title(r\"PDF of sparse unimodal Beta\")\n_ = ax.set_ylabel(\"Density\")\n\n\n\n\n\nWhen \\(\\alpha, \\beta &lt; 1\\), we get a bias toward values near both \\(0\\) and \\(1\\) with more density shifted toward \\(1\\) if \\(\\alpha\\) is larger and more density shifted toward \\(0\\) if \\(\\beta\\) is larger. These distributions are sparse and bimodal.\n\nsparse_bimodal_beta_params = [\n    (0.5, 0.5),\n    (0.6, 0.4),\n    (0.4, 0.6),\n]\n\n\n\nCode\nax = subplot()\n\nfor a, b in sparse_bimodal_beta_params:\n    ax.plot(\n        mgrid[0:1:0.01], \n        beta(a, b).pdf(mgrid[0:1:0.01]),\n        label=f\"Beta({a}, {b})\"\n    )\n\nax.legend()\nax.set_title(r\"PDF of sparse bimodal Beta\")\n_ = ax.set_ylabel(\"Density\")\n\n\n\n\n\n\n\nUnivariate Gaussian distribution\nOne continuous distribution we will work with extensively is the Gaussian or normal distribution.\n\\[\\mathcal{N}(x; \\mu, \\sigma^2) = \\frac{1}{\\sigma\\sqrt{2\\pi}}\\exp\\left(-\\frac{(x-\\mu)^2}{2\\sigma^2}\\right)\\]\nwhere \\(\\mu\\) is referred to as the mean and \\(\\sigma^2\\) as the variance.\n\nfrom scipy.stats import norm\n\n\n\nCode\nax = subplot()\n\nax.plot(mgrid[-3:3:0.01], norm(0, 1).pdf(mgrid[-3:3:0.01]))\n\nax.set_title(r\"PDF of $\\mathcal{N}(0, 1)$\")\n_ = ax.set_ylabel(\"Density\")\n\n\n\n\n\nThe mean controls the position and the variance controls the width–specifically, the wideness.\n\nnormal_params = [\n    (0, 1),\n    (1, 1),\n    (0, 2)\n]\n\n\n\nCode\nax = subplot()\n\nfor a, b in normal_params:\n    ax.plot(\n        mgrid[-3:3:0.01], \n        norm(a, b).pdf(mgrid[-3:3:0.01]),\n        label=r\"$\\mathcal{N}(\"+str(a)+\", \"+str(b)+\")$\"\n    )\n\nax.legend()\nax.set_title(r\"PDF of Guassian\")\n_ = ax.set_ylabel(\"Density\")\n\n\n\n\n\nWe say that the distribution is standard normal if the mean \\(\\mu = 0\\) and the variance \\(\\sigma^2 = 1\\).\nAs with all continuous distributions, we can compute the cumulative distribution function as:\n\\[\\Phi(x) = \\int_{-\\infty}^x \\mathcal{N}(y; \\mu, \\sigma^2)\\,\\mathrm{d}y\\]\nwhere \\(\\Phi\\) is a common notation for \\(F_X\\), when \\(X\\) is a Gaussian random variable.\n\n\nCode\nax = subplot()\n\nax.plot(mgrid[-3:3:0.01], norm(0, 1).cdf(mgrid[-3:3:0.01]))\n\nax.set_title(r\"CDF of $\\mathcal{N}(0, 1)$\")\n_ = ax.set_ylabel(\"Probability\")\n\n\n\n\n\n\\(\\Phi\\) is often referred to as sigmoidal or a sigmoid for its S shape. These sorts of functions will be very important moving forward–most proximally because they play a role in modeling judgments provided through instruments like Likert (1-7) scales and slider scales.\nThe Gaussian CDF is only one of many continuous CDFs with this shape. The beta CDF is also sigmoidal when \\(\\alpha, \\beta \\neq 1\\).\n\n\nCode\nax = subplot()\n\nax.plot(mgrid[0:1:0.01], beta(5, 5).cdf(mgrid[0:1:0.01]))\n\nax.set_title(r\"CDF of Beta(5, 5)\")\n_ = ax.set_ylabel(\"Probability\")"
  },
  {
    "objectID": "foundational-concepts-in-probability-and-statistics/random-variables-and-probability-distributions.html#some-more-useful-definitions",
    "href": "foundational-concepts-in-probability-and-statistics/random-variables-and-probability-distributions.html#some-more-useful-definitions",
    "title": "Random variables and probability distributions",
    "section": "Some more useful definitions",
    "text": "Some more useful definitions\nSince random variables are required to preserve the structure of the event space, the definitions of joint probability, conditional probability, and independence can all be extended to them. The introduction of random variables and probability distributions also allows us to define a notion of expected value.\n\nJoint probability\nDefining the joint probability of random variables \\(X\\) and \\(Y\\) with underlying probabiliy spaces \\(\\langle \\Omega_X, \\mathcal{F}_X, \\mathbb{P}_X \\rangle\\) and \\(\\langle \\Omega_Y, \\mathcal{F}_Y, \\mathbb{P}_Y \\rangle\\) requires us to define a new probability space \\(\\langle \\Omega_X \\times \\Omega_Y, \\mathcal{F}_{X, Y}, \\mathbb{P}_{X, Y} \\rangle\\), where \\(\\mathcal{F}_{X, Y}\\) is the product \\(\\sigma\\)-algebra \\(\\sigma\\left(\\left\\{E_X \\times E_Y \\mid E_X \\in \\mathcal{F}_X, E_Y \\in \\mathcal{F}_Y\\right\\}\\right)\\) on \\(\\Omega_X \\times \\Omega_Y\\). We then define the joint distribution \\(p_{X, Y}\\) in terms of \\(X'(\\omega_X, \\omega_Y) = X(\\omega_X)\\) and \\(Y'(\\omega_X, \\omega_Y) = Y(\\omega_Y)\\):\n\\[\\begin{align*}p_{X, Y}(x, y) &= \\mathbb{P}_{X, Y}(X' = x, Y' = y)\\\\ &= \\mathbb{P}_{X, Y}\\left(\\{\\langle\\omega_X, \\omega_Y\\rangle \\mid X'(\\langle\\omega_X, \\omega_Y\\rangle) = x\\}, \\{\\langle\\omega_X, \\omega_Y\\rangle \\mid Y'(\\langle\\omega_X, \\omega_Y\\rangle) = y\\}\\right)\\\\ &= \\mathbb{P}_{X, Y}\\left(\\{\\langle\\omega_X, \\omega_Y\\rangle \\mid X'(\\langle\\omega_X, \\omega_Y\\rangle) = x\\} \\cap \\{\\langle\\omega_X, \\omega_Y\\rangle \\mid Y'(\\langle\\omega_X, \\omega_Y\\rangle) = y\\}\\right)\\\\ &= \\mathbb{P}_{X, Y}\\left(\\{\\langle\\omega_X, \\omega_Y\\rangle \\mid X'(\\langle\\omega_X, \\omega_Y\\rangle) = x \\land Y'(\\langle\\omega_X, \\omega_Y\\rangle) = y\\}\\right)\\\\ &= \\mathbb{P}_{X, Y}\\left(\\{\\langle\\omega_X, \\omega_Y\\rangle \\mid X(\\omega_X) = x \\land Y'(\\omega_Y) = y\\}\\right)\\end{align*}\\]\nwhere \\(p_{X, Y}\\) (and thus \\(\\mathbb{P}_{X, Y}\\)) must be such that the marginal distributions \\(p_X\\) and \\(p_Y\\) satisfy:\n\\[p_X(x) = \\begin{cases}\\sum_{y \\in Y(\\Omega_Y)} p_{X, Y}(x, y) & \\text{if $Y$ is discrete} \\\\ \\int_{Y(\\Omega_Y)} p_{X, Y}(x, y)\\,\\mathrm{d}y & \\text{if $Y$ is continuous} \\\\ \\end{cases}\\]\n\\[p_Y(y) = \\begin{cases}\\sum_{x \\in X(\\Omega_X)} p_{X, Y}(x, y) & \\text{if $X$ is discrete} \\\\ \\int_{X(\\Omega_X)} p_{X, Y}(x, y)\\,\\mathrm{d}x & \\text{if $X$ is continuous} \\\\ \\end{cases}\\]\nI’ll sometimes simply write \\(p(x, y)\\) (with \\(x\\) and \\(y\\) values of implicit random variables) instead of \\(p_{X, Y}(x, y)\\). I’ll often use \\(p\\) here, even when both \\(X\\) and \\(Y\\) are continuous. I’ll also often drop all but the variable of summation/integration from the sum or integral over the range of a random variable. So I’ll write things like…\n\\[p(x) = \\begin{cases}\\sum_{y} p(x, y) & \\text{if $Y$ is discrete} \\\\ \\int p(x, y)\\,\\mathrm{d}y & \\text{if $Y$ is continuous} \\\\ \\end{cases}\\]\n…rather than…\n\\[p_X(x) = \\begin{cases}\\sum_{y \\in Y(\\Omega_Y)} p_{X, Y}(x, y) & \\text{if $Y$ is discrete} \\\\ \\int_{Y(\\Omega_Y)} p_{X, Y}(x, y)\\,\\mathrm{d}y & \\text{if $Y$ is continuous} \\\\ \\end{cases}\\]\nJust remember that \\(p_{X, Y}\\) is a different function from \\(p_X\\) or \\(p_Y\\)–even when I write \\(p(x, y)\\), \\(p(x)\\), or \\(p(y)\\), rather than the more verbose \\(p_{X, Y}(x, y)\\), \\(p_X(x)\\), or \\(p_Y(y)\\).\n\n\nConditional probability\nThe conditional probability of a random variable \\(X\\) given a random variable \\(Y\\) is defined in terms of their joint probability and the marginal probability of \\(Y\\):\n\\[p_{X \\mid Y}(x \\mid y) \\equiv \\frac{p_{X, Y}(x, y)}{p_{Y}(y)} = \\begin{cases}\\frac{p_{X, Y}(x, y)}{\\sum_{x'} p_{X, Y}(x', y)} & \\text{if $X$ is discrete} \\\\ \\frac{p_{X, Y}(x, y)}{\\int p_{X, Y}(x', y)\\,\\mathrm{d}x'} & \\text{if $X$ is continuous} \\\\ \\end{cases}\\]\n\n\nIndependence\nWe can extend the definition of independent events to that of independent random variables by saying that two random variables \\(X\\) and \\(Y\\) are independent if and only if:\n\\[p_{X \\mid Y}(x \\mid y) = p_X(x)\\] \\[p_{Y \\mid X}(y \\mid x) = p_Y(y)\\]\nBy the same reasoning as for independent events, this in turn implies that:\n\\[p_{X, Y}(x, y) = p_X(x)p_Y(y)\\]\nWe say that two random variables \\(X\\) and \\(Y\\) are conditionally independent given another \\(Z\\) if and only if:\n\\[p_{X \\mid Y, Z}(x \\mid y, z) = p_{X \\mid Z}(x \\mid z)\\] \\[p_{Y \\mid X, Z}(y \\mid x, z) = p_{Y \\mid Z}(y \\mid z)\\]\nAs before, this implies that:\n\\[p_{X, Y \\mid Z}(x, y \\mid z) = p_{X \\mid Z}(x \\mid z)p_{Y \\mid Z}(y \\mid z)\\]\nNote that being conditionally independent is not the same as being independent.\n\n\nExpected values\nThe expected value \\(\\mathbb{E}[X]\\) of a random variable \\(X\\) can be thought of as a kind of weighted average over the values of that variable. When the variable is discrete, this average is computed using a sum.\n\\[\\mathbb{E}[X] \\equiv \\sum_{x} x \\cdot p_X(x)\\]\nWhen the variable is continuous, this average is computed using an integral.\n\\[\\mathbb{E}[X] \\equiv \\int x \\cdot f_X(x) \\, \\mathrm{d}x\\]\nThe expected value of a random variable \\(X\\) is often referred to as the mean of \\(X\\). Given a PMF or PDF of a probability distribution, we can often (though not always) compute the mean analytically in terms of the distribution’s parameters. For instance, the mean of a random variable \\(X \\sim \\text{Geom}(\\pi)\\) is:\n\\[\\mathbb{E}[X] = \\sum_{k=0}^\\infty k \\cdot (1-\\pi)^k\\pi = \\frac{1-\\pi}{\\pi}\\]\nAnd the mean of a random variable \\(X \\sim \\text{Beta}(\\alpha, \\beta)\\) is:\n\\[\\mathbb{E}[X] = \\int_0^1 x \\cdot \\frac{x^{\\alpha - 1}(1-x)^{\\beta-1}}{\\text{B}(\\alpha, \\beta)} \\, \\mathrm{d}x = \\frac{\\alpha}{\\alpha + \\beta}\\]\nThe mean of a Cauchy-distributed random variable \\(X \\sim \\text{Cauchy}(x_0, \\gamma)\\) is one instance of a random variable where \\(\\mathbb{E}[X]\\) is not defined. This fact is not immediately obvious from its PDF.\n\\[\\text{Cauchy}(x; x_{0},\\gamma )={\\frac {1}{\\pi \\gamma \\left[1+\\left({\\frac {x-x_{0}}{\\gamma }}\\right)^{2}\\right]}}\\]\n\nfrom scipy.stats import cauchy\n\n_ = plt.plot(mgrid[-3:3:0.01], cauchy(0, 1).pdf(mgrid[-3:3:0.01]))\n\nThe moral is to be careful in assuming that the expected value is always defined.\n\nExpected value of a function of a random variable\nWe’ll often have cause to take the expected value of some function \\(g(X) \\equiv g \\circ X\\) of a random variable, which we define as:\n\\[\\mathbb{E}\\left[g(X)\\right] \\equiv \\begin{cases}\\sum_{x} g(x) \\cdot p(x) & \\text{if $X$ is discrete} \\\\ \\int g(x) \\cdot f(x) \\, \\mathrm{d}x & \\text{if $X$ is continuous} \\\\ \\end{cases}\\]\nFor simple affine functions, it is straightforward to prove that \\(\\mathbb{E}\\left[aX + b\\right] = a\\mathbb{E}\\left[X\\right] + b\\). But it’s important to note that \\(\\mathbb{E}\\left[g(X)\\right] \\neq g\\left(\\mathbb{E}\\left[X\\right]\\right)\\) in general.7\n\n\nCentral moments\nOne function of a random variable we’ll use frequently is \\(\\left(X - \\mathbb{E}[X]\\right)^k\\), which gives us the concept of a central moment:\n\\[\\mathbb{E}\\left[\\left(X - \\mathbb{E}[X]\\right)^k\\right] = \\begin{cases}\\sum_{x \\in X(\\Omega)} \\left(x - \\mathbb{E}[X]\\right)^k \\cdot p_X(x) & \\text{if $X$ is discrete} \\\\ \\int_{X(\\Omega)} \\left(x - \\mathbb{E}[X]\\right)^k \\cdot f_X(x) \\, \\mathrm{d}x & \\text{if $X$ is continuous} \\\\ \\end{cases}\\]\nThe second central moment \\(\\mathbb{E}\\left[\\left(X - \\mathbb{E}[X]\\right)^2\\right]\\) is known as the variance \\(\\mathbb{V}\\left[X\\right]\\) or \\(\\text{Var}[X]\\), which is a common measure of dispersion. Another common measure of dispersion, the standard deviation, is simply \\(\\sqrt{\\mathbb{V}[X]}\\).\nLike the expected value/mean, the variance of a particular distribution can often be computed analytically in terms of the distribution’s parameters. For instance, the variance of a random variable \\(X \\sim \\text{Geom}(\\pi)\\) is:\n\\[\\mathbb{V}[X] \\equiv \\sum_{k=0}^\\infty (k - \\mathbb{E}[X])^2 \\cdot (1-\\pi)^k\\pi\\]\nIf \\(X \\sim \\mathcal{N}(\\mu, \\sigma^2)\\) , then \\(\\mathbb{E}[X] = \\mu\\) and \\(\\mathbb{V}[X] = \\sigma^2\\), hence the names mean and variance for those parameters.\n\n\nCovariance and correlation\nIt is often useful to know how two random variables \\(X\\) and \\(Y\\) “move together” or covary. We can measure this covariance by extending variance \\(\\mathbb{V}[X]\\), which is a property of a single random variable, to covariance, which is a property of pairs of random variables with a joint distribution \\(p_{X, Y}\\). Assuming both \\(X\\) and \\(Y\\) are continuous and real-valued:\n\\[\\begin{align*}\\text{cov}(X, Y) &= \\mathbb{E}[(X - \\mathbb{E}[X])(Y - \\mathbb{E}[Y])]\\\\ &= \\int_{\\mathbb{R}^2} (x - \\mathbb{E}[X]) \\cdot (y - \\mathbb{E}[Y]) \\cdot p(x, y) \\, \\mathrm{d}\\langle x, y \\rangle \\\\ &= \\int_{\\mathbb{R}} \\left[\\int_{\\mathbb{R}} (x - \\mathbb{E}[X]) \\cdot (y - \\mathbb{E}[Y]) \\cdot p(x, y) \\, \\mathrm{d}x\\right]\\, \\mathrm{d}y\\end{align*}\\]\nIf either are discrete, we just replace the integral over that variable with a sum.\nThe covariance of a random variable with itself is just the variance:\n\\[\\text{cov}(X, X) \\equiv \\mathbb{E}[(X - \\mathbb{E}[X])(X - \\mathbb{E}[X])] = \\mathbb{V}[X]\\]\nThe covariance has units corresponding to whatever the units of \\(X\\) and \\(Y\\) are: for instance, if both were formant values, the units would be frequency. The (Pearson) correlation normalizes these units away to a quantity in \\([-1, 1]\\), which can be useful if the variables have different units whose product is not itself interpretable.\n\\[\\text{corr}(X, Y) \\equiv \\frac{\\text{cov}(X, Y)}{\\sqrt{\\mathbb{V}[X]}\\sqrt{\\mathbb{V}[Y]}}\\]\nThis quantity is guaranteed to be between \\([-1, 1]\\) due to an application of the Cauchy-Schwarz inequality:\n\\[\\text{cov}(X, Y)^2 \\leq \\mathbb{V}[X] \\cdot \\mathbb{V}[Y]\\]\n\n\nConditional expectation\nIn certain cases, we need the expected value of one random variable \\(X\\) conditioned on another random variable \\(Y\\): \\(\\mathbb{E}[X \\mid Y]\\). In the case where we known the value of \\(Y\\) (or want to assume we do):\n\\[\\mathbb{E}[X \\mid Y = y] = \\begin{cases}\\sum_x x \\cdot p(x \\mid y) & \\text{if } X \\text{ is discrete} \\\\ \\int x \\cdot p(x \\mid y) \\, \\mathrm{d}x & \\text{if } X \\text{ is continuous}\\end{cases}\\]\nThus, we could think of \\(\\mathbb{E}[X \\mid Y = y]\\) as a function \\(g: \\mathrm{cod}(Y) \\rightarrow \\mathrm{cod}(X)\\).\nAlternatively, we can think of \\(\\mathbb{E}[X \\mid Y]\\) as a random variable \\(g(Y) = g \\circ Y: \\mathrm{dom}(Y) \\rightarrow \\mathrm{cod}(X)\\), where \\(\\mathrm{dom}(Y)\\) is the sample space of the probability space underlying \\(Y\\)."
  },
  {
    "objectID": "foundational-concepts-in-probability-and-statistics/random-variables-and-probability-distributions.html#footnotes",
    "href": "foundational-concepts-in-probability-and-statistics/random-variables-and-probability-distributions.html#footnotes",
    "title": "Random variables and probability distributions",
    "section": "Footnotes",
    "text": "Footnotes\n\n\nThe event space for \\(\\Omega = \\mathbb{R}_+^2\\) is analogous to the Borel \\(\\sigma\\)-algebra for \\(\\mathbb{R}\\). Basically, it contains all pairs of real intervals. The technical details aren’t really going to be important for our purposes beyond knowing that \\(\\mathbb{R}_+^2\\) is going to act like \\(\\mathbb{R}\\) in the ways we care about.↩︎\nIt is common to talk about the categorical distribution, when we really mean the family of categorical distributions.↩︎\nThe parameterization below is derived from the relative frequencies for each pronoun extracted from the Universal Dependencies English Web TreeBank here.↩︎\nThis semicolon notation–in contrast to the pipe notation–will become important shortly.↩︎\nThis assumes that strings cannot have zero length, meaning that \\(\\Omega = \\Sigma^+\\) rather than \\(\\Sigma^*\\); if we want to allow zero-length strings \\(\\epsilon\\), we would need \\(p_X(k) = \\frac{1}{2^{k+1}}\\).↩︎\nYou’ll need to take my word on this point if you haven’t proved it before.↩︎\nIf \\(g\\) is convex, however, \\(\\mathbb{E}\\left[g(X)\\right] \\geq g\\left(\\mathbb{E}\\left[X\\right]\\right)\\) by Jensen’s inequality.↩︎"
  },
  {
    "objectID": "foundational-concepts-in-probability-and-statistics/statistical-inference.html",
    "href": "foundational-concepts-in-probability-and-statistics/statistical-inference.html",
    "title": "Statistical Inference",
    "section": "",
    "text": "The concepts we’ve discussed so far provide us a space of possible descriptions of the world coming from probability theory, but they do not give us a way of grounding that description, thereby imbuing it with content. This is the role of statistics in general and statistical inference in particular. A good bit of this course will cover different forms of statistical inference. In this section, my aim is to give you a taste of two of the major forms of statistical inference we’ll use throughout the course in increasing more complex forms: frequentist inference and Bayesian inference. Unless you have explicitly been introduced to Bayesian inference, frequentist inference is probably the form you are most familiar with through the use of constructs like \\(p\\)-values and confidence intervals.\nThe overall goal of statistical inference is to find a good description of (some property of) a population in terms of probability distributions. The notion of population is very abstract; it could be basically any of the things we might be interested in defining a probability model for: formant values, vowels, well-formed strings of phonemes, morphemes, words, etc. We will generally start out with some assumptions about the family of distributions that might best describe the population and then on the basis of data sampled from the population attempt to determine which distribution in the family is the best description."
  },
  {
    "objectID": "foundational-concepts-in-probability-and-statistics/statistical-inference.html#running-example-pronoun-case",
    "href": "foundational-concepts-in-probability-and-statistics/statistical-inference.html#running-example-pronoun-case",
    "title": "Statistical Inference",
    "section": "Running example: pronoun case",
    "text": "Running example: pronoun case\nAs a running example, I’ll consider a case where \\(X_i\\) maps a pronoun token \\(i\\) to an indicator of whether it is accusative or not–i.e. the Bernoulli random variable we discussed here.\n\npronouns = frozenset({\n    \"i\", \"me\", \n    \"you\", \n    \"they\", \"them\", \n    \"it\", \n    \"she\", \"her\", \n    \"he\", \"him\", \n    \"we\", \"us\",\n})\n\npronouns_acc = frozenset({\"me\", \"you\", \"them\", \"her\", \"him\", \"it\", \"us\"})\npronouns_nonacc = frozenset({\"i\", \"you\", \"they\", \"she\", \"he\", \"it\", \"we\"})\n\nFor data, we’ll use the Universal Dependencies English Web Treebank.1 I’ll use this data throughout, often without comment.\n\nfrom urllib.request import urlopen\nfrom collections import Counter\nfrom numpy import array\n\ndata = []\n\ncase_pronoun = {\n    \"[+acc]\": [],\n    \"[-acc]\": []\n}\n\npronoun_count = Counter()\n\nud_ewt_url = \"https://raw.githubusercontent.com/UniversalDependencies/UD_English-EWT/master/en_ewt-ud-train.conllu\"\n\nwith urlopen(ud_ewt_url) as ud_ewt_url:\n    for i, l in enumerate(ud_ewt_url):\n        l = l.decode()\n        \n        if l[0] != \"#\" and l.strip():\n            l = l.split()\n            word = l[1].lower()\n            \n            if word not in pronouns:\n                continue\n            \n            if word in pronouns_acc - pronouns_nonacc:\n                data.append(1)\n                case_pronoun[\"[+acc]\"].append(word)\n                pronoun_count[word] += 1\n            elif word in pronouns_nonacc - pronouns_acc:\n                data.append(0)\n                case_pronoun[\"[-acc]\"].append(word)\n                pronoun_count[word] += 1\n            elif l[7] == \"nsubj\":\n                data.append(0)\n                case_pronoun[\"[-acc]\"].append(word)\n                pronoun_count[word+\"_[-acc]\"] += 1\n            else:\n                data.append(1)\n                case_pronoun[\"[+acc]\"].append(word)\n                pronoun_count[word+\"_[+acc]\"] += 1\n                \ndata = array(data)\n\nI’ll assume that \\(X_i\\) is independent of \\(X_j\\) for all \\(i \\neq j\\). In this case, we say that the collection of random variables \\(\\{X_1, X_2, \\ldots\\}\\) is independent and identically distributed (iid), which I will denote by.\n\\[X_i \\sim \\text{Bern}(\\pi)\\]\nHere, our description of our population is \\(\\text{Bern}(\\pi)\\) and \\(X_i\\) is a random variable corresponding to the \\(i^{th}\\) sample we’ve taken from the population.\nOne thing we might be interested in inferring is what the value of \\(\\pi\\) is. We’ll discuss two broad families of approaches to doing this: frequentist inference and Bayesian inference."
  },
  {
    "objectID": "foundational-concepts-in-probability-and-statistics/statistical-inference.html#frequentist-inference",
    "href": "foundational-concepts-in-probability-and-statistics/statistical-inference.html#frequentist-inference",
    "title": "Statistical Inference",
    "section": "Frequentist inference",
    "text": "Frequentist inference\nIn frequentist inference, we assume that \\(\\pi\\) is a fixed value–some aspect of the world we are attempting to discover (or at least approximate). One popular way to attempt to approximate (or estimate) this value is through use of the likelihood function \\(\\mathcal{L}_\\mathbf{x}(\\pi) = p_{X_1, X_2, \\ldots, X_N}(\\mathbf{x} = x_1, x_2, \\ldots, x_N; \\pi)\\).2 One common way to use the likelihood function in this way is maximum likelihood estimation (MLE). In MLE, we derive an estimate \\(\\hat\\pi\\) by…maximizing the likelihood.\n\\[\\begin{align*}\\hat\\pi &= \\arg_\\pi\\max\\mathcal{L}_\\mathbf{x}(\\pi)\\\\ &= \\arg_\\pi\\max p_{X_1, X_2, \\ldots, X_N}(\\mathbf{x}; \\pi)\\end{align*}\\]\nBecause \\(X_1, X_2, \\ldots, X_N\\) are iid by assumption (whether we observe an accusative on the \\(i^{th}\\) observation doesn’t depend on whether we observed it on any other), we can express this quantity as:\n\\[\\begin{align*}\\hat\\pi &= \\arg_\\pi\\max p_{X_1, X_2, \\ldots}(\\mathbf{x}; \\pi)\\\\ &= \\arg_\\pi\\max \\prod_{i=1}^N p_{X_i}(x_i; \\pi)\\\\ &= \\arg_\\pi\\max \\prod_{i=1}^N \\text{Bern}(x_i; \\pi)\\\\ &= \\arg_\\pi\\max \\prod_{i=1}^N \\pi^{x_i}(1-\\pi)^{1-x_i}\\\\\\end{align*}\\]\nTo make this form easier to work with, we will often maximize the log of the likelihood rather than the likelihood directly. (Equivalently, we will sometimes minimize the negative of the log-likelihood.) Taking the logarithm gives us the same result for the argmax, since logarithms are monotone increasing.\n\\[\\begin{align*}\\hat\\pi &= \\arg_\\pi\\max \\mathcal{L}_\\mathbf{x}(\\pi)\\\\ &= \\arg_\\pi\\max\\log\\mathcal{L}_\\mathbf{x}(\\pi) \\\\ &= \\arg_\\pi\\max \\log\\prod_{i=1}^N \\pi^{x_i}(1-\\pi)^{1-x_i}\\\\ &= \\arg_\\pi\\max \\sum_{i=1}^N \\log\\left( \\pi^{x_i}(1-\\pi)^{1-x_i}\\right)\\\\ &= \\arg_\\pi\\max \\sum_{i=1}^N x_i \\log \\pi + (1-x_i)\\log(1-\\pi)\\\\\\end{align*}\\]\nOne reason to express the maximization in terms of the log-likelihood, rather than the likelihood, is that it allows us to exchange a product for a sum. This sum makes it easier to compute the derivative, which we will use to maximize \\(\\pi\\)….\n\\[\\begin{align*}\\frac{\\mathrm{d}}{\\mathrm{d}\\pi}\\log\\mathcal{L}_\\mathbf{x}(\\pi) &= \\frac{\\mathrm{d}}{\\mathrm{d}\\pi}\\sum_{i=1}^N x_i \\log \\pi + (1-x_i)\\log(1-\\pi)\\\\ &= \\sum_{i=1}^N \\frac{\\mathrm{d}}{\\mathrm{d}\\pi} x_i \\log \\pi + (1-x_i)\\log(1-\\pi)\\\\ &= \\sum_{i=1}^N \\frac{x_i -\\pi}{p(1-\\pi)}\\\\ &= \\sum_{i=1}^N \\frac{x_i}{\\pi(1-\\pi)} - \\frac{1}{1-\\pi}\\\\ &= \\left[\\frac{1}{\\pi(1-\\pi)}\\sum_{i=1}^N x_i\\right] - \\frac{N}{1-\\pi}\\end{align*}\\]\n…by setting it to zero.\n\\[\\begin{align*}\\left[\\frac{1}{\\hat\\pi(1-\\hat\\pi)}\\sum_{i=1}^N x_i\\right] - \\frac{N}{1-\\hat\\pi} &= 0 \\\\ \\frac{1}{\\hat\\pi(1-\\hat\\pi)}\\sum_{i=1}^N x_i &= \\frac{N}{1-\\hat\\pi} \\\\ \\sum_{i=1}^N x_i &= N\\hat\\pi \\\\ \\frac{\\sum_{i=1}^N x_i}{N} &= \\hat\\pi \\\\ \\end{align*}\\]\nThus, the maximum likelihood estimate \\(\\hat\\pi\\) for a particular set of samples \\(x_1, x_2, \\ldots, x_N\\) is simply the sample mean for \\(X_1, X_2, \\ldots, X_N\\): \\(\\frac{\\sum_{i=1}^N x_i}{N}\\) (the number of accusative pronouns we observed over the number of pronouns we observed in total). View as a function of \\(\\mathbf{x}\\), we call \\(\\hat\\pi(\\mathbf{x}) = \\frac{\\sum_{i=1}^N x_i}{N}\\) the maximum likelihood estimator for the Bernoulli parameter (the estimand) \\(\\pi\\).\n\nfrom numpy import mean\n\npi_hat = data.mean()\n\npi_hat\n\n0.2709504031272905\n\n\nViewed as a function of some fixed quantity \\(\\hat\\pi(\\mathbf{x})\\) is to the conditional expectation \\(\\mathbb{E}[X \\mid Y = y]\\), which we viewed as a function of the value \\(y\\) of the random variable \\(Y\\). Here, we would consider \\(\\arg_\\pi\\max\\mathcal{L}_\\mathbf{x}(\\pi)\\) as a function of the values \\(x_1, x_2, \\ldots, x_N\\) of the random variables \\(X_1, X_2, \\ldots, X_N\\).\nBut similar to our discussion of conditional expectations, we will often talk about the estimator itself as a random variable that is a function of some other set of random variables \\(X_1, X_2, \\ldots, X_N\\). The view of \\(\\hat\\pi(\\mathbf{X})\\) as a random variable in turn allows us to talk about the distribution of \\(\\hat\\pi(\\mathbf{X})\\) as well as the distributions of functions on that random variable.\nIn the case of \\(X_i \\sim \\text{Bern}(\\pi)\\), \\(N\\hat\\pi(X_1, X_2, \\ldots, X_N) \\sim \\text{Binomial}(N, \\pi)\\):\n\\[p_{N\\hat\\pi(X_1, X_2, \\ldots, X_N)}(k) = {N \\choose k}\\pi^{k}(1-\\pi)^{N-k}\\]\nYou can get a sense for why this is by noting that any particular assignment \\(X_1 = x_1, X_2 = x_2, \\ldots, X_N = x_N\\) has a probability \\(p(x_1, x_2, \\ldots, x_N) = \\prod_{i=1}^N \\pi^{x_i}(1-\\pi)^{(1-x_i)} = \\pi^{\\sum_{i=1}^N x_i}(1-\\pi)^{\\sum_{i=1}^N (1-x_i)}\\) but that many other configurations will average to the same thing as \\(x_1, x_2, \\ldots, x_N\\) because they sum to the same thing as \\(x_1, x_2, \\ldots, x_N\\). The number of such configurations is given by the binomial coefficient \\({N \\choose k} = \\frac {n!}{k!(n-k)!}\\), which tells you the number of ways of selecting \\(x_i = 1\\) such that the sum is \\(k\\).\nWe can alternatively see that the estimator has this distribution by simulation. With smaller number of samples, the estimator will have higher variance.\n\nfrom numpy import mgrid\nfrom scipy.stats import bernoulli\nfrom statsmodels.distributions.empirical_distribution import ECDF\nfrom matplotlib.pyplot import subplot\n\ndef sample_bernoulli_sample_mean(p: float, n: int) -&gt; float:\n  return mean(bernoulli(p).rvs(n))\n\nn = 10\np = pi_hat\n\nsamples = [sample_bernoulli_sample_mean(p, n) for _ in range(1000)]\necdf = ECDF(samples)\n\n\n\nPlotting code\nfrom numpy import round\nfrom scipy.stats import binom\n\nax = subplot()\nax.plot(mgrid[0:n:0.1]/n, ecdf(mgrid[0:n:0.1]/n), label=\"Empirical CDF of simulated estimator\")\nax.plot(mgrid[0:n:0.1]/n, binom(n, p).cdf(mgrid[0:n:0.1]), label=\"Theoretical CDF of estimator\")\n\nax.legend()\nax.set_title(r\"CDF for estimator $\\hat{\\pi}(\\mathbf{X})$ of $\\pi = \"+ str(round(pi_hat, 2)) + \"$ when $N=10$\")\nax.set_xlabel(r\"$\\hat{\\pi}(\\mathbf{X})$\")\n_ = ax.set_ylabel(\"Probability\")\n\n\n\n\n\nWith larger numbers of samples–e.g. the number of datapoints we have (12,279)–it will have much lower variance.\n\nn = len(data)\np = pi_hat\n\nsamples = [sample_bernoulli_sample_mean(p, n) for _ in range(1000)]\necdf = ECDF(samples)\n\n\n\nPlotting code\nax = subplot()\nax.plot(mgrid[0:n:0.1]/n, ecdf(mgrid[0:n:0.1]/n), label=\"Empirical CDF of simulated estimator\")\nax.plot(mgrid[0:n:0.1]/n, binom(n, p).cdf(mgrid[0:n:0.1]), label=\"Theoretical CDF of estimator\")\n\nax.legend()\nax.set_title(r\"CDF for estimator $\\hat{\\pi}(\\mathbf{X})$ of $\\pi = \"+ str(round(pi_hat, 2)) + \"$ when $N=\"+ str(len(data)) +\"$\")\nax.set_xlabel(r\"$\\hat{\\pi}(\\mathbf{X})$\")\n_ = ax.set_ylabel(\"Probability\")\n\n\n\n\n\nOne such important distribution is that of the error.\n\\[e(\\hat\\pi(\\mathbf{X})) = \\hat\\pi(\\mathbf{X}) - \\pi\\]\nWe can describe this distribution as \\(N (\\pi + e(\\hat\\pi(\\mathbf{X}))) \\sim \\text{Binomial}(N, \\pi)\\).\n\ndef sample_bernoulli_sample_mean_error(p: float, n: int) -&gt; float:\n    return sample_bernoulli_sample_mean(p, n) - p\n\n\n\nPlotting code\nax = subplot()\n\nax.hist([sample_bernoulli_sample_mean_error(pi_hat, 10) for _ in range(1000)], bins=100, range=[-0.5, 0.5], density=True)\n\nax.set_title(r\"PDF of estimator error $e(\\hat{\\pi}(\\mathbf{X}))$ of $\\pi = \"+ str(round(pi_hat, 2)) + \"$ when $N=10$\")\nax.set_xlabel(r\"$e(\\hat{\\pi}(\\mathbf{X}))$\")\n_ = ax.set_ylabel(\"Density\")\n\n\n\n\n\n\n\nPlotting code\nax = subplot()\n\nax.hist([sample_bernoulli_sample_mean_error(pi_hat, len(data)) for _ in range(1000)], bins=1000, range=[-0.5, 0.5])\n\nax.set_title(r\"PDF of estimator error $e(\\hat{\\pi}(\\mathbf{X}))$ of $\\pi = \"+ str(round(pi_hat, 2)) + \"$ when $N=\"+ str(len(data)) +\"$\")\nax.set_xlabel(r\"$e(\\hat{\\pi}(\\mathbf{X}))$\")\n_ = ax.set_ylabel(\"Density\")\n\n\n\n\n\nIt also allows us to define two important quantities associated with the estimator: the bias, which is equivalent to the expected value of the error…\n\\[b(\\hat\\pi(\\mathbf{X})) = \\mathbb{E}[\\hat\\pi(\\mathbf{X})] - \\pi = \\mathbb{E}[\\hat\\pi(\\mathbf{X}) - \\pi]\\]\n…and the mean squared error (MSE).\n\\[\\text{MSE}(\\hat\\pi(\\mathbf{X})) = \\mathbb{E}\\left[(\\hat\\pi(\\mathbf{X}) - \\pi)^2\\right]\\]\nBoth are ways of quantifying how off we will tend to be in estimating the parameter of interest at a particular sample size. So for instance, for the maximum likelihood estimator we’ve been looking at:\n\\[\\text{b}(\\hat\\pi(\\mathbf{X})) = \\sum_{k=0}^N \\left(\\frac{k}{N} - \\pi\\right) \\cdot {N \\choose k}\\pi^k(1-\\pi)^{N-k}\\]\n\\[\\text{MSE}(\\hat\\pi(\\mathbf{X})) = \\sum_{k=0}^N \\left(\\frac{k}{N} - \\pi\\right)^2 \\cdot {N \\choose k}\\pi^k(1-\\pi)^{N-k}\\]\nThus, while the bias of this estimator is 0, the MSE starts relatively high and goes down as \\(N \\rightarrow \\infty\\), and it goes down faster the further from 0.5 \\(\\pi\\) is.\n\nfrom numpy import arange, sum\n\ndef bernoulli_mle_mse(n, p):\n  return sum((arange(n+1)/n - p)**2 * binom(n, p).pmf(arange(n+1)))\n\n\n\nPlotting code\nsample_sizes = arange(1, 20)\n\nax = subplot()\n\nax.plot(sample_sizes, [bernoulli_mle_mse(n, 0.5) for n in sample_sizes], label=r\"$\\pi = 0.5$\")\nax.plot(sample_sizes, [bernoulli_mle_mse(n, 0.75) for n in sample_sizes], label=r\"$\\pi = 0.25$\")\nax.plot(sample_sizes, [bernoulli_mle_mse(n, 0.9) for n in sample_sizes], label=r\"$\\pi = 0.1$\")\n\nax.legend()\n\nax.set_title(r\"MSE of estimator $\\hat{\\pi}(\\mathbf{X})$ at different sample sizes\")\nax.set_xlabel(r\"Sample size\")\n_ = ax.set_ylabel(\"MSE\")\n\n\n\n\n\nWe say that an estimator is unbiased if the bias of the estimator is \\(0\\); otherwise it’s biased. Therefore, the maximum likelihood estimator for the Bernoulli parameter is unbiased: it’s always \\(0\\), regardless of the sample size.\nBut maximum likelihood estimators for many other distributions are not. For instance, the maximum likelihood estimator \\(\\hat\\mu(\\mathbf{X})\\) for the mean \\(\\mu\\) of a univariate normal distribution is also the sample mean \\(\\hat\\mu(\\mathbf{x}) = \\frac{\\sum_{i=1}^N x_i}{N}\\), and this estimator is unbiased. In contrast, the maximum likelihood estimator \\(\\hat\\sigma^2(\\mathbf{X})\\) for the variance \\(\\sigma^2\\) is the sample variance \\(\\hat\\sigma^2(\\mathbf{x}) = \\frac{\\sum_{i=1}^N \\left(x_i - \\hat\\mu(\\mathbf{x})\\right)^2}{N}\\), but this estimator is biased: \\(b\\left(\\hat\\sigma^2(\\mathbf{X})\\right) = -\\frac{\\sigma^2}{N}\\). That is, in expectation, it underestimates the true variance by \\(-\\frac{\\sigma^2}{N}\\). (I won’t work through why this is, but you can find a proof here.) It’s for this reason that you’ll often see an alternative estimator of the variance used: \\(s^2(\\mathbf{X}) = \\frac{\\sum_{i=1}^N \\left(x_i - \\hat\\mu(\\mathbf{x})\\right)^2}{N-1}\\).\nIn general, we aren’t going to worry too much about bias (indeed, in some sense, we’re going to lean into biased estimators), but it is useful to know the above if you haven’t seen it before."
  },
  {
    "objectID": "foundational-concepts-in-probability-and-statistics/statistical-inference.html#bayesian-inference",
    "href": "foundational-concepts-in-probability-and-statistics/statistical-inference.html#bayesian-inference",
    "title": "Statistical Inference",
    "section": "Bayesian Inference",
    "text": "Bayesian Inference\nThe maximum likelihood estimate is what’s known as a point estimate because it’s a single number that gives the “best” estimate for the parameter given a way of estimating that parameter, such as MLE. But often we want to know how much uncertainty we should have about that estimate. For instance, if I compute the maximum likelihood estimate on the basis of only a single sample, that estimate, which will be either \\(0\\) or \\(1\\), will probably be terrible, even though, as we just discussed, the estimator is unbiased: it’s expected error is \\(0\\). The MSE gives us some indication of how much to trust the estimate (less with smaller sample sizes and more with larger sample sizes), but it doesn’t really tell us which other possible estimates might be reasonable values.\nBefore talking about how we deal with this issue in Bayesian inference, I first want to discuss one way that frequentist inference deals with uncertainty and that you might be familiar with: confidence intervals. The main reason I want to discuss confidence intervals is because they are tricky: their interpretation seems a lot clearer than it actually is.\n\nConfidence Intervals\nA confidence interval for some parameter \\(\\pi\\) at some confidence level \\(\\gamma \\in (0, 1)\\) is an interval \\((l(\\mathbf{X}), u(\\mathbf{X}))\\) whose bounds are determined by a pair of random variables \\(l(\\mathbf{X})\\) and \\(u(\\mathbf{X})\\). In being random variables, we can compute probabilities of events defined in terms of them. The probability that is relevant in constructing a confidence interval is \\(\\mathbb{P}\\left(l(\\mathbf{X}) &lt; \\theta &lt; u(\\mathbf{X})\\right)\\). To construct a confidence interval at level \\(\\gamma\\), we’re going to find the values of \\(l(\\mathbf{X})\\) and \\(u(\\mathbf{X})\\) such that \\(\\mathbb{P}\\left(l(\\mathbf{X}) &lt; \\theta &lt; u(\\mathbf{X})\\right) = \\gamma\\).\nOften, this interval needs to be approximated; and even in the case of the Bernoulli parameter, there are a variety of ways of doing this approximation. One way to do it is using the Clopper-Pearson method, which computes the interval as:\n\\[l(\\mathbf{x}) = \\inf \\left\\{\\theta \\,\\,{\\Big |}\\,\\,\\left[\\sum_{k=\\sum_{i=0}^N x_i}^N\\operatorname {Bin} \\left(k; N, \\theta \\right)\\right]&gt;{\\frac {1 - \\gamma }{2}}\\right\\}\\]\n\\[u(\\mathbf{x}) = \\sup\\left\\{\\theta \\,\\,{\\Big |}\\,\\,\\left[\\sum_{k=0}^{\\sum_{i=0}^N x_i}\\operatorname {Bin} \\left(k; N, \\theta \\right)\\right]&gt;{\\frac {1 - \\gamma }{2}}\\right\\}\\]\n\nfrom statsmodels.stats.proportion import proportion_confint\n\n\n\nEstimate CI with Clopper-Pearson\ncount_n_obs = [\n    (2, 10),\n    (20, 100),\n    (200, 1_000)\n]\n\nfor count, n_obs in count_n_obs:\n    ci = round(\n        proportion_confint(\n            count=count, nobs=n_obs, \n            method='beta'\n        ), 2\n    )\n\n    print(f\"successes = {count}\\tobservations = {n_obs}\\t95% CI={ci}\")\n\n\nsuccesses = 2   observations = 10   95% CI=[0.03 0.56]\nsuccesses = 20  observations = 100  95% CI=[0.13 0.29]\nsuccesses = 200 observations = 1000 95% CI=[0.18 0.23]\n\n\nAlternatively, we’ll very frequently compute confidence intervals via nonparametric bootstraps. In the simplest form of a nonparametric bootstrap, we take a dataset and resample it with replacement many times, thereby simulating the experiment on the basis of the distribution of samples. On each resampling, we compute the statistic of interest. Then, we compute the \\(\\frac{1-\\gamma}{2}\\) and \\(1-\\frac{1-\\gamma}{2}\\) quantiles of the collection of statistics–i.e. the values \\(l\\) and \\(u\\) such that \\(\\frac{1-\\gamma}{2}\\) of the statistics are less the \\(l\\) and \\(\\frac{1-\\gamma}{2}\\) are greater than \\(u\\).\n\nfrom typing import Tuple, Iterable\nfrom numpy import concatenate, zeros, ones, quantile\nfrom numpy.random import choice\n\ndef bootstrap_mean(\n    x: Iterable, gamma: float=0.95, \n    n_iter: int=10_000\n) -&gt; Tuple[float, Tuple[float, float]]:\n    \"\"\"Confidence interval of the mean using a non-parametric bootstrap\n    \n    Parameters\n    ----------\n    x\n        The data whose mean CI we want to bootstrap\n    gamma\n        The confidence level\n    n_iter\n        The number of bootstrap iterates\n        \n    Returns\n    -------\n    est\n        The estimate of the mean\n    ci\n        The confidence interval\n    \"\"\"\n    alpha = 1 - gamma\n\n    resampled = [choice(x, len(x)) for _ in range(n_iter)]\n    means = [mean(resamp) for resamp in resampled]\n\n    cilo, est, cihi = quantile(means, [alpha/2, 0.5, 1 - alpha/2])\n\n    return est, (cilo, cihi)\n\n\n\nEstimate CI with nonparametric bootstrap\nfor count, n_obs in count_n_obs:\n    samples = concatenate([ones(count), zeros(n_obs-count)])\n    est, ci = bootstrap_mean(samples)\n\n    print(f\"successes = {count}\\tobservations = {n_obs}\\testimate: {est}\\t95% CI={ci}\")\n\n\nsuccesses = 2   observations = 10   estimate: 0.2   95% CI=(0.0, 0.5)\nsuccesses = 20  observations = 100  estimate: 0.2   95% CI=(0.12, 0.28)\nsuccesses = 200 observations = 1000 estimate: 0.2   95% CI=(0.175, 0.225)\n\n\nWhy do I say the interpretation of these intervals is tricky? I say this because you might try to read \\(\\theta\\) in \\(\\mathbb{P}\\left(l(\\mathbf{X}) &lt; \\theta &lt; u(\\mathbf{X})\\right)\\) as a random variable, but it’s importantly not in this context: \\(\\theta\\) is some fixed value that we’re trying to estimate. So what this probability is telling us is how likely it is that the true, fixed value \\(\\theta\\) falls within the interval we construct when observing \\(\\mathbf{X}\\) many, many times. That is, the random variables here are those in \\(\\mathbf{X}\\), not \\(\\theta\\).\n\n\nPosterior Distributions\nThe way Bayesian inference deals with this issue is instead calculating something a bit more intuitive: the conditional distribution of the parameter \\(p(\\theta\\mid \\mathbf{x})\\). This approach is very different than the one we just saw because it requires us to view the parameter as (the value of) a random variable \\(\\Theta = \\theta\\). Generally, we don’t have a good idea what that conditional distribution looks like, but we may have some reasonable guesses about what \\(p(\\mathbf{x} \\mid \\theta)\\) and \\(p(\\theta)\\) look like. In this case, we will often invoke Bayes’ theorem to try to compute \\(p(\\theta\\mid \\mathbf{x})\\).\n\\[\\begin{align*}p(\\theta\\mid \\mathbf{x}) &= \\frac{p(\\mathbf{x} \\mid \\theta)p(\\theta)}{p(\\mathbf{x})} \\\\ &= \\begin{cases}\\frac{p(\\mathbf{x} \\mid \\theta)p(\\theta)}{\\sum_{\\theta'} p(\\mathbf{x}, \\theta')} & \\text{if } \\Theta \\text{ is discrete} \\\\ \\frac{p(\\mathbf{x} \\mid \\theta)p(\\theta)}{\\int p(\\mathbf{x}, \\theta')\\,\\mathrm{d}\\theta'} & \\text{if } \\Theta \\text{ is continuous} \\\\ \\end{cases}\\\\ &= \\begin{cases}\\frac{p(\\mathbf{x} \\mid \\theta)p(\\theta)}{\\sum_{\\theta'} p(\\mathbf{x} \\mid \\theta')p(\\theta')} & \\text{if } \\Theta \\text{ is discrete} \\\\ \\frac{p(\\mathbf{x} \\mid \\theta)p(\\theta)}{\\int p(\\mathbf{x} \\mid \\theta')p(\\theta')\\,\\mathrm{d}\\theta'} & \\text{if } \\Theta \\text{ is continuous} \\\\ \\end{cases}\\\\ \\end{align*} \\]\nIn this context, \\(p(\\theta\\mid \\mathbf{x})\\) is often termed the posterior (since it is the distribution of \\(\\Theta\\) after observing \\(\\mathbf{X}\\)), \\(p(\\theta)\\) is often termed the prior (since it is the distribution of \\(\\Theta\\) before observing \\(\\mathbf{X}\\)), and \\(p(\\mathbf{x})\\) is often termed the evidence. The name for \\(p(\\mathbf{x} \\mid \\theta)\\) is one we’ve seen before: the likelihood. This terminology is where the notation \\(\\mathcal{L}(\\theta \\mid \\mathbf{x})\\) I mentioned earlier comes from. In Bayesian inference, \\(\\mathcal{L}\\) is often defined as:\n\\[\\mathcal{L}(\\theta \\mid \\mathbf{x}) = p(\\mathbf{x} \\mid \\theta)\\]\nThis notation, which contrasts with the notation I used earlier–\\(\\mathcal{L}(\\theta \\mid \\mathbf{x}) = p(\\mathbf{x}; \\theta)\\)–is intended to emphasize that both \\(\\mathbf{X}\\) and \\(\\Theta\\) are viewed as random variables.\nBecause we generally assume a situation where the value of \\(\\mathbf{X} = \\mathbf{x}\\) is known (or at least observable in principle), so \\(p(\\mathbf{x})\\) (the evidence) is a constant: whatever the probability (or density) of the actual observation is. Indeed, it’s specifically a normalizing constant, since it doesn’t depend on \\(\\theta\\). So in a reasonable number of cases, we actually only care about the numerator (the product of the prior and the likelihood): we only care that \\(p(\\theta \\mid \\mathbf{x})\\) is proportional to \\(p(\\mathbf{x} \\mid \\theta)p(\\theta)\\).3 4\n\\[p(\\theta \\mid \\mathbf{x}) \\propto p(\\mathbf{x} \\mid \\theta)p(\\theta)\\]\n“Full” Bayesian inference will always use the posterior distribution in downstream inferences–as I discuss below. To simulate frequentist inference, however, we will sometimes derive point estimates from this distribution: often, a measure of the posterior’s central tendency (mean, median, or mode) and/or the \\((1-\\alpha)\\)% credible interval. The latter can be defined multiple ways. If the variable is univariate and continuous (which is often the case when computing credible intervals), one way is to define it as the interval \\((\\theta_\\text{min}, \\theta_\\text{max})\\) s.t. \\(\\mathbb{P}(\\theta &lt; \\theta_\\text{min} \\mid \\mathbf{x}) = \\mathbb{P}(\\theta &gt; \\theta_\\text{max} \\mid \\mathbf{x}) = \\frac{\\alpha}{2}\\).\n\n\nConjugate Priors\nIf we were to pick two arbitrary distributions for the likelihood \\(p(\\mathbf{x} \\mid \\theta)\\) and the prior \\(p(\\theta)\\) with which to express the posterior distribution \\(p(\\theta \\mid \\mathbf{x})\\), the posterior will often still be difficult to compute. But there are specific cases where computing it gets easier if we are prudent in our choice of what form the likelihood and prior take. Specifically, when the prior is conjugate to the likelihood, the posterior is guaranteed to be in the same distributional family as the prior (usually with different parameters).\nAn example of this can be seen with the beta and Bernoulli distributions we’ve been working with. Suppose that:\n\\[\\Pi \\sim \\text{Beta}(\\alpha, \\beta)\\]\nAnd suppose we wanted to compute the posterior density \\(p(\\pi \\mid x)\\) when we’ve observed a single \\(X\\). We don’t know this density directly, but we do know \\(p(x \\mid \\pi) = \\text{Bern}(x \\mid \\pi)\\) and the \\(p(\\pi) = \\text{Beta}(\\pi; \\alpha, \\beta)\\).5\nLet’s work through the full expression of Bayes’ theorem.\n\\[p(\\pi \\mid x) = \\frac{p(x \\mid \\pi)p(\\pi)}{p(x)} = \\frac{p(x \\mid \\pi)p(\\pi)}{\\int p(x \\mid \\pi')p(\\pi') \\, \\mathrm{d}\\pi'}\\]\nAnd let’s first deal with that denominator.\n\\[\\begin{align*}p(x) &= \\int p(x \\mid \\pi)p(\\pi) \\, \\mathrm{d}\\pi \\\\ &= \\int_0^1 \\text{Bern}(x\\mid \\pi)\\,\\text{Beta}(\\pi; \\alpha, \\beta)\\,\\mathrm{d}\\pi\\\\\n&= \\int_0^1 \\pi^x(1-\\pi)^{1-x}\\frac{\\pi^{\\alpha-1}(1-\\pi)^{\\beta-1}} {\\mathrm{B}(\\alpha,\\beta)} \\,\\mathrm{d}\\pi\\\\ &= \\frac{1}{\\mathrm{B}(\\alpha,\\beta)}\\int_0^1 \\pi^{x+\\alpha-1}(1-\\pi)^{\\beta+(1-x)-1} \\,\\mathrm{d}\\pi\\end{align*}\\]\nThis formula looks complex, but it turns out that we can use a straightforward trick to simplify it: because PDFs must always integrate to 1 over the range of the random variable by the assumption of unit measure, e.g.,…\n\\[\\int_0^1 \\text{Beta}(\\pi; \\alpha, \\beta)\\,\\mathrm{d}\\pi = \\int_0^1 \\frac{\\pi^{\\alpha-1}(1-\\pi)^{\\beta-1}} {\\mathrm{B}(\\alpha,\\beta)}\\,\\mathrm{d}\\pi = 1\\]\n…and because the normalizing constant can always be factored out of the integral, since it doesn’t depend on the variable of integration, e.g., …\n\\[\\int_0^1 \\frac{\\pi^{\\alpha-1}(1-\\pi)^{\\beta-1}} {\\mathrm{B}(\\alpha,\\beta)}\\,\\mathrm{d}\\pi = \\frac{1} {\\mathrm{B}(\\alpha,\\beta)}\\int_0^1 \\pi^{\\alpha-1}(1-\\pi)^{\\beta-1}\\,\\mathrm{d}\\pi\\]\n…it must be that the unnormalized PDF, e.g., \\(\\pi^{\\alpha-1}(1-\\pi)^{\\beta-1}\\) integrates to the normalizing constant:\n\\[\\int_0^1 \\pi^{\\alpha-1}(1-\\pi)^{\\beta-1}\\,\\mathrm{d}\\pi = \\mathrm{B}(\\alpha,\\beta)\\]\nWhy does this help us? Well. We can view the value we need to integrate in our compound distribution as an unnormalized PDF of a random variable \\(\\text{Beta}(\\alpha + x, \\beta + (1-x))\\) and thus:\n\\[\\begin{align*}p(x) &= \\frac{1}{\\mathrm{B}(\\alpha,\\beta)}\\int_0^1 \\pi^{x+\\alpha-1}(1-\\pi)^{\\beta+(1-x)-1} \\,\\mathrm{d}\\pi\\\\ &= \\frac{\\mathrm{B}(\\alpha + x, \\beta + (1-x))}{\\mathrm{B}(\\alpha,\\beta)} \\end{align*}\\]\nThis still looks complex, but it’s actually not, because we can take advantage of the properties of the gamma function.\n\\[\\begin{align*}p(x) &= \\frac{\\mathrm{B}(\\alpha + x, \\beta + (1-x))}{\\mathrm{B}(\\alpha,\\beta)}\\\\ &= \\frac{\\left(\\frac {\\Gamma (\\alpha+x)\\Gamma (\\beta+(1-x))}{\\Gamma (\\alpha+\\beta+1)}\\right)}{\\left(\\frac {\\Gamma (\\alpha)\\Gamma (\\beta)}{\\Gamma (\\alpha+\\beta)}\\right)} \\\\ &= \\frac{\\Gamma (\\alpha+\\beta)}{\\Gamma (\\alpha+\\beta+1)} \\frac{\\Gamma (\\alpha+x)}{\\Gamma (\\alpha)} \\frac{\\Gamma (\\beta+(1-x))}{\\Gamma (\\beta)} \\\\ &= \\begin{cases}\\frac{\\alpha}{\\alpha+\\beta} & \\text{if } x = 1\\\\ \\frac{\\beta}{\\alpha+\\beta} & \\text{if } x = 0\\end{cases} \\\\ &= \\left(\\frac{\\alpha}{\\alpha+\\beta}\\right)^x\\left(1-\\frac{\\alpha}{\\alpha+\\beta}\\right)^{1-x} \\end{align*}\\]\n\\(X\\) (in contrast to \\(X \\mid \\Pi\\), which is distributed Bernoulli) is thus said to be distributed \\(\\text{BetaBernoulli}(\\alpha, \\beta)\\), which as we just showed turns out to be equivalent to being distributed \\(\\text{Bernoulli}\\left(\\frac{\\alpha}{\\alpha+\\beta}\\right)\\). The BetaBernoulli distribution is our first instance of a compound probability distribution. We’ll see more such distributions throughout the course.6\nSo now we know what the denominator looks like; what’s the numerator? Well. We’ve already computed it while computing the denominator:\n\\[p(x \\mid \\pi)p(\\pi) = \\frac{\\pi^{x+\\alpha-1}(1-\\pi)^{\\beta+(1-x)-1}}{\\mathrm{B}(\\alpha, \\beta)}\\]\nThus:\n\\[p(\\pi \\mid x) = \\frac{\\left(\\frac{\\pi^{x+\\alpha-1}(1-\\pi)^{\\beta+(1-x)-1}}{\\mathrm{B}(\\alpha, \\beta)}\\right)}{\\left(\\frac{\\alpha}{\\alpha+\\beta}\\right)^x\\left(\\frac{\\beta}{\\alpha+\\beta}\\right)^{1-x}}\\]\nI promised a form for the posterior that was in the same family as the prior, so this should be a beta distribution; but it doesn’t really look like one. It is, though; and to see it, we need to go back to:\n\\[p(x) = \\frac{\\mathrm{B}(\\alpha + x, \\beta + (1-x))}{\\mathrm{B}(\\alpha,\\beta)}\\]\nUsing this equality, we get:\n\\[\\begin{align*}p(\\pi \\mid x) &= \\frac{\\left(\\frac{\\pi^{x+\\alpha-1}(1-\\pi)^{\\beta+(1-x)-1}}{\\mathrm{B}(\\alpha, \\beta)}\\right)}{\\left(\\frac{\\mathrm{B}(\\alpha + x, \\beta + (1-x))}{\\mathrm{B}(\\alpha,\\beta)}\\right)}\\\\ &= \\frac{\\pi^{x+\\alpha-1}(1-\\pi)^{\\beta+(1-x)-1}}{\\mathrm{B}(\\alpha + x, \\beta + (1-x))}\\\\ &= \\mathrm{Beta}(\\pi \\mid \\alpha + x, \\beta + (1-x))\\\\ \\end{align*}\\]\nIntuitively, this can be read: “if I started out believing that \\(\\Pi\\) was distributed \\(\\text{Beta}(\\alpha, \\beta)\\) and then I observed that \\(X = x\\), I now should believe that \\(\\Pi\\) is distributed \\(\\mathrm{Beta}(\\pi \\mid \\alpha + x, \\beta + (1-x))\\).”\nSo if I started out with a uniform distribution on \\(\\pi \\sim \\text{Beta}(1, 1)\\)…\n\n\nPlotting code\nfrom scipy.stats import beta\n\nax = subplot()\n\n_ = ax.plot(mgrid[0:1:0.01], beta(1, 1).pdf(mgrid[0:1:0.01]))\n\n\n\n\n\n…and I observed \\(X = 1\\), I shift the density to the right: \\(\\pi \\mid X = 1 \\sim \\text{Beta}(2, 1)\\)…\n\n\nPlotting code\nax = subplot()\n\n_ = ax.plot(mgrid[0:1:0.01], beta(2, 1).pdf(mgrid[0:1:0.01]))\n\n\n\n\n\n…but if I observed \\(X = 0\\), I shift the density to the left: \\(\\pi \\mid X = 0 \\sim \\text{Beta}(1, 2)\\).\n\n\nPlotting code\nax = subplot()\n\n_ = ax.plot(mgrid[0:1:0.01], beta(1, 2).pdf(mgrid[0:1:0.01]))\n\n\n\n\n\nIf I start out with a much denser prior, like \\(\\pi \\sim \\text{Beta}(10, 10)\\)…\n\n\nPlotting code\nax = subplot()\n\n_ = ax.plot(mgrid[0:1:0.01], beta(10, 10).pdf(mgrid[0:1:0.01]))\n\n\n\n\n\n… the shifts to \\(\\pi \\mid X = 1 \\sim \\text{Beta}(11, 10)\\) and \\(\\pi \\mid X = 0 \\sim \\text{Beta}(10, 11)\\) are much smaller.\n\n\nPlotting code\nax = subplot()\n\nax.plot(mgrid[0:1:0.01], beta(10, 10).pdf(mgrid[0:1:0.01]), label=\"Prior: Beta(10, 10)\")\nax.plot(mgrid[0:1:0.01], beta(11, 10).pdf(mgrid[0:1:0.01]), label=\"Posterior after observing X = 1: Beta(11, 10)\")\nax.plot(mgrid[0:1:0.01], beta(10, 11).pdf(mgrid[0:1:0.01]), label=\"Posterior after observing X = 0: Beta(10, 11)\")\n\n_ = ax.legend()\n\n\n\n\n\nSo the stronger I believe something initially (e.g. that there is high density nearest to \\(0.5\\)), the less I can be swayed one way or another by a single piece of evidence.\n\nPredictive Distributions\nWe’ll use conjugacy extensively throughout this course. To give you a taste: one important place it will show up is in the context of making predictions about what we will see in the future (\\(x_\\text{new}\\)) based on what we’ve already seen (\\(\\mathbf{x}_\\text{old}\\)), which we can formulate using what’s know as the posterior predictive distribution.\n\\[\\begin{align*}p(x_\\text{new} \\mid \\mathbf{x}_\\text{old}) &= \\int p(x_\\text{new}, \\pi \\mid \\mathbf{x}_\\text{old})\\,\\mathrm{d}\\pi & \\text{definition of joint distribution}\\\\ &= \\int p(x_\\text{new}\\mid \\pi; \\mathbf{x}_\\text{old})p(\\pi \\mid \\mathbf{x}_\\text{old})\\,\\mathrm{d}\\pi & \\text{definition of conditional probability}\\\\ &= \\int p(x_\\text{new}\\mid \\pi)p(\\pi \\mid \\mathbf{x}_\\text{old})\\,\\mathrm{d}\\pi & \\text{conditional independence assumption}\\\\ &= \\int \\mathcal{L}(\\pi \\mid x_\\text{new})p(\\pi \\mid \\mathbf{x}_\\text{old})\\,\\mathrm{d}\\pi  & \\text{definition of $\\mathcal{L}$}\\\\ &= \\mathbb{E}\\left[\\mathcal{L}(\\Pi \\mid x_\\text{new})\\mid \\mathbf{X}\\right] & \\text{definition of conditional expectation}\\\\\\end{align*}\\]\nIn the context of our running example, this can be read “if I’ve observed pronouns with cases \\(\\mathbf{x}_\\text{old}\\), the probability that the next pronoun I observe \\(x_\\text{new}\\) will be high can be found by taking the conditional expectation of the likelihood \\(\\mathcal{L}(\\Pi \\mid x_\\text{new})\\) (a function of the random variable \\(\\Pi\\)) given \\(\\mathbf{X}_\\text{old}\\).”\nWe know by slightly extending what we saw above that:\n\\[p(\\pi \\mid \\mathbf{x}; \\alpha, \\beta) = \\text{Beta}\\left(\\pi; \\alpha + \\sum_i x_{\\text{old}, i}, \\beta + \\sum_i 1 - x_{\\text{old}, i}\\right)\\]\nAnd since \\(p(x_\\text{new}\\mid \\pi) = \\text{Bernoulli}(x_\\text{new}; \\pi)\\) by the work we did to prove the beta-Bernoulli conjugacy, we know that:\n\\[p(x_\\text{new}\\mid \\pi; \\mathbf{x}_\\text{old})p(\\pi \\mid \\mathbf{x}_\\text{old}) = \\frac{\\pi^{\\alpha + x_\\text{new} + \\sum_i x_{\\text{old}, i} - 1}(1-\\pi)^{\\beta + (1-x_\\text{new}) +\\sum_i 1 - x_{\\text{old}, i}-1}}{\\mathrm{B}\\left(\\alpha + \\sum_i x_{\\text{old}, i}, \\beta  +\\sum_i 1 - x_{\\text{old}, i}\\right)}\\]\nSo:\n\\[\\begin{align*}p(x_\\text{new} \\mid \\mathbf{x}_\\text{old}) &= \\int \\frac{\\pi^{\\alpha + x_\\text{new} + \\sum_i x_{\\text{old}, i} - 1}(1-\\pi)^{\\beta + (1-x_\\text{new}) +\\sum_i 1 - x_{\\text{old}, i}-1}}{\\mathrm{B}\\left(\\alpha + \\sum_i x_{\\text{old}, i}, \\beta  +\\sum_i 1 - x_{\\text{old}, i}\\right)}\\,\\mathrm{d}\\pi\\\\ &= \\frac{\\int \\pi^{\\alpha + x_\\text{new} + \\sum_i x_{\\text{old}, i} - 1}(1-\\pi)^{\\beta + (1-x_\\text{new}) +\\sum_i 1 - x_{\\text{old}, i}-1} \\,\\mathrm{d}\\pi}{\\mathrm{B}\\left(\\alpha + \\sum_i x_{\\text{old}, i}, \\beta  +\\sum_i 1 - x_{\\text{old}, i}\\right)}\\\\ &= \\frac{\\mathrm{B}\\left(\\alpha + x_\\text{new} + \\sum_i x_{\\text{old}, i}, \\beta + (1-x_\\text{new}) +\\sum_i 1 - x_{\\text{old}, i}\\right)}{\\mathrm{B}\\left(\\alpha + \\sum_i x_{\\text{old}, i}, \\beta  +\\sum_i 1 - x_{\\text{old}, i}\\right)}\\\\\\end{align*}\\]\nThis form is exactly like what we had when computing the computing \\(p(x)\\), and the same logic for reducing it can be deployed here.\n\\[p(x_\\text{new} \\mid \\mathbf{x}_\\text{old}) = \\text{BetaBern}\\left(x_\\text{new}; \\alpha + \\sum_i x_{\\text{old}, i}, \\beta + \\sum_i 1- x_{\\text{old}, i}\\right) = \\text{Bern}\\left(x_\\text{new}; \\frac{\\alpha + \\sum_i x_{\\text{old}, i}}{\\alpha + \\beta + N}\\right)\\]\nThis is of course not a coincidence: the evidence \\(p(x) = \\int p(x\\mid \\pi)p(\\pi)\\,\\mathrm{d}\\pi\\) is always the prior predictive distribution, which is just like the posterior predictive distribution, but without the conditioning on prior data.\n\\[p(x) = \\mathbb{E}\\left[\\mathcal{L}(\\Pi \\mid x)\\right]\\]\n\n\n\nBeyond conjugacy\nIt is often the case that we cannot derive the posterior \\(p(\\theta \\mid \\mathbf{x})\\) analytically–i.e. without any integrals, as we did above. For instance, suppose we wanted to compute the evidence/prior predictive \\(p(\\mathbf{x})\\) from our example above, but instead of assuming that the prior \\(p(\\pi)\\) was beta-distributed, we wanted to assume it was distributed logit-normal.\n\\[p(\\pi; \\mu, \\sigma) \\propto \\frac{\\exp\\left(-\\frac  {(\\text{logit}(\\pi)-\\mu )^2}{2\\sigma^2}\\right)}{\\pi(1-\\pi)}\\]\n\nfrom numpy import inf\nfrom scipy.stats import rv_continuous, norm\nfrom scipy.special import logit, expit\n\nclass logitnorm_gen(rv_continuous):\n    \"\"\"A logit-normal generator\n    \n    See https://stackoverflow.com/a/73084994\n    \"\"\"\n    \n    def _argcheck(self, m, s):\n        return (s &gt; 0.) & (m &gt; -inf)\n    \n    def _pdf(self, x, m, s):\n        return norm(loc=m, scale=s).pdf(logit(x))/(x*(1-x))\n    \n    def _cdf(self, x, m, s):\n        return norm(loc=m, scale=s).cdf(logit(x))\n    \n    def _rvs(self, m, s, size=None, random_state=None):\n        return expit(m + s*random_state.standard_normal(size))\n    \n    def fit(self, data, **kwargs):\n        return norm.fit(logit(data), **kwargs)\n\nlogitnorm = logitnorm_gen(a=0.0, b=1.0, name=\"logitnorm\")\n\nThe logit-normal can capture many beta-like shapes, including both sparse and dense distributions and unimodal and bimodal distributions.\n\n\nPlotting code\nax = subplot()\n\nprobability = mgrid[0.01:1.0:0.01]\n\nmu_sigma = [\n    (0.0, 0.5),\n    (1.5, 0.5),\n    (0.0, 5.0)\n]\n\nfor mu, sigma in mu_sigma:\n    ax.plot(\n        probability, \n        logitnorm(mu, sigma).pdf(probability),\n        label=f\"LogitNormal({mu}, {sigma})\"\n    )\n    \nax.legend()\n\nax.set_xlabel(\"Probability\")\n_ = ax.set_ylabel(\"Density\")\n\n\n\n\n\nIn this case, we won’t be able to map this to a known distribution. We need to resort to approximating it.\n\\[\\begin{align*}\np(\\mathbf{x}) &= \\int p(\\mathbf{x} \\mid \\pi)p(\\pi; \\mu, \\sigma)\\,\\mathrm{d}\\pi\\\\\n&\\propto \\int \\pi^{\\sum_i x_i}(1-\\pi)^{\\sum_i (1-x_i) }\\frac{\\exp\\left(-\\frac  {(\\text{logit}(\\pi)-\\mu )^2}{2\\sigma^2}\\right)}{\\pi(1-\\pi)}\\,\\mathrm{d}\\pi\\\\\n&\\propto \\int \\pi^{\\sum_i x_i - 1}(1-\\pi)^{\\sum_i (1-x_i) - 1}\\exp\\left(-\\frac  {(\\text{logit}(\\pi)-\\mu )^2}{2\\sigma^2}\\right)\\,\\mathrm{d}\\pi\\\\\n\\end{align*}\\]\n\nMonte Carlo Integration\nOne way to do this is by brute force using some form of numerical integration–e.g. a Monte Carlo integration technique. In this case, we sample many (say, \\(K\\)) values \\(\\pi_k\\) from the logit-normal prior (which, I will assert, we know how to sample from), evaluate the likelihood under \\(\\pi_k\\), then average those likelihoods.\n\\[p(\\mathbf{x}) \\approx \\frac{1}{K}\\sum_{k=1}^K p(\\mathbf{x} \\mid \\pi_k) = \\frac{1}{K}\\sum_{k=1}^N \\pi_k^{\\sum_i x_i}(1-\\pi_k)^{\\sum_i (1-x_i) }\\]\n\nfrom numpy import ndarray, log\nfrom scipy.special import logsumexp\nfrom scipy.stats import bernoulli\n\ndef bernoulli_logit_normal_log_evidence(x: ndarray, mu: float, sigma: float, n_approx: int=1_000) -&gt; float:\n    \"\"\"The log-evidence of the data under a Bernoulli likelihood with logit-normal prior\n    \n    Parameters\n    ----------\n    x\n        The data\n    mu\n        The mean log-odds for the logit-normal\n    sigma\n        The standard deviation in the log-odds for the logit-normal\n    n_approx\n        The number of samples to draw in approximating the evidence\n    \"\"\"\n    n, = x.shape\n    \n    return logsumexp([\n        bernoulli(pi_bar_k).logpmf(x).sum()\n        for pi_bar_k in logitnorm(mu, sigma).rvs(n_approx)\n    ]) - log(n_approx)\n\nKeeping the number of observations \\(N\\) fixed, we can then plot the approximate log-evidence in terms of the proportion of true observations for different settings of the logit-normal parameters (\\(\\mu\\) and \\(\\sigma\\)).7\n\n\nPlotting code\nfrom numpy.random import seed\n\nseed(4329)\n\nax = subplot()\n\nmus = arange(-4, 5)\nsigmas = mgrid[0.1:1.1:0.1]\n\nfor mu in mus:\n    log_evidence = [\n        bernoulli_logit_normal_log_evidence(data, mu, sigma)\n        for sigma in sigmas\n    ]\n    ax.plot(sigmas, log_evidence, label=f\"LogitNormal({mu}, \"+ r\"$\\sigma$)\")\n\nax.legend()\n\nax.set_title(\"Log-evidence under different LogitNormal priors\")\nax.set_xlabel(r\"$\\sigma$\")\n_ = ax.set_ylabel(r\"$\\log p(\\mathbf{x})$\")\n\n\n\n\n\nThis approach works because we can sample \\(\\pi_k\\) from the prior. But it becomes hairy in the case where we don’t know how to draw such samples. For instance, suppose we want to compute the posterior predictive \\(p(x_\\text{new} \\mid \\mathbf{x}_\\text{old})\\).\n\\[p(x_\\text{new} \\mid \\mathbf{x}_\\text{old}) = \\int p(x_\\text{new}  \\mid \\pi)p(\\pi \\mid \\mathbf{x}_\\text{old})\\,\\mathrm{d}\\pi\\]\nIn this case, we need to be able to sample from the posterior \\(p(\\pi \\mid \\mathbf{x}_\\text{old})\\). But we don’t know how to sample from the posterior because, as we just saw, it doesn’t have a known distribution. One idea–the core idea of importance sampling–is to sample candidate \\(\\pi'_k\\)s from some proposal distribution \\(q(\\pi')\\) that we know how to sample from (e.g. in this case, the uniform is a reasonable choice) and then weight the average we aim to compute in the appropriate way. To see why this works, note that we can rewrite \\(p(x_\\text{new} \\mid \\mathbf{x}_\\text{old})\\) as an expectation of \\(\\Pi' \\sim q(\\cdot)\\).\n\\[\\begin{align*}\np(x_\\text{new} \\mid \\mathbf{x}_\\text{old}) &= \\int p(\\mathbf{x} \\mid \\pi)p(\\pi \\mid \\mathbf{x})\\,\\mathrm{d}\\pi\\\\\n&= \\int p(\\mathbf{x} \\mid \\pi)p(\\pi \\mid \\mathbf{x})\\frac{q(\\pi)}{q(\\pi)}\\,\\mathrm{d}\\pi\\\\\n&= \\int p(\\mathbf{x} \\mid \\pi')\\frac{p(\\pi' \\mid \\mathbf{x})}{q(\\pi')}q(\\pi')\\,\\mathrm{d}\\pi'\\\\\n&= \\mathbb{E}\\left[p(\\mathbf{x} \\mid \\Pi')\\frac{p(\\Pi' \\mid \\mathbf{x})}{q(\\Pi')}\\right]\n\\end{align*}\\]\nThis rewrite then allows us to sample from the proposal distribution–rather than the actual distribution–in approximating \\(p(x_\\text{new} \\mid \\mathbf{x}_\\text{old})\\) using Monte Carlo integration. We merely need to reweight the sample by \\(\\frac{p(\\pi \\mid \\mathbf{x})}{q(\\pi)}\\) to account for the fact that we are sampling from a different distribution.8\n\\[p(x_\\text{new} \\mid \\mathbf{x}_\\text{old}) \\approx \\frac{1}{K}\\sum_{k=1}^K p(x_\\text{new} \\mid \\pi'_k)\\frac{p(\\pi'_k \\mid \\mathbf{x}_\\text{old})}{q(\\pi'_k)}\\]\nNow, one thing you might have noticed is that we actually have to approximate two integrals to compute \\(p(x_\\text{new} \\mid \\mathbf{x}_\\text{old})\\): (i) the integral over the posterior we just handled; and (ii) the integral over the prior, which is implicit in the denominator of the posterior–the evidence \\(p(\\mathbf{x})\\) in \\(p(\\pi \\mid \\mathbf{x}) = \\frac{p(\\mathbf{x} \\mid \\pi)p(\\pi)}{p(\\mathbf{x})}\\). In principle, because the \\(p(\\mathbf{x})\\) is a constant relative to the first integral, we can pull it out and just compute it once.\n\\[p(x_\\text{new} \\mid \\mathbf{x}_\\text{old}) \\approx \\frac{1}{Kp(\\mathbf{x})}\\sum_{k=1}^N p(x_\\text{new} \\mid \\pi'_k)\\frac{p(\\mathbf{x}_\\text{old}\\mid\\pi'_k)p(\\pi'_k)}{q(\\pi'_k)}\\]\nBut since we don’t really care about it in the context of computing \\(p(x_\\text{new} \\mid \\mathbf{x}_\\text{old})\\), it would be nice if we could ignore it altogether. One way to do this is to take a different approach to sampling that attempts to actually produce a set of samples from the posterior, rather than drawing samples from some other distribution and subsequently reweighting them (as in importance sampling).\n\n\nMarkov Chain Monte Carlo\nMarkov chain Monte Carlo (MCMC) methods attempt to sample from the posterior directly. The idea behind MCMC is to start from some sample \\(\\theta\\) and then propose a new sample \\(\\theta'\\) conditioned on \\(\\theta\\) that we accept or reject based on how (i) probable that sample is under the distribution we are attempting to sample from; and (ii) how probable the previous sample was under the distribution we are attempting to sample from. If we accept the proposal, we log it and use it to condition the proposal of the new sample; otherwise, we try again using \\(\\theta\\) to condition the new proposal. Together, the sequence of \\(\\theta\\)s is our sample from the posterior.\nMCMC still requires us to evaluate the distribution of interest at each sample; but because it relies on comparison of the probabilities of the current sample and the proposal, the constant terms in that comparison cancel each other out–meaning we don’t need to worry about computing quantities, like the evidence \\(p(\\mathbf{x})\\), that we’re not interested in.\n\nMetropolis-Hastings samplers\nOne simple family of methods that can be useful in getting an intuition for how MCMC work are those that use the Metropolis-Hastings algorithm (MH). I’ll walk through how an MH sampler can be built for the example above; but know that, for the remainder of the course, we will use STAN to automatically construct and deploy samplers that use Hamiltonian Monte Carlo, which has various benefits over simpler approaches but which is somewhat different from the simple MH algorithm I’ll present here.\nSimilar to importance sampling, the basic idea behind the MH algorithm is to define some proposal distribution \\(q(\\theta' \\mid \\theta)\\) for generating proposals. Unlike in importance sampling, this distribution is generally conditioned on the previous sample \\(\\theta_{k-1}\\). We start the sampler by choosing some initial sample \\(\\theta_0\\). Then, for each sample \\(k\\) we’d like to draw we:\n\nSample a candidate \\(\\theta'_k \\sim q(\\cdot \\mid \\theta_{k-1})\\)\nCalculate the acceptance ratio \\(\\alpha_k = \\frac{p(\\theta'_k \\mid \\mathbf{x})q(\\theta'_k \\mid \\theta_{k-1})}{p(\\theta_{k-1} \\mid \\mathbf{x})q(\\theta_{k-1} \\mid \\theta'_k)}\\)\nSample whether to accept the proposal \\(a_k \\sim \\text{Bernoulli}(\\min(\\alpha_k, 1))\\)\nIf \\(a_k\\), set \\(\\theta_k = \\theta'_k\\); otherwise \\(\\theta_k = \\theta_{k-1}\\)\n\nIn the case of our Bernoulli-logit normal model, we could define a relatively simple proposal distribution \\(\\mathcal{U}(l_k, u_k)\\), where \\(l_k \\equiv \\max\\left(0, \\theta_{k-1} - \\frac{\\delta}{2}\\right)\\), \\(u_k \\equiv \\min\\left(1, \\theta_{k-1} + \\frac{\\delta}{2}\\right)\\), and \\(\\delta\\) is a parameter of the sampler. This proposal distribution ensures that the proposal \\(\\pi'_k \\in [0, 1]\\) and that we only ever propose samples at most \\(\\frac{\\delta}{2}\\) from \\(\\pi_{k-1}\\).9\n\nfrom numpy import array, exp, corrcoef\nfrom scipy.stats import uniform\n\nclass BernoulliLogitNormalPosteriorMHSampler:\n    \"\"\"A Metropolis-Hastings sampler for a Bernoulli-LogitNormal model\n    \n    Parameters\n    ----------\n    mu\n        mean log-odds for LogitNormal\n    sigma\n        standard deviation for LogitNormal\n    \"\"\"\n    def __init__(self, mu: float, sigma: float):\n        self.mu = mu\n        self.sigma = sigma\n        \n    def _initialize(self, x: ndarray, n_samples: int, delta: float):\n        # save the data `x` and sampler parameter `delta`\n        self.x = x\n        self.delta = delta\n        \n        # initialize the samples to -inf so it is easier to detect bugs\n        # in the sampler implementation\n        self.samples = zeros(n_samples) - inf\n        \n        # set the initial sample to the mean of the data (the MLE)\n        self.sample[0] = x.mean()\n        \n        # initialize the log unnormalized posterior for the samples \n        # to -inf\n        self.lup = zeros(n_samples) - inf\n        \n        # set the initial log unnormalized posterior to the log \n        # unnormalized posterior for the initial sample\n        self.lup[0] = self._log_unnormalized_posterior(self.samples[0])\n    \n    def fit(self, x: ndarray, n_samples: int = 20_000, delta: float = 0.1, \n            burnin: int = 2_000, thinning: int = 100, \n            verbosity: int = 0) -&gt; 'BernoulliLogitNormalPosteriorMHSampler':\n        self._initialize(x, n_samples, delta)\n        \n        acceptance_count = 0\n        \n        for k in range(1, n_samples):\n            # sample proposal\n            pi_prime_k = self._propose(k)\n            \n            # log transition probabilities\n            ltp_f, ltp_b = self._log_transition_prob(pi_prime_k, k)\n            \n            # log unnormalized posterior for pi_prime_k\n            lup = self._log_unnormalized_posterior(pi_prime_k)\n            \n            # log acceptance ratio\n            lar = (lup + ltp_f) - (self.lup[k-1] + ltp_b)\n            \n            # acceptance probability\n            ap = min(exp(lar), 1)\n            \n            # sample whether to accept\n            accept, = bernoulli(ap).rvs(1)\n            \n            # save sample\n            if accept:\n                self.samples[k] = pi_prime_k\n                self.lup[k] = lup\n                \n                acceptance_count += 1\n                \n            else:\n                self.samples[k] = self.samples[k-1]\n                self.lup[k] = self.lup[k-1]\n\n            if verbosity and k and not (k % verbosity):\n                print(f\"Sample {k}\")\n                print(f\"Acceptance proportion: {round(acceptance_count / k, 2)}\")\n                print(f\"Sample:                {round(self.samples[k], 2)}\")\n                print()\n                \n        # throw out burn-in samples and thin samples\n        self.samples = self.samples[burnin::thinning]\n                \n        if verbosity:\n            autocorrelation = corrcoef(self.samples[:-1], self.samples[1:])[1,0]\n            print(f\"Autocorrelation: {autocorrelation}\")\n            print()\n                \n        return self\n            \n    def _propose(self, k: int) -&gt; float:\n        l, u = self._proposal_bounds(\n            self.samples[k-1], self.delta\n        )\n        \n        # uniform parameterized by (loc, loc + scale)\n        pi_prime_k, = uniform(l, u - l).rvs(1)\n        \n        return pi_prime_k\n    \n    def _log_transition_prob(self, pi_prime_k: float, k: int) -&gt; float:\n        # forward proposal bounds\n        l_f, u_f = self._proposal_bounds(\n            self.samples[k-1], self.delta\n        )\n        \n        # forward log transition probability\n        ltp_f = uniform(l_f, u_f - l_f).logpdf(pi_prime_k)\n        \n        # backward proposal bounds\n        l_b, u_b = self._proposal_bounds(\n            pi_prime_k, self.delta\n        )\n        \n        # backward log transition probability\n        ltp_b = uniform(l_b, u_b - l_b).logpdf(self.samples[k-1])\n        \n        return ltp_f, ltp_b\n        \n    def _log_unnormalized_posterior(self, pi: float):\n        log_likelihood = bernoulli(pi).logpmf(self.x).sum()\n        log_prior = logitnorm(self.mu, self.sigma).logpdf(pi)\n        \n        return log_likelihood + log_prior\n    \n    def _proposal_bounds(self, pi: float, delta: float) -&gt; Tuple[float]:\n        d = delta/2\n        a, b = pi + array([-d, d])\n        \n        return max(a, 0), min(b, 1)\n\nWe’ll fit this using a \\(\\text{LogitNormal}(0, 1)\\) prior.10\n\nseed(302928)\n\nmh_sampler = BernoulliLogitNormalPosteriorMHSampler(0., 1.)\n\nFor comparison, a \\(\\text{LogitNormal}(0, 1)\\) prior has a relatively similar shape to a \\(\\text{Beta}(2, 2)\\) prior.\n\n\nPlotting code\nax = subplot()\n\nprobability = mgrid[0.01:1.0:0.01]\n\nax.plot(\n    probability, \n    logitnorm(0, 1).pdf(probability),\n    label=f\"LogitNormal(0, 1)\"\n)\n\nax.plot(\n    probability, \n    beta(2, 2).pdf(probability),\n    label=f\"Beta(2, 2)\"\n)\n    \nax.legend()\n\nax.set_xlabel(\"Probability\")\n_ = ax.set_ylabel(\"Density\")\n\n\n\n\n\nIf we run this sampler and then plot the posterior samples, we get an approximation to the posterior distribution that is very close to the analytically computable posterior distribution under the assumption that the prior is distributed beta.\n\n_ = mh_sampler.fit(data, delta=0.01)\n\n&lt;__main__.BernoulliLogitNormalPosteriorMHSampler at 0xffff61e92c50&gt;\n\n\n\n\nPlotting code\nax = subplot()\n\nax.set_xlim(0, 1)\n\nax.hist(mh_sampler.samples, bins=10, density=True, label=\"Approximate posterior under LogitNorm(0, 1) prior\")\nax.plot(\n    mgrid[0.01:1.0:0.01], \n    beta(\n        2 + data.sum(), \n        2 + (1-data).sum()).pdf(mgrid[0.01:1.0:0.01]\n    ), \n    label=\"True posterior under Beta(2, 2) prior\"\n)\n\nax.legend()\n\nax.set_title(r\"Approximate posterior distribution of $\\pi$\")\nax.set_xlabel(r\"$p(\\pi \\mid \\mathbf{x})$\")\n_ = ax.set_ylabel(\"Density\")\n\n\n\n\n\n\n\nImplementing samplers in STAN\nIt is quite rare to implement MCMC samplers by hand nowadays. In general, we would rather use some software package that allows us to specify our desired distributional assumptions and then builds a sampler programmatically based on those assumptions. STAN, which is the package we will use, is a popular choice for doing this. Other packages for doing this in python are pymc and pyro.\nThe way we construct a model in STAN is by declaring the form of the data (including both the data we are modeling and any parameters of the priors) and the distributional assumptions that make up the model. These are specified in program blocks.\nThe data block specifies what the inputs STAN can expect to receive look like.\ndata {\n    int N;                             // number of datapoints\n    real mu;                           // prior mean\n    real sigma;                        // prior standard deviation\n    int&lt;lower=0, upper=1&gt; x[N];        // datapoints \n}\nThe parameters block specifies which parameters STAN will need to sample.\nparameters {\n    real logodds;                      // log-odds of success\n}\nIn our case, we are specifying an auxiliary variable logodds that corresponds to \\(\\text{logit}(\\pi) = \\log\\frac{\\pi}{1 - \\pi}\\). The reason we are doing it this way is that \\(\\pi \\sim \\text{LogitNormal}(\\mu, \\sigma)\\) is equivalent to saying that \\(\\text{logit}(\\pi) \\sim \\mathcal{N}(\\mu, \\sigma)\\), and STAN does not specify a logit-normal distribution in its standard library of distributions. So what we will do it sample logodds \\(= \\text{logit}(\\pi)\\), then compute \\(\\text{logit}^{-1}(\\)logodds\\() = \\text{logit}^{-1}(\\text{logit}(\\pi)) = \\pi\\), which we can do using STAN’s transformed parameters block.\nThe transformed parameters block specifies which transformations of the sampled parameters are needed in parameterizing some other distribution.11\ntransformed parameters {\n    real pi = inv_logit(logodds);      // probability of success\n}\nIn this case, we use it to compute \\(\\pi = \\text{logit}^{-1}(\\)logodds\\()\\) from a sampled logodds deterministically.\nFinally, model block specifies the distributional assumptions of the model.12\nmodel {\n    logodds ~ normal(mu, sigma);\n    x ~ bernoulli(pi);\n}\nIn our case, we state that logodds \\(\\sim \\text{LogitNormal}(\\mu, \\sigma)\\) and \\(X_i \\sim \\text{Bernoulli}(\\pi)\\).13\nTo interface with STAN, which maps the above model specification to C++ code, we will use cmdstanpy, which is a light wrapper around cmdstan. cmdstan provides tools for executing the sampler code built by STAN, and cmdstanpy provides wrappers around those tools.\n\n\nSilence STAN logger\nimport logging\nlogger = logging.getLogger('cmdstanpy')\nlogger.addHandler(logging.NullHandler())\nlogger.propagate = False\nlogger.setLevel(logging.CRITICAL)\n\n\n\nfrom cmdstanpy import CmdStanModel\n\nstan_model = CmdStanModel(\n    stan_file=\"bernoulli-logit-normal-model.stan\"\n)\nmodel_data = {\n    \"N\": data.shape[0],\n    \"mu\": 0.0,\n    \"sigma\": 1.0,\n    \"x\": data\n}\nmodel_fit = stan_model.sample(\n    data=model_data, \n    iter_warmup=10_000, iter_sampling=10_000,\n    show_progress=False,\n    seed=304938\n)\n\nWe can then use arviz to quickly plot the posteriors for the parameters. And again, we get something very similar to what we observed with our Metropolis-Hastings sampler.\n\nfrom arviz import plot_posterior\n\n_ = plot_posterior(model_fit)"
  },
  {
    "objectID": "foundational-concepts-in-probability-and-statistics/statistical-inference.html#footnotes",
    "href": "foundational-concepts-in-probability-and-statistics/statistical-inference.html#footnotes",
    "title": "Statistical Inference",
    "section": "Footnotes",
    "text": "Footnotes\n\n\nWe won’t use it here, but the pronoun relative frequencies visualized here are derived from pronoun_count below using {p: c / pronoun_count.total() for p, c in pronoun_count.items()}.↩︎\nI’m using \\(\\mathcal{L}_\\mathbf{x}(\\pi)\\) to emphasize that \\(\\mathcal{L}\\) is parameterized by \\(\\mathbf{x}\\). Another notation, which means the same thing but which I think is initially more confusing, is \\(\\mathcal{L}(\\pi \\mid \\mathbf{x})\\). I will return to why this notation makes sense in a second.↩︎\nIf you’re not familiar with this direct proportionality notation, \\(x \\propto y\\) just means that there is some non-zero constant \\(k\\) such that \\(x = ky\\).↩︎\nNote that this implies that \\(p(\\theta \\mid \\mathbf{x}) \\propto p(\\theta, \\mathbf{x})\\).↩︎\nNote, again, the use of a pipe for the PMF of \\(X\\) and a semicolon for the PDF of \\(\\Pi\\). This notation is used to denote that \\(\\pi\\) is the value of some random variable, whereas \\(\\alpha\\) and \\(\\beta\\) are given by some oracle–namely, us.↩︎\nIndeed, we’ve already seen another: it turns out that the negative binomial distribution can be viewed as a compound probability distribution.↩︎\nNote that each proportion \\(p \\in \\left\\{\\frac{1}{N}, \\frac{2}{N}, \\ldots, 1\\right\\}\\) corresponds to \\({N \\choose pN}\\) possible \\(\\mathbf{x}\\)s but that the log-evidence must be the same for each such \\(\\mathbf{x}\\) if the likelihood is Bernoulli.↩︎\nTo develop additional intuition for why this reweighting is necessary: consider a very simple case where we are trying to approximate the expectation \\(\\mathbb{E}[U] = \\int u\\,p(u)\\,\\mathrm{d}u\\) of a uniform random variable \\(U \\sim \\mathcal{U}(0, 1)\\) with importance sampling. (We would never do this–not least because we can easily compute the expected value analytically–but it is useful for illustrating the point.) And suppose we chose as our proposal distribution \\(U'_k \\sim \\text{Beta}(2, 1)\\). If we didn’t reweight by \\(\\frac{\\mathcal{U}(u'_k; 0, 1)}{\\text{Beta}(u'_k; 2, 1)} = \\frac{1}{\\text{Beta}(u'_k; 2, 1)}\\), we’d end with the expectation of \\(U'_k\\), which is \\(\\frac{2}{3}\\), not \\(U\\), which is \\(\\frac{1}{2}\\)!↩︎\nAnother good alternative would be a \\(\\text{LogitNormal}\\left(\\text{logit}^{-1}(\\pi_{k-1}), \\sigma\\right)\\), where \\(\\sigma\\) is analogous to \\(\\delta\\) above, or a \\(\\text{Beta}(\\nu\\pi_{k-1}, \\nu(1-\\pi_{k-1}))\\), where \\(\\nu\\) is (inversely) analogous to \\(\\delta\\).↩︎\nIn light of the amount of data we have, the prior is not going to matter very much.↩︎\nSTAN also provides an anologous transformed data block for transformations of the input data.↩︎\nThere is an additional available kind of program block: the useful and important generated quantities block, which I will not cover here.↩︎\nThe indexation on the latter is implicit in STAN’s vectorization conventions.↩︎"
  },
  {
    "objectID": "island-effects/index.html",
    "href": "island-effects/index.html",
    "title": "Overview",
    "section": "",
    "text": "Reading\n\n\n\nData: Sprouse et al. (2016) on variation in the strength of island effects on acceptabiliy judgments. We will use the data collected for that paper, which can be found here, in this module.\nTheory: Sprouse (2018) on the relationship between acceptability and grammaticality. We will specifically be concerned with his discussion in Section 3.3 of what apparent gradience in acceptability implies about discreteness v. continuity in grammatical representations.\n\n\nIn this first module of the course, we are going to focus on minimally extending standard statistical models used in analyzing acceptability judgments–generalized linear mixed effects models–in order to probe the nature of the grammatical representations that drive acceptability judgments. We will consider two possibilities discussed by Sprouse (2018): (a) that the grammatical representations underlying acceptability judgments are discrete (or categorical); and (b) the grammatical representations are continuous (or gradient).\nThe basic recipe, which we will repeat through the course, is (i) to define two or more (families of) models–in this case, one that assumes that the grammatical representation is categorical and another that assumes the representation is gradient; (ii) to fit both models to the data from some acceptability judgment data–in this case, to the data collected by Sprouse et al. (2016); and (iii) to compare how well the two models fit the data, weighed against some measure of how parsimonious (or conversely, complex) each model is.\n\n\n\n\nReferences\n\nSprouse, Jon. 2018. “Acceptability Judgments and Grammaticality, Prospects and Challenges.” In The Impact of the Chomskyan Revolution in Linguistics, edited by Norbert Hornstein, Howard Lasnik, Pritty Patel-Grosz, and Charles Yang, 195–224. Berlin, Boston: De Gruyter Mouton. https://doi.org/doi:10.1515/9781501506925-199.\n\n\nSprouse, Jon, Ivano Caponigro, Ciro Greco, and Carlo Cecchetto. 2016. “Experimental Syntax and the Variation of Island Effects in English and Italian.” Natural Language & Linguistic Theory 34: 307–44. https://doi.org/10.1007/s11049-015-9286-8."
  },
  {
    "objectID": "island-effects/model-definition.html",
    "href": "island-effects/model-definition.html",
    "title": "Model definition",
    "section": "",
    "text": "Sprouse (2018, 213–15) discusses how one might test particular theories that assume categorical or gradient grammatical representations: compute the predicted acceptability from an implementation of such theories and then using those predictions as predictors in some model. He notes (p. 212) that, in deriving these predictions, it is important to consider five distinct (families of) phenomena that are likely, in combination, to modulate acceptability:\nHe goes on to suggest that “…we can minimize the impact of the effects of typical processing, plausibility and real-world knowledge, task effects, and possibly even unexplored factors by using experimentally-defined phenomena…and focusing on the effect size of the difference between them.”\nSprouse et al. (2016, 308) implement this idea in their data collection using “…a factorial design to isolate island effects over and above other factors (such as processing complexity) that may influence acceptability judgments (Sprouse 2007, 2011; Sprouse and Almeida 2012)”. But even if we can minimize the impact of these effects, Sprouse (2018, 214) points to two main obstacles to doing this comparison in practice: (a) “theories of typical sentence processing are an active area of research”; and (b) “there is little to no research on the atypical sentence processing that arises for ungrammatical sentences”.\nThese are serious obstacles for anyone interested in comparing particular theories that assume categorical or gradient grammatical representations; and we should of course strive to test as specific a theory as we can. But if we are interested instead in comparing how well any theory that assumes a particular kind of grammatical representation can explain acceptability judgments relevant to a particular phenomenon, we can take a different tack.\nThe basic idea will be to ask, for a particular family of theories–in the current case, whether categorical or gradient representations comprise grammars–how we can represent the effect on acceptability that any possible analysis under that theory could produce. We will then search among those analyses for those that fit the data best. We can then compare the families of theories by quantitatively measuring the fit of those theories’ best analyses to the data and–as a measure of parsimony–weighing that fit against how many such best analyses there are. The more constrained the family of theories, the fewer such best analyses it will have and thus the more parsimonious we will consider it.\nTo illustrate how we might implement a comparison between categorical and gradient grammars, we’ll use the data collected by Sprouse et al. (2016) in their Experiments 1 and 3, which investigated English island effects across a range of island types and dependency types."
  },
  {
    "objectID": "island-effects/model-definition.html#sprouse-et-als-2016-experiments-1-and-3",
    "href": "island-effects/model-definition.html#sprouse-et-als-2016-experiments-1-and-3",
    "title": "Model definition",
    "section": "Sprouse et al’s (2016) Experiments 1 and 3",
    "text": "Sprouse et al’s (2016) Experiments 1 and 3\nFirst, let’s load the data.\n\n\nDownload the data\n!wget https://www.jonsprouse.com/data/NLLT2016/SCGC.data.zip -P data/\n!unzip data/SCGC.data.zip -d data/\n\n\n\nfrom pandas import DataFrame, read_csv\n\ndef load_data(fname: str, remove_fillers: bool = False) -&gt; DataFrame:\n    \"\"\"Load Sprouse et al.'s (2016) data\n    \n    Parameters\n    ----------\n    fname\n        The filename of the data\n    remove_fillers\n        Whether to remove the fillers\n    \n    Returns\n    -------\n    data\n        The data\n    \"\"\"\n    # read the raw data skipping comment rows at the beginning\n    data = read_csv(fname, skiprows=5)\n    \n    # remove NaN judgments\n    data = data.query(\"~judgment.isnull()\")\n    \n    # fill NaNs\n    for col in [\"dependency\", \"structure\", \"distance\", \"island\"]:\n        data.loc[:,col] = data[col].fillna(\"filler\")\n    \n    # remove fillers\n    if remove_fillers:\n        data = data.query(\"dependency != 'filler'\")\n    \n    return data\n\n\n\nLoad the Experiments 1 and 3 data\nimport os\nfrom pandas import concat\n\ndata_dir = \"./data/SCGC.data/\"\n\ndata_exp1 = load_data(os.path.join(data_dir, \"Experiment 1 results - English.csv\"))\ndata_exp3 = load_data(os.path.join(data_dir, \"Experiment 3 results - English D-linking.csv\"))\n\ndata_exp3[\"dependency\"] = data_exp3.dependency.map({\n    \"WH\": \"DlinkedWH\", \"RC\": \"DlinkedRC\", \"filler\": \"filler\"\n})\n\ndata_exp1[\"exp\"] = 1\ndata_exp3[\"exp\"] = 3\n\ndata = concat([data_exp1, data_exp3])\n\ndata\n\n\n\n\n\n\n\n\n\nsubject\nsurvey\norder\njudgment\nitem\ncondition\nzscores\ndependency\nisland\nstructure\ndistance\nexp\n\n\n\n\n0\nA15EZJS1DROADE\n1.3\n13\n1.0\nF.1.UG\nF.1.UG\n-2.677619\nfiller\nfiller\nfiller\nfiller\n1\n\n\n1\nA1948V3S82RNX5\n1.2\n17\n1.0\nF.1.UG\nF.1.UG\n-1.188567\nfiller\nfiller\nfiller\nfiller\n1\n\n\n2\nA19P3BIPW6UMQ9\n1.2\n17\n2.0\nF.1.UG\nF.1.UG\n-1.012792\nfiller\nfiller\nfiller\nfiller\n1\n\n\n3\nA1BZDH1VJJK97V\n1.1\n26\n2.0\nF.1.UG\nF.1.UG\n-1.148201\nfiller\nfiller\nfiller\nfiller\n1\n\n\n4\nA1CE3DR200PXSS\n1.2\n17\n1.0\nF.1.UG\nF.1.UG\n-1.285708\nfiller\nfiller\nfiller\nfiller\n1\n\n\n...\n...\n...\n...\n...\n...\n...\n...\n...\n...\n...\n...\n...\n\n\n10651\nAU0LVWJM11NLF\n1.1\n51\n4.0\nWH.whe.non.sh.01\nWH.whe.non.sh\n-0.234321\nDlinkedWH\nWH\nnon\nshort\n3\n\n\n10652\nAWSCR2O3D6T87\n1.4\n29\n7.0\nWH.whe.non.sh.08\nWH.whe.non.sh\n0.777625\nDlinkedWH\nWH\nnon\nshort\n3\n\n\n10653\nAWSCR2O3D6T87\n1.4\n32\n7.0\nWH.whe.non.sh.04\nWH.whe.non.sh\n0.777625\nDlinkedWH\nWH\nnon\nshort\n3\n\n\n10654\nAZCV8JQ2NEFN8\n1.4\n29\n7.0\nWH.whe.non.sh.08\nWH.whe.non.sh\n0.699702\nDlinkedWH\nWH\nnon\nshort\n3\n\n\n10655\nAZCV8JQ2NEFN8\n1.4\n32\n7.0\nWH.whe.non.sh.04\nWH.whe.non.sh\n0.699702\nDlinkedWH\nWH\nnon\nshort\n3\n\n\n\n\n21195 rows × 12 columns\n\n\n\n\nData collection instrument\nJudgments in Sprouse et al.’s data were collected using a 7-point Likert scale–i.e. ordinal scale.\n\n\nPlotting code\nfrom numpy import arange\nfrom matplotlib.pyplot import subplot\n\n\nax = subplot()\nax.hist(data.judgment, bins=arange(1, 9), rwidth=0.5, align=\"left\")\n\nax.set_title(\"Likert scale acceptability judgments (Experiments 1 and 3)\")\nax.set_xlabel(\"Likert scale acceptability judgment\")\n_ = ax.set_ylabel(\"Count\")\n\n\n\n\n\n\n\nScale normalization\nSprouse et al. also provide by-subject \\(z\\)-scores, which are the quantities they use as dependent variables in their analyses because they are believed to “[eliminate] certain kinds of scale biases between participants” (Sprouse et al. 2016, 325). These scores are derived by mapping ordinal scale ratings \\(y_n\\) to \\(\\frac{y_n - \\text{mean}\\left(\\left\\{y_n \\mid s = \\text{subj}(n)\\right\\}\\right)}{\\text{sd}\\left(\\left\\{y_n \\mid s = \\text{subj}(n)\\right\\}\\right)}\\), where \\(\\text{subj}\\) maps a response index to a subject identifier. We can recompute these values and see that they have high correlation with those that Sprouse et al. compute–presumably differing only up to floating point error.\n\nfrom numpy import round, corrcoef\nfrom pandas import Series\n\ndef zscore(responses: Series) -&gt; Series:\n    \"\"\"z-score responses\n    \n    Parameters\n    ----------\n    responses\n        The responses to z-score\n        \n    Returns\n    -------\n    zscores\n        The z-scored responses\n    \"\"\"\n    return (responses - responses.mean()) / responses.std()\n\nzscores_exp1 = data.groupby(\"subject\").judgment.transform(zscore)\n\nround(corrcoef(data.zscores, zscores_exp1)[1,0], 3)\n\n0.998\n\n\nWe will not be using these \\(z\\)-scores for our implementation. Instead, we will the raw ordinal responses using an ordinal logit model–described below. This approach will be taken throughout the course on principled grounds: any preprocessing of a dependent variable necessarily introduces potentially important changes in the structure of that variable that can have downstream effects on statistical inference.2 Nonetheless, for the purposes of plotting, \\(z\\)-scores can be useful, and we will use them below.\n\n\nDesign\nAs mentioned above, the dataset has a factorial design, manipulating four factors:\n\nstructure (non-island, island): whether or not the sentence contains a purported island violation\ndistance (short, long): whether the number of words between the filler (i.e. the WH word) and the gap (i.e. the position the word is associated with) is small or large\nisland type (ADJunct island, NP island, SUBject island, WHether island): if structure = island and distance = long, what the island violation type is\ndependency type (WH main clause question, RC: relative clause, DlinkedWH main clause D-linked question, DlinkedRC: D-linked relative clause): whether the sentence is a WH interrogative or contains a relative clause and what the filler is (D-linked or not)\n\n    The first two factors–whose manipulation for island=WH and dependency=WH can be seen in (1-4), corresponding to items WH.whe.non.sh.05, WH.whe.isl.sh.05, WH.whe.non.lg.05, WH.whe.isl.lg.05–are intended to provide a way of estimating how acceptability is modulated by processing load–e.g. induced by having to keep a filler in memory longer before it can be linked with its gap–while keeping the meaning as constant as possible.3\n\nWho thinks that Aaron bought the house? (structure=non, distance=short)\nWho wonders whether Aaron bought the house? (structure=island, distance=short)\nWhat does the agent think that Aaron bought? (structure=non, distance=long)\nWhat does the agent wonder whether Aaron bought? (structure=island, distance=long)\n\nSprouse et al. (2016) want this manipulation so that they can pull apart the contribution of what Sprouse (2018, 210) refers to as “the ‘grammar’ component of the theory of acceptability”, which he takes to be “something like an error signal from the structure-building component of the sentence processor” from world knowledge/typicality as well as “the ‘sentence processing’ component of the theory of acceptability judgments”, which he takes to be “everything that isn’t structure-building: parsing strategies for various types of ambiguity resolution, the complexity that arises from ambiguity resolution (e.g., surprisal, Hale 2001; Levy 2008), the complexity that arises from dependency processing (Gibson 1998), the complexity that arises from working memory operations more generally (Lewis and Vasishth 2005; McElree, Foraker, and Dyer 2003), and many others components.”\nWe can get a quick intuition for what these effects might look like by looking at the average \\(z\\)-scores for the above items.\n\nfactors = [\n    \"island\", \"dependency\",\n    \"distance\", \"structure\" \n]\n\nitem05_ids = [\n    \"WH.whe.non.sh.05\", \"WH.whe.non.lg.05\", \n    \"WH.whe.isl.sh.05\", \"WH.whe.isl.lg.05\"\n]\n\ndata_exp1_item05 = data_exp1[data_exp1.item.isin(item05_ids)]\ndata_exp1_item05_means = data_exp1_item05.groupby(factors[2:] + [\"item\"])[[\"zscores\"]].mean()\n\ndata_exp1_item05_means.sort_values(\"zscores\", ascending=False).reset_index()\n\n\n\n\n\n\n\n\ndistance\nstructure\nitem\nzscores\n\n\n\n\n0\nshort\nnon\nWH.whe.non.sh.05\n0.956486\n\n\n1\nshort\nisland\nWH.whe.isl.sh.05\n0.944204\n\n\n2\nlong\nnon\nWH.whe.non.lg.05\n0.857106\n\n\n3\nlong\nisland\nWH.whe.isl.lg.05\n-0.427193\n\n\n\n\n\n\n\nWe can see (i) that the distance=short items (1-2) are judged to be about as acceptable as each other on average; (ii) that both distance=long items (3-4) are judged worse than both distance=short items on average; and (iii) that the distance=long, structure=island item (4), which is the one that has a dependency crossing an island boundary, is substantially worse than all the others on average. It is this sort of difference of differences that Sprouse et al. (2016) take as evidence for the influence of a “grammar” component over and above a “sentence processing” component–in the senses put forth by Sprouse (2018).\n\ndata_test = data.query(\"distance != 'filler'\")\n\ndata_test_itemmeans = data_test.groupby(\n    factors + [\"item\"]\n)[[\"zscores\"]].mean().reset_index()\n\n\n\nPlotting code\nfrom seaborn import FacetGrid, boxplot\n\np = FacetGrid(\n    data_test_itemmeans,\n    col=\"island\", row=\"dependency\"\n)\n\np.map(\n    boxplot, \n    \"distance\", \"zscores\", \"structure\", \n    order=[\"short\", \"long\"], \n    hue_order=[\"non\", \"island\"]\n)\n\np.set_ylabels(r\"Mean $z$-score of item\")\n\n_ = p.add_legend()\n\n\n\n\n\nIn asking whether these data provide evidence for a categorical grammar or a gradient grammar, we are effectively asking whether the pattern of difference of differences across combinations of dependency type and island type are better explained as the product of a representation of the combination \\(d\\) and \\(i\\)–i.e. the interaction of \\(d\\) and \\(i\\)–that assumes a categorical grammar or a gradient grammar.\n\ndata_test_itemmeans[\"itemnum\"] = data_test_itemmeans.item.map(\n    lambda x: x.split(\".\")[-1]\n)\n\ndata_test_itemmeans_cast = data_test_itemmeans.pivot_table(\n    index=[\"island\", \"dependency\", \"itemnum\"], \n    columns=[\"distance\", \"structure\"], \n    values=\"zscores\"\n)\n\nshort_diffs = data_test_itemmeans_cast.short.non -\\\n              data_test_itemmeans_cast.short.island\nlong_diffs = data_test_itemmeans_cast.long.non -\\\n             data_test_itemmeans_cast.long.island\n\ndiffs_of_diffs = (short_diffs - long_diffs).reset_index()\n\n\n\nPlotting code\np = boxplot(\n    diffs_of_diffs,\n    x=\"island\", y=0, hue=\"dependency\"\n)\n\n_ = p.set_ylabel(\"Difference of differences by item\")\n\n\n\n\n\nIn terms solely of fit, the answer here must be that the best-fitting gradient model will always fit the data as well or better than the analogous best-fitting categorical model. (We’ll see why shortly.) The question is whether, once we consider the improved parsimony of the categorical family, the best-fitting categorical model is comparable to the gradient model."
  },
  {
    "objectID": "island-effects/model-definition.html#formalizing-the-model-families",
    "href": "island-effects/model-definition.html#formalizing-the-model-families",
    "title": "Model definition",
    "section": "Formalizing the model families",
    "text": "Formalizing the model families\nLet’s consider what a categorical family is committed to in contrast to a gradient model. To do this, we need to back up and talk about how to model what Sprouse (2018, 197) refers to as “the continuum of acceptability”. We’ll assume that the acceptability \\(\\alpha_i\\) of some natural language string \\(i\\) can be represented by a real value (viewed as an element of an ordered field). This assumption is relatively uncontroversial: even those researchers committed to some form of discreteness in the “grammar” component of the theory of acceptability assume the existence of processes that should be modeled as gradient–at least as a first pass.\nThe first thing we need to do is to figure out how to model the relationship between \\(\\alpha_i\\)–however it is determined–and the set of judgments for that item \\(\\{y_n \\mid \\text{item}(n) = i\\}\\), where \\(\\text{item}\\) maps a response index to an item identifier. We’ll refer to this component of our model as our linking model. How we define this model is important because we do not directly observe the true acceptability represented by \\(\\alpha_i\\); we must estimate it from the responses.4\n\nThe Ordinal Logit Linking Model\nTo model ordinal responses \\(y_n\\), we will use an ordered logit model, which will be parameterized by our real-valued \\(\\alpha_{\\text{item}(n)}\\) and \\(K \\equiv r_\\text{max} - r_\\text{min}\\) cutpoints \\(\\mathbf{c}_{\\text{subj}(n)}\\) specific to each subject, where \\(r_\\text{max}\\) is the highest rating–7 in the Sprouse et al. data–and \\(r_\\text{min}\\) is the lowest–1 in the Sprouse et al. data.5 Let’s assume that \\(c_{sr_\\text{min}} \\sim \\mathcal{N}(0, \\sigma^2_\\text{cutpoint})\\) and that:\n\\[C_{s(r+1)} - C_{sr} \\sim \\text{Gamma}(2, 1)\\]\nWe want a distribution–like the gamma distribution–on distances between cutpoints that has only positive support so that we can enforce a strict ordering assumption: \\(\\forall r \\in \\{r_\\text{min}, \\ldots, r_\\text{max}\\}: c_{sr} &lt; c_{s(r+1)}\\). Any distribution with positive support would work here.\n\nfrom scipy.stats import gamma\n\n# uses the k, theta (scale) parameterization\ncutpoint_distance_dist = gamma(2.0, scale=1.)\n\n\n\nCode\nfrom numpy import mgrid\nfrom matplotlib.pyplot import subplot\n\nax = subplot()\n\ndistance = mgrid[0:10:0.01]\ndensity = cutpoint_distance_dist.pdf(distance)\n\nax.plot(distance, density)\n\nax.set_title(r\"PDF of the cutpoint distance prior distribution\")\nax.set_xlabel(r\"Distance\")\n_ = ax.set_ylabel(\"Density\")\n\n\n\n\n\nThe reason why we want a strict ordering assumption is that we’re going to use these \\(K=6\\) cutpoints to define \\(K+1 = 7\\) bins \\(\\{(-\\infty, c_{sr_\\text{min}}), (c_{sr_\\text{min}}, c_{sr_\\text{min} + 1}), \\ldots, (c_{sr_\\text{max}-2}, c_{sr_\\text{max}-1}), (c_{sr_\\text{max}-1}, \\infty)\\}\\) of contiguous real values. Each bin will correspond to a possible rating \\(\\{r_\\text{min}, \\ldots, r_\\text{max}\\}\\).\n\nfrom numpy import sort\nfrom numpy.random import seed\n\nseed(302984)\n\nn_resp_levels = 7\n\njumps = cutpoint_distance_dist.rvs(n_resp_levels-1)\ncutpoints = jumps.cumsum()\ncutpoints -= cutpoints.min()\n\ncutpoints\n\narray([ 0.        ,  3.01509045,  5.3033194 ,  8.44799298, 13.82188812,\n       14.96264086])\n\n\n\n\nCode\nfrom numpy import ndarray\n\ndef plot_cutpoints(ax, cutpoints: ndarray, ymin: float = 0, ymax: float = 1) -&gt; None:\n    ax.axis(xmin=cutpoints[0] - 2, xmax=cutpoints[-1] + 2)\n    ax.vlines(cutpoints, ymin, ymax, colors=\"C1\")\n    \n    height = (ymax + ymin) / 2\n    \n    for i, c_i in enumerate(cutpoints):\n        if i:\n            _ = ax.annotate(\n                i + 1,\n                xy=((c_i + cutpoints[i-1]) / 2, height), xycoords='data',\n                horizontalalignment='center', verticalalignment='top',\n                fontsize=20,\n            )\n        elif not i:\n            _ = ax.annotate(\n                i + 1,\n                xy=((c_i - 1), height), xycoords='data',\n                horizontalalignment='center', verticalalignment='top',\n                fontsize=20\n            )\n            \n    _ = ax.annotate(\n        cutpoints.shape[0] + 1,\n        xy=((cutpoints[-1] + 1), height), xycoords='data',\n        horizontalalignment='center', verticalalignment='top',\n        fontsize=20\n    )\n\nax = subplot()\n    \nplot_cutpoints(ax, cutpoints)\n\nax.set_title(\"Binning of acceptability space\")\n_ = ax.set_xlabel(\"Acceptability\")\n\n\n\n\n\nWhat makes this model an ordered logistic model is its assumptions about how randomness in the responses comes about: namely, that participants produce the ordinal value \\(y_n\\) corresponding to the bin in which \\(\\alpha_{\\text{item}(n)} + \\epsilon_n\\) falls, where \\(\\epsilon_n \\sim \\text{Logistic}(0, 1)\\) is an error term distributed logistic. That is, the PDF of \\(\\epsilon_n\\) is:\n\\[f(x) = \\frac {e^{-x}}{\\left(1+e^{-x}\\right)^{2}}\\]\n\nfrom scipy.stats import logistic\n\n\n\nCode\nax = subplot()\n\nlogodds = mgrid[-5:5:0.01]\ndensity = logistic(0, 1).pdf(mgrid[-5:5:0.01])\n\nax.plot(logodds, density)\n\nax.set_title(r\"PDF of the standard logistic distribution\")\nax.set_xlabel(r\"Error\")\n_ = ax.set_ylabel(\"Density\")\n\n\n\n\n\nFor instance, if we simulate multiple draws for a \\(Y_n\\) whose \\(\\alpha_{\\text{item}(n)}\\) is in the center of the bin for response 4 and whose cutpoints \\(\\mathbf{c}_{\\text{subj}(n)}\\) are the ones we sampled above…\n\nseed(3029)\n\nmu_n = (cutpoints[3] + cutpoints[2]) / 2\n\nsamples = mu_n + logistic(0, 1).rvs(10_000)\n\n\n\nCode\nax = subplot()\n\nplot_cutpoints(ax, cutpoints, 0, 0.25)\n\n_ = ax.hist(samples, density=True, bins=20)\n\n\n\n\n\n…we obtain a frequency distribution that peaks at 4, since \\(\\alpha_{\\text{item}(n)} + \\epsilon_n\\) has most density within \\((c_{{\\text{subj}(n)}, 3}, c_{{\\text{subj}(n)}, 4})\\), but where there are a fair number of 3s and 5s, since those value have a fair amount of density.\n\nresponses = (samples[:,None] &gt; cutpoints[None,:]).sum(axis=1) + 1\n\n\n\nCode\nax = subplot()\n_ = ax.hist(responses, bins=arange(1, 9), rwidth=0.5, align=\"left\", density=True)\n\nax.set_title(r\"Relative frequency of response in simulation\")\nax.set_xlabel(r\"Response\")\n_ = ax.set_ylabel(\"Relative Frequency\")\n\n\n\n\n\nWe will express that \\(Y_n\\) is distributed ordered logistic with:\n\\[\n\\begin{align*}\nY_n &\\sim \\text{OrderedLogistic}\\left(\\alpha_{\\text{item}(n)}, \\mathbf{c}_{\\text{subj}(n)}\\right)\\\\\n\\end{align*}\n\\]\nTo make the notation a bit less complex moving forward, I’m going to write \\(\\alpha_i\\)–rather than \\(\\alpha_{\\text{item}(n)}\\) and \\(\\mathbf{c}_s\\)–rather than \\(\\mathbf{c}_{\\text{subj}(n)}\\)–leaving implicit the statements “where \\(i \\equiv \\text{item}(n)\\)” and “where \\(s \\equiv \\text{subj}(n)\\)”.\nThe way of thinking about \\(Y_n\\) described above effectively defines the PMF in terms of an expectation of \\(\\epsilon_n\\)–which, remember, is a random variable. To make things a bit simpler, let’s assume we’re working with the extended reals, so we can say that \\(c_{s(r_\\text{min}-1)} = -\\infty\\) and that \\(c_{sr_\\text{max}} = +\\infty\\) for all subjects \\(s\\). Then, for \\(r \\in \\{r_\\text{min}, \\ldots, r_\\text{max}\\}\\):\n\\[\\begin{align*}\n\\mathbb{P}(Y_n=r\\mid\\alpha_i, \\mathbf{c}_s) &= \\int_\\mathbb{R} f(e)\\mathbb{P}(Y_n=r\\mid\\alpha_i, \\mathbf{c}_s,e) \\,\\mathrm{d}e\\\\\n&= \\int_\\mathbb{R} f(e)\\mathbb{P}\\left(\\alpha_i+e \\in (c_{s(r-1)}, c_{sr})\\right)\\,\\mathrm{d}e\\\\\n&= \\int_\\mathbb{R} f(e)\\mathbb{P}\\left(e \\in (c_{s(r-1)} - \\alpha_i, c_{sr} - \\alpha_i)\\right)\\\\\n&= \\mathbb{E}\\left[\\mathbb{P}\\left(\\epsilon_n \\in (c_{s(r-1)} - \\alpha_i, c_{sr} - \\alpha_i)\\right)\\right]\\\\\n\\end{align*}\\]\nThis expression looks a bit hairy, but it turns out that we can express the PMF of \\(Y_n\\) analytically. To do this, we first need to note that, for a fixed \\(e\\):\n\\[\\begin{align*}\n\\mathbb{P}\\left(e \\in (c_{s(r-1)} - \\alpha_i, c_{sr} - \\alpha_i)\\right) &= F(c_{sr} - \\alpha_i) - F(c_{s(r-1)} - \\alpha_i)\\\\\n&= \\text{logit}^{-1}(c_{sr} - \\alpha_i) - \\text{logit}^{-1}(c_{s(r-1)} - \\alpha_i)\n\\end{align*}\\]\nwhere \\(F(x) = \\text{logit}^{-1}(x) = \\frac{1}{1 + \\exp(-x)}\\) is the CDF of the standard logistic distribution.\nThis function is also often called the inverse logit, logistic, or expit function. It can be viewed as mapping a log-odds to a probability. You may be familiar with it in the context of logistic regression, where we model the conditional expectation \\(\\text{logit}\\;\\mathbb{E}[Y \\mid \\mathbf{X}]\\) of a Bernoulli random variable \\(Y\\)–e.g. a variable indicating whether a sentence is acceptable or unacceptable–given some predictors \\(\\mathbf{X}\\)–e.g. dependency, island, structure, and distance from Sprouse et al.’s dataset.\n\nfrom scipy.special import expit\n\n\n\nCode\nax = subplot()\n\nlogodds = mgrid[-5:5:0.01]\nprobability = expit(mgrid[-5:5:0.01])\n\nax.plot(logodds, probability)\n\nax.set_title(r\"The logistic function $\\frac{1}{1+\\exp(-x)}$\")\nax.set_xlabel(r\"Log-odds $\\log\\frac{p}{1-p}$\")\n_ = ax.set_ylabel(\"Probability\")\n\n\n\n\n\nThus, \\(\\mathbb{E}\\left[\\mathbb{P}\\left(\\epsilon_n \\in (c_{s(r-1)} - \\alpha_i, c_{sr} - \\alpha_i)\\right)\\right]\\) is actually the expected value of a constant \\(\\text{logit}^{-1}(c_{sr} - \\alpha_i) - \\text{logit}^{-1}(c_{s(r-1)} - \\alpha_i)\\) (relative to \\(\\epsilon_n\\)), which means that, for \\(r \\in \\{r_\\text{min}, \\ldots, r_\\text{max}\\}\\):\n\\[\\mathbb{P}(Y_n=r\\mid\\alpha_i, \\mathbf{c}_s) = \\text{logit}^{-1}(c_{sr} - \\alpha_i) - \\text{logit}^{-1}(c_{s(r-1)} - \\alpha_i)\\]\nMore explicitly, the PMF of \\(Y_n\\) is:\n\\[\\mathbb{P}(Y_n = r \\mid \\alpha_i, \\mathbf{c}_s) = \\begin{cases}\n\\text{logit}^{-1}(c_{sr} - \\alpha_i) & \\text{if } r = r_\\text{min}\\\\\n\\text{logit}^{-1}(c_{sr} - \\alpha_i) - \\text{logit}^{-1}(c_{s(r-1)} - \\alpha_i) & \\text{if } r_\\text{min} &lt; r &lt; r_\\text{max}\\\\\n1 - \\text{logit}^{-1}(c_{s(r-1)} - \\alpha_i) & \\text{if } r = r_\\text{max}\\\\\n0 & \\text{otherwise}\\\\\n\\end{cases}\\]\nWe commonly compute this by first computing the CDF and then taking the cumulative difference.\n\\[\\mathbb{P}(Y_n \\leq r \\mid \\alpha_i, \\mathbf{c}_s) = \\begin{cases}\n0 & \\text{if } r &lt; r_\\text{min}\\\\\n\\text{logit}^{-1}(c_{sr} - \\alpha_i) & \\text{if } r &lt; r_\\text{max}\\\\\n1 & \\text{if } r \\geq r_\\text{max}\\\\\n\\end{cases}\\]\n\nfrom numpy import concatenate, ones, zeros, arange\n\ndef ordinal_pmf(mu: ndarray, cutpoints: ndarray):\n    n, = mu.shape\n    \n    cdf = expit(cutpoints[None,:] - mu[:,None])\n    \n    return concatenate([cdf, ones([n, 1])], axis=1) -\\\n           concatenate([zeros([n, 1]), cdf], axis=1)\n\nIf we compute the PMF for the value of \\(\\alpha_i\\) we simulated against above, we get something very close to the relative frequency distribution we observed before.\n\n\nCode\nax = subplot()\n\nax.bar(arange(1, 8), ordinal_pmf(mu_n*ones(1), cutpoints)[0], 0.5)\n\nax.set_title(r\"Probability mass function of ordinal logistic\")\nax.set_xlabel(r\"Response\")\n_ = ax.set_ylabel(\"Probability\")\n\n\n\n\n\nIf we sweep the value of \\(\\alpha_i\\) relative to the set of cutpoints we sampled above, then plot the resulting PMF, the ordinal constraints on the distribution become apparent. Also notice that for 6, which has a very small bin relative to the other responses, no setting of \\(\\alpha_i\\) gives it a very high probability.\n\n\nCode\nfrom matplotlib.pyplot import subplots\n\npmfs = ordinal_pmf(arange(-1, 20), cutpoints)\n\nfig, ax = subplots(figsize=(6, 8))\nimg = ax.imshow(pmfs)\nax.set_xticks(arange(7), arange(1,8))\nax.set_xlabel(\"Rating\")\nax.set_ylabel(\"Value\")\nimg.set_cmap('binary')\n_ = fig.colorbar(img, label=\"Probability\")\n\n\n\n\n\nThus, the ordinal logistic model allows us to capture preference or dispreference for a particular response level by manipulating the bin size associated with that level. This manipulation of the bin size is how we model subjects’ preferences for particular bins. For instance, the subject we simulated above has a fairly strong dispreference for using a 6 response, which is a consequence of how small the bin for 6 is and which can be seen in the fact that no row of the above plot is particularly dark for 6.\nThere are many ways to set up the distribution on subject-specific cutpoints. In the current context, we are going to assume a general set of cutpoints \\(\\bar{\\mathbf{c}}\\) that subjects rigidly shift left or right via a subject-specific intercept term \\(\\rho^\\text{subj}_s \\sim \\mathcal{N}\\left(0, \\sigma^2_\\text{subj}\\right)\\). That is, \\(\\mathbf{c}_s \\equiv \\bar{\\mathbf{c}} + \\rho^\\text{subj}_s\\)–holding all assumptions above fixed. This assumption is fairly standard and the default in libraries like ordinal. An alternative assumption, which we will make later in the course, is that that subjects’ cutpoints \\(\\mathbf{c}_s\\) can freely vary–allowing different subjects to have different preferences for different ordinal responses.\n\n\nA First (Poor) Approximation\nGiven the above setup, the simplest model we might define is one in which every item is equally acceptable and all the variability in responses is modeled by the error term and variability in how subjects bin the continuum of acceptability. That is, there is a single \\(\\mu\\) such that \\(\\alpha_i \\equiv \\mu\\). This model is effectively a random effects model, where the subject-specific intercepts \\(\\rho^\\text{subj}_s\\) are the random effects.\nWe’ll use STAN to implement this model. You can find a very brief introduction to STAN here in the course notes on statistical inference.\nThe data block needs to specify information about both the responses and the subjects.\ndata {\n  int&lt;lower=0&gt; N_resp;                           // number of responses\n  int&lt;lower=0&gt; N_subj;                           // number of subjects\n  int&lt;lower=2&gt; N_resp_levels;                    // number of possible likert scale acceptability judgment responses\n  int&lt;lower=1,upper=N_subj&gt; subj[N_resp];        // subject who gave response n\n  int&lt;lower=1,upper=N_resp_levels&gt; resp[N_resp]; // likert scale acceptability judgment responses \n}\nWe will have three (sets of) parameters:\n\nthe fixed representation of acceptability for every item acc_mean\nthe standard deviation of the subject random intercepts subj_intercept_std and the subj_intercepts themselves\nthe distances (“jumps”) between cutpoints\n\nparameters {\n  real acc_mean;                                 // mean acceptability\n  real&lt;lower=0&gt; subj_intercept_std;              // subject random intercept standard deviation\n  vector[N_subj] subj_intercept;                 // subject random intercepts\n  vector&lt;lower=0&gt;[N_resp_levels-2] jumps;        // the cutpoint distances\n}\nTo enforce the prior on the distances between cutpoints–henceforth referred to as jumps–it will be useful to define them in transformed parameters.\ntransformed parameters {\n  // compute the cutpoints by taking a cumulative sum\n  vector[N_resp_levels-1] cutpoints;\n\n  for (c in 1:(N_resp_levels-1)) {\n    if (c == 1) {\n      cutpoints[c] = 0.0;\n    } else {\n      cutpoints[c] = cutpoints[c-1] + jumps[c-1];\n    }\n  }\n}\nThe model block then encodes the distributional assumptions about the subject random intercepts and cutpoints mentioned above, as well as the assumption that resp[n] \\(\\sim \\text{OrderedLogistic}(\\) mu, cutpoints + subj_intercept[subj[n]]\\()\\).\nmodel {\n  // sample the subject intercepts\n  subj_intercept ~ normal(0, subj_intercept_std);\n\n  // sample the cutpoints distances\n  for (j in 1:(N_resp_levels-2))\n    jumps[j] ~ gamma(2,1);\n\n  // sample the responses\n  for (n in 1:N_resp)\n    resp[n] ~ ordered_logistic(\n      acc_mean, cutpoints + subj_intercept[subj[n]]\n    );\n}\nFinally, the generated quantities block computes the log-likelihood of each datapoint (log_lik), which is necessary for model comparison later.\n\ngenerated quantities {\n  // compute the log-likelihood\n  real log_lik[N_resp];\n  \n  for (n in 1:N_resp)\n    log_lik[n] = ordered_logistic_lpmf(\n      resp[n] | acc_mean, cutpoints + subj_intercept[subj[n]]\n    );\n}\n\n\nA Second (Slightly Less Poor) Approximation\nA better version of this model adds item-specific random intercepts \\(\\rho^\\text{item}_i \\sim \\mathcal{N}\\left(0, \\sigma^2_\\text{item}\\right)\\) that allow us to better predict the distribution of responses for a particular item. The main change is to define the distribution on responses as:\n\\[Y_n \\sim \\text{OrderedLogistic}\\left(\\alpha_{\\text{item}(n)} + \\rho^\\text{item}_{\\text{item}(n)}, \\mathbf{c} + \\rho^\\text{subj}_{\\text{subj}(n)}\\right)\\]\nTo implement this model, we need to add item identity information to the data block.\ndata {\n  int&lt;lower=0&gt; N_resp;                           // number of responses\n  int&lt;lower=0&gt; N_item;                           // number of items\n  int&lt;lower=0&gt; N_subj;                           // number of subjects\n  int&lt;lower=2&gt; N_resp_levels;                    // number of possible likert scale acceptability judgment responses\n  int&lt;lower=1,upper=N_item&gt; item[N_resp];        // item corresponding to response n\n  int&lt;lower=1,upper=N_subj&gt; subj[N_resp];        // subject who gave response n\n  int&lt;lower=1,upper=N_resp_levels&gt; resp[N_resp]; // likert scale acceptability judgment responses\n}\nIn the parameters block, we need to add the item random intercepts (item_intercept = \\(\\boldsymbol\\rho\\)) as well as a parameter for their prior (item_intercept_std = \\(\\sigma_\\text{item}\\)).\nparameters {\n  real acc_mean;                                 // the mean acceptability\n  real&lt;lower=0&gt; item_intercept_std;              // the item random intercept standard deviation\n  vector[N_item] item_intercept;                 // the item random intercepts\n  real&lt;lower=0&gt; subj_intercept_std;              // subject random intercept standard deviation\n  vector[N_subj] subj_intercept;                 // subject random intercepts\n  vector&lt;lower=0&gt;[N_resp_levels-2] jumps;        // the cutpoint distances\n}\n\ntransformed parameters {\nIn the transformed parameters block, we will define \\(\\alpha_i = \\mu + \\rho_i\\).\n  vector[N_resp_levels-1] cutpoints;\n\n  for (c in 1:(N_resp_levels-1)) {\n    if (c == 1) {\n      cutpoints[c] = 0.0;\n    } else {\n      cutpoints[c] = cutpoints[c-1] + jumps[c-1];\n    }\n  }\n\n  // compute the item-specific acceptability\n  real acc[N_item];\n\n  for (i in 1:N_item)\n    acc[i] = acc_mean + item_intercept[i];\n}\nAnd finally, in the model block, we state that item_intercept \\(\\sim \\mathcal{N}(0,\\) item_intercept_std \\(^2)\\) and we update the response distribution to reflect the addition of item-specific random intercepts.\nmodel {  \n  // sample the item intercepts\n  item_intercept ~ normal(0, item_intercept_std);\n\n  // sample the subject intercepts\n  subj_intercept ~ normal(0, subj_intercept_std);\n\n  // sample the cutpoints distances\n  for (j in 1:(N_resp_levels-2))\n    jumps[j] ~ gamma(2,1);\n\n  // sample the responses\n  for (n in 1:N_resp)\n    resp[n] ~ ordered_logistic(\n      acc[item[n]], cutpoints + subj_intercept[subj[n]]\n    );\n}\nAs we will see, this model will fit the data much better. But it’s still not a very good model. The reason is that, since the random intercepts are item-specific, the model cannot predict responses to items it hasn’t seen before particularly well. If we have an estimate for a particular participant’s cutpoints, the best we can do is to compute the probability of a particular response by marginalizing over the item-specific random intercepts.\n\\[\\begin{align*}\n\\mathbb{P}(Y_n = r \\mid \\mu, \\mathbf{c}, \\rho^\\text{subj}_{\\text{subj}(n)}; \\sigma_\\text{item}) &= \\int_\\mathbb{R} \\mathbb{P}(Y_n = r \\mid \\mu, \\rho)p(\\rho; \\sigma_\\text{item})\\,\\mathrm{d}\\rho\\\\\n&= \\int_\\mathbb{R} \\text{OrderedLogistic}\\left(r \\mid \\mu + \\rho, \\mathbf{c}_{\\text{subj}(n)}\\right)\\mathcal{N}\\left(\\rho; 0, \\sigma_\\text{item}^2\\right)\\,\\mathrm{d}\\rho\\\\\n\\end{align*}\\]\n\n\nAdding Grammar and Processing Effects\nTo improve the predictive power of our models, we need to add information about properties of the items to our models–e.g. dependency, island, structure, and distance. How we add this information will correspond to the family of models we are fitting. All of these models will be mixed effects models or extensions thereof, so what I want to do now is to define a general mixed effects model. All our models from here on out in this module will use this model or some slight modification of it. To keep with our theme of focusing on the acceptability \\(\\alpha_i\\) of a particular item \\(i\\), I’m going to describe the mixed effects models we use in a slightly non-standard way that will hopefully make clear why we are using them.\nWe are going to define \\(\\alpha_i\\) in terms of some fixed effects \\(\\mathbf{x}^\\text{fixed}_i\\)–in our case, some subset and/or combination of dependency, island, structure, and distance–as well as item random effects \\(\\mathbf{x}^\\text{item}_i\\). We will assume that the fixed effects \\(\\mathbf{x}^\\text{fixed}_i\\) and \\(\\mathbf{x}^\\text{item}_i\\) use a dummy coding of the variables of interest and that the first element of both is always \\(1\\). The latter assumption allows us to easily represent an intercept term.\nWe will say that \\(\\alpha_i\\) is a linear function of \\(\\mathbf{x}^\\text{fixed}_i\\) and \\(\\mathbf{x}^\\text{by-item}_i\\):\n\\[\\alpha_i = \\mathbf{x}^\\text{fixed}_i \\cdot \\boldsymbol\\beta + \\mathbf{x}^\\text{item}_i \\cdot \\boldsymbol\\rho^\\text{item}_i\\]\nwhere \\(\\boldsymbol\\beta \\in \\mathbb{R}^{K_\\text{fixed}}\\) is the fixed effect coefficients and \\(\\boldsymbol\\rho^\\text{item}_i \\in \\mathbb{R}^{K_\\text{item}}\\) are the by-item random effect coefficients. The former (\\(\\boldsymbol\\beta\\)) track the effect on acceptability that a particular aspect of the linguistic expression has in general, while the latter (\\(\\boldsymbol\\rho^\\text{item}_i\\)) track the way in which a particular item modulates these effects. In our case, we will keep the by-item random effect coefficients very simple: they will effectively just be equivalent to the random intercept above–i.e. \\(\\mathbf{x}^\\text{item}_i = [1]\\) and thus \\(\\rho_{i1}\\) is an intercept.\nIn addition to acceptability \\(\\alpha_{\\text{item}(n)}\\), we will assume that the distribution of response \\(Y_n\\) is sensitive to ways that particular participants’ perception of acceptability is modulated by particular properties \\(\\mathbf{x}^\\text{subj}_{\\text{item}(n)}\\) of the item they are rating. As for the fixed effects, \\(\\mathbf{x}^\\text{subj}_{\\text{item}(n)}\\) will be some subset and/or combination of dependency, island, structure, and distance.\nWe model this modulation in terms of by-subject random effect coefficients \\(\\boldsymbol\\rho^\\text{item}_s \\in \\mathbb{R}^{K_\\text{subj}}\\), defining the distribution of response \\(Y_n\\) as:\n\\[Y_n \\sim \\text{OrderedLogistic}\\left(\\alpha_{\\text{item}(n)} + \\mathbf{x}^\\text{subj}_{\\text{item}(n)} \\cdot \\boldsymbol\\rho^\\text{subj}_{\\text{subj}(n)}, \\mathbf{c}\\right)\\]\nThis form looks slightly different than what we used for the first two models, but we could just as well have written it:\n\\[Y_n \\sim \\text{OrderedLogistic}\\left(\\alpha_{\\text{item}(n)}, \\mathbf{c} + \\mathbf{x}^\\text{subj}_{\\text{item}(n)} \\cdot \\boldsymbol\\rho^\\text{subj}_{\\text{subj}(n)}\\right)\\]\nThe main difference is that the signs invert: a shift up of the cutpoints is equivalent to a shift down in the acceptability.\nTo implement a mixed effects model in STAN, we need to add a few things to the data block, specifying how many fixed effect, by-item, and by-subject effects there are and what they are.\ndata {\n  int&lt;lower=0&gt; N_resp;                           // number of responses\n  int&lt;lower=0&gt; N_item;                           // number of items\n  int&lt;lower=0&gt; N_subj;                           // number of subjects\n  int&lt;lower=2&gt; N_resp_levels;                    // number of possible likert scale acceptability judgment responses\n  int&lt;lower=1&gt; N_fixed;                          // number of fixed predictors\n  int&lt;lower=1&gt; N_by_subj;                        // number of random by-subject predictors\n  int&lt;lower=1&gt; N_by_item;                        // number of random by-item predictors\n  matrix[N_resp,N_fixed] fixed_predictors;       // predictors (length and dependency type) including intercept\n  matrix[N_resp,N_by_item] by_item_predictors;   // by-item predictors (length and dependency type) including intercept\n  matrix[N_resp,N_by_subj] by_subj_predictors;   // by-subject predictors (length and dependency type) including intercept\n  int&lt;lower=1,upper=N_item&gt; item[N_resp];        // item corresponding to response n\n  int&lt;lower=1,upper=N_subj&gt; subj[N_resp];        // subject who gave response n\n  int&lt;lower=1,upper=N_resp_levels&gt; resp[N_resp]; // likert scale acceptability judgment responses\n}\nWe additionally need to add to the parameters block a representation of the fixed effect and augment the by-item and by-subject effects from scalars to vectors, with a corresponding change to covariance matrices.\nparameters {\n  vector[N_fixed] fixed_coefs;                   // fixed coefficients (including intercept)\n  cov_matrix[N_by_item] item_cov;                // item random effects covariance  \n  cov_matrix[N_by_subj] subj_cov;                // subject random effects covariance            \n  vector[N_by_item] by_item_coefs[N_item];       // by-item coefficients (including intercept)\n  vector[N_by_subj] by_subj_coefs[N_subj];       // by-subject coefficients (including intercept)\n  vector&lt;lower=0&gt;[N_resp_levels-2] jumps;        // cutpoint distances for each subject\n}\nRather than defining the acceptability by item in the transformed parameters block, it makes more sense to define it for each response, since both item and subject modulate it.\ntransformed parameters {\n  // compute the cutpoints by taking a cumulative sum\n  vector[N_resp_levels-1] cutpoints;\n\n  for (c in 1:(N_resp_levels-1)) {\n    if (c == 1) {\n      cutpoints[c] = 0.0;\n    } else {\n      cutpoints[c] = cutpoints[c-1] + jumps[c-1];\n    }\n  }\n\n  // compute the acceptability\n  real acc[N_resp];\n\n  for (n in 1:N_resp) {\n    acc[n] = fixed_predictors[n] * fixed_coefs + \n             by_item_predictors[n] * by_item_coefs[item[n]] + \n             by_subj_predictors[n] * by_subj_coefs[subj[n]];\n  }\n}\nFinally, the main change in the model block is for handling the augmentation of the by-item and by-subject effects from scalars to vectors.\nmodel { \n  // initialize by-item random effects mean to 0\n  vector[N_by_item] item_mean = rep_vector(0.0, N_by_item);\n\n  // sample the item coefficients\n  for (i in 1:N_item)\n    by_item_coefs[i] ~ multi_normal(item_mean, item_cov);\n\n  // sample the cutpoints distances\n  for (j in 1:(N_resp_levels-2))\n    jumps[j] ~ gamma(2,1);\n  \n  // initialize by-subject random effects mean to 0\n  vector[N_by_subj] subj_mean = rep_vector(0.0, N_by_subj);\n\n  // sample the subject coefficients\n  for (s in 1:N_subj)\n    by_subj_coefs[s] ~ multi_normal(subj_mean, subj_cov);\n\n  // sample the responses\n  for (n in 1:N_resp) {\n    resp[n] ~ ordered_logistic(acc[n], cutpoints);\n  }\n}\n\nNo Grammatical Effects\nThe first model we will interested in within this general framework is one that accounts for the effects of structure (non-island v. island) and distance (short v. long) for each combination of island type (ADJunct island, NP island, SUBject island, WHether island) and dependency type (WH v. RC v. DlinkedWH v. DlinkedRC) but does not capture the crucial interaction between structure and distance for any of them. Using the R formula interface, this model would be judgment ~ (distance + structure) * island * dependency.\n\n\nAdding a Grammatical Representation\nThe second two models we will consider are also vanilla mixed effects models. The first assumes that all island violations have the same effect on acceptability: judgment ~ (distance + structure) * island * dependency + distance:structure. This model is consistent with the assumption that all islands are ungrammatical to the same extent and that that ungrammaticality yields the same decrement along the acceptability continuum–equal to whatever the coefficient \\(\\beta_{\\text{distance} \\times \\text{structure}}\\) corresponding to the interaction term is. This assumption is technically consistent with either a categorical or gradient grammar, though in the latter case, the gradience would do no work–i.e. it is effectively a perverse sort of discrete grammar. I will refer to this as the minimal interaction model.\nThe second of these models assumes that all island violations have potentially distinct effects on acceptability: judgment ~ distance * structure * island * dependency. That is, there is a potentially distinct effect for every combination of island type and dependency type and there is no necessary relation among those effects. This assumption is consistent only with a gradient grammar, since any pair of effects could be arbitrarily similar but distinct. I will refer to this as the maximal interaction model.\n\n\nMaking the space of grammatical representations more granular\nThe minimal and maximal interaction models are extremes along a conceptual continuum that ignore two possibilities: (i) some combinations of island type and dependency type may not result in either categorical or gradient ungrammaticality; and (ii) the effects of island violations may cluster. A potential example of possibility (i) is that some of the differences of differences we observed above (duplicated below) are very near 0 on average. A potential example of (ii) is that the medians for many of these differences of differences are very near each other.\n\n\nPlotting code\np = boxplot(\n    diffs_of_diffs,\n    x=\"island\", y=0, hue=\"dependency\"\n)\n\n_ = p.set_ylabel(\"Difference of differences by item\")\n\n\n\n\n\nTo capture both ideas, we can add some additional structure into how we represent the interaction effects in our mixed effects models. The basic idea is to assume that each pairing of an island type \\(i\\) and a dependency type \\(d\\) might be associated with a discrete indicator \\(g_{di} \\in \\{0, \\ldots, G\\}\\) of its level of ungrammaticality (Chomsky 1965, 1986), where \\(G\\) is the maximal number of grammatical violations associated with any structure. We then define the island effect associated with island type \\(i\\) and a dependency type \\(d\\) in terms of \\(g_{di} \\sim \\text{Categorical}(\\boldsymbol{\\gamma})\\).\nDepending on (i) how large \\(G\\) is and (ii) how we constrain the relationship between the effect and \\(g_{di}\\), we get models that live between the extremes of our minimal and maximal interaction models. We will consider two ways that \\(g_{di}\\) might determine the effect: either (a) increments of ungrammaticality come with constant penalty on the acceptability continuum \\(\\delta\\) and therefore the total decrement for \\(g_{di}\\) increments of ungrammaticality is \\(\\delta g_{di}\\); or (b) increments of ungrammaticality come with potentially variable penalties on the acceptability continuum \\(\\boldsymbol\\delta\\) and therefore the total decrement for \\(g_{di}\\) increments of ungrammaticality is \\(\\sum_{g' = 1}^{g_{di}} \\delta_{g'}\\), for some sequence of penalty term \\(\\boldsymbol\\delta\\). I will refer to the first as the constrained clustered mixed effects model and the second as the unconstrained clustered mixed effects model.\nIf \\(G = 1\\), the two models are equivalent, and we have a model that minimally augments our minimal interaction model with the ability to say that some island violations do not cause a decrement in acceptability. But when \\(G = 2\\), the models begin to pull apart, becoming more drastic as \\(G \\rightarrow \\infty\\).\nEither sort of model is technically consistent with a categorical or gradient grammar, insofar as the gradient grammar is willing to posit at least some amount of underlying discreteness. But as for the the minimal interaction model, associating at least the family of constrained clustered interaction models with a gradient grammar is potentially perverse: where would the equidistance in the acceptability decrements come from?\nTo implement the two clustered interaction models, we will add to the data block from the mixed effects model a specification of the number of grammaticality levels (N_grammaticality_levels\\(= G+1\\)) and the interactions we’re modeling.\ndata {\n  int&lt;lower=2&gt; N_grammaticality_levels;                   // number of grammaticality levels\n  int&lt;lower=2&gt; N_interactions;                            // number of interactions to model as discrete\n  int&lt;lower=0&gt; N_resp;                                    // number of responses\n  int&lt;lower=0&gt; N_subj;                                    // number of subjects\n  int&lt;lower=0&gt; N_item;                                    // number of items\n  int&lt;lower=2&gt; N_resp_levels;                             // number of possible likert scale acceptability judgment responses\n  int&lt;lower=1&gt; N_fixed;                                   // number of fixed predictors\n  int&lt;lower=1&gt; N_by_subj;                                 // number of random by-subject predictors\n  int&lt;lower=1&gt; N_by_item;                                 // number of random by-item predictors\n  matrix[N_resp,N_fixed] fixed_predictors;                // predictors (length and dependency type) including intercept\n  matrix[N_resp,N_by_subj] by_subj_predictors;            // by-subject predictors (length and dependency type) including intercept\n  matrix[N_resp,N_by_item] by_item_predictors;            // by-item predictors (length and dependency type) including intercept\n  int&lt;lower=1,upper=N_interactions&gt; interactions[N_resp]; // interactions to model as discrete \n  int&lt;lower=1,upper=N_subj&gt; subj[N_resp];                 // subject who gave response n\n  int&lt;lower=1,upper=N_item&gt; item[N_resp];                 // item corresponding to response n\n  int&lt;lower=1,upper=N_resp_levels&gt; resp[N_resp];          // likert scale acceptability judgment responses\n}\nTo the parameters block of the constrained clutered interaction model, we’ll add the penalty \\(\\delta\\) and a parameter gamma that representations the probability of each grammaticality level.\nparameters {\n  real&lt;upper=0&gt; penalty;                                  // grammaticality violation penalty\n  simplex[N_grammaticality_levels] gamma;                 // probabilities of grammaticality levels\n  vector[N_fixed] fixed_coefs;                            // fixed coefficients (including intercept)\n  cov_matrix[N_by_subj] subj_cov;                         // subject random effects covariance\n  cov_matrix[N_by_item] item_cov;                         // item random effects covariance              \n  vector[N_by_subj] by_subj_coefs[N_subj];                // by-subject coefficients (including intercept)\n  vector[N_by_item] by_item_coefs[N_item];                // by-item coefficients (including intercept)\n  vector&lt;lower=0&gt;[N_resp_levels-2] jumps;                 // cutpoint distances for each subject\n}\nAnalogously, to the parameters block of the unconstrained clutered interaction model, we’ll add N_grammaticality_levels\\(-1 = G\\) penaltys \\(\\boldsymbol\\delta\\) and an analogous gamma parameter.\nparameters {\n  vector&lt;upper=0&gt;[N_grammaticality_levels-1] penalty;     // grammaticality violation penalty\n  simplex[N_grammaticality_levels] gamma;                 // probabilities of grammaticality levels\n  vector[N_fixed] fixed_coefs;                            // fixed coefficients (including intercept)\n  cov_matrix[N_by_subj] subj_cov;                         // subject random effects covariance\n  cov_matrix[N_by_item] item_cov;                         // item random effects covariance              \n  vector[N_by_subj] by_subj_coefs[N_subj];                // by-subject coefficients (including intercept)\n  vector[N_by_item] by_item_coefs[N_item];                // by-item coefficients (including intercept)\n  vector&lt;lower=0&gt;[N_resp_levels-2] jumps;                 // cutpoint distances for each subject\n}\nTo compute the acceptability in the transformed parameters blocks, we do something similar to what we did for the mixed effects model. The main difference is that we need to track the acceptability under each assumed level of grammaticality.\nConstrained clustered mixed effects model\ntransformed parameters {\n  // compute the cutpoints by taking a cumulative sum\n  vector[N_resp_levels-1] cutpoints;\n\n  for (c in 1:(N_resp_levels-1)) {\n    if (c == 1) {\n      cutpoints[c] = 0.0;\n    } else {\n      cutpoints[c] = cutpoints[c-1] + jumps[c-1];\n    }\n  }\n\n  // compute the acceptability\n  real acc[N_resp,N_grammaticality_levels];\n  \n  for (n in 1:N_resp) {\n    for (g in 1:N_grammaticality_levels) {\n      acc[n,g] = fixed_predictors[n] * fixed_coefs + \n                by_subj_predictors[n] * by_subj_coefs[subj[n]] + \n                by_item_predictors[n] * by_item_coefs[item[n]] +\n                (g-1) * penalty;\n    }\n  }\n}\nUnconstrained clustered mixed effects model\ntransformed parameters {\n  // compute the cutpoints by taking a cumulative sum\n  vector[N_resp_levels-1] cutpoints;\n\n  for (c in 1:(N_resp_levels-1)) {\n    if (c == 1) {\n      cutpoints[c] = 0.0;\n    } else {\n      cutpoints[c] = cutpoints[c-1] + jumps[c-1];\n    }\n  }\n\n  // compute the decrement\n  vector[N_grammaticality_levels] decrement;\n\n  for (g in 1:N_grammaticality_levels) {\n    if (g == 1) {\n      decrement[g] = 0.0;\n    } else {\n      decrement[g] = decrement[g-1] + penalty[g-1];\n    }\n  }  \n\n  // compute the acceptability\n  real acc[N_resp,N_grammaticality_levels];\n  \n  for (n in 1:N_resp) {\n    for (g in 1:N_grammaticality_levels) {\n      acc[n,g] = fixed_predictors[n] * fixed_coefs + \n                by_subj_predictors[n] * by_subj_coefs[subj[n]] + \n                by_item_predictors[n] * by_item_coefs[item[n]] +\n                decrement[g];\n    }\n  }\n}\nThe reason need to do this is that, because we are assuming that each pairing of island type and dependency type has a particular grammaticality that’s shared across all items that instantiate that pair. This assumption implies that responses are only independent conditioned on the grammaticality associated with that structure.\n\\[\\begin{align*}\np(\\mathbf{y} \\mid \\boldsymbol\\gamma, \\delta, \\mathbf{c}) &= \\prod_{d,i} \\sum_{g'} \\mathbb{P}(g_{di} = g'; \\boldsymbol\\gamma, \\delta, \\mathbf{c}) \\prod_{n: \\text{struct}(n) = \\langle d, i \\rangle} p(y_n \\mid g_{di} = g'; \\boldsymbol\\gamma, d, \\mathbf{c})\n\\end{align*}\\]\nThis assumption is represented in the model block:\nmodel {\n  // sample penalty\n  penalty ~ normal(0, 1);\n\n  // initialize by-subject random effects mean to 0\n  vector[N_by_subj] subj_mean;\n  subj_mean = rep_vector(0.0, N_by_subj);\n  \n  // initialize by-item random effects mean to 0\n  vector[N_by_item] item_mean;\n  item_mean = rep_vector(0.0, N_by_item);\n  \n  // sample the cutpoints distances\n  for (j in 1:(N_resp_levels-2))\n    jumps[j] ~ gamma(2,1);\n  \n  // sample the subject intercepts\n  for (s in 1:N_subj)\n    by_subj_coefs[s] ~ multi_normal(subj_mean, subj_cov);\n  \n  // sample the item intercepts\n  for (i in 1:N_item)\n    by_item_coefs[i] ~ multi_normal(item_mean, item_cov);\n\n  // declare log-likelihood of responses corresponding to a particular interaction\n  // assuming a particular grammaticality level\n  real theta[N_interactions,N_grammaticality_levels];\n  \n  // initialize log-likelihood of responses corresponding to a particular interaction\n  // to the log-prior on the membership probabilities\n  for (i in 1:N_interactions) {\n    for (g in 1:N_grammaticality_levels) {\n      theta[i,g] = log(gamma[g]);\n    }\n  }\n  \n  // add the log-likelihood of each response corresponding to a particular interaction\n  // assuming a particular grammaticality level \n  for (n in 1:N_resp) {\n    for (g in 1:N_grammaticality_levels) {\n      theta[interactions[n],g] += ordered_logistic_lpmf(\n        resp[n] | acc[n,g], cutpoints\n      );\n    }\n  }\n  \n  // compute log-likelihood of all responses corresponding to a particular interaction\n  // by summing over the likelihood assuming a particular grammaticality level\n  for (i in 1:N_interactions) {\n    target += log_sum_exp(theta[i]);\n  }\n}\nThis assumption also affects how we compute metrics for model comparison, which I’ll come back to in the next section. I’ll just say now that, to handle this, we need to compute the membership probabilities for each pairing of island type and dependency type–i.e. the posterior probability of the grammaticality levels given the responses to items instantiating that pairing.\n\\[\\mathbb{P}(g_{di} = g' \\mid \\{y_n: \\text{struct}(n) = \\langle d, i \\rangle\\}) \\propto p(\\{y_n: \\text{struct}(n) = \\langle d, i \\rangle\\} \\mid g_{di} = g')\\mathbb{P}(g_{di} = g')\\]\nWe do this computation in the generated quantities block.\ngenerated quantities {  \n  // declare log-likelihood of all responses corresponding to a particular interaction\n  // by summing over the likelihood assuming a particular grammaticality level\n  real log_lik_grouped[N_interactions];\n  \n  // compute log-likelihood of all responses corresponding to a particular interaction\n  // by summing over the likelihood assuming a particular grammaticality level\n  for (i in 1:N_interactions) {\n    log_lik_grouped[i] = log_sum_exp(theta[i]);\n  }\n\n  // declare probability of particular grammaticality level for each interaction\n  real log_membership[N_interactions,N_grammaticality_levels];\n  \n  // compute probability of particular grammaticality level for each interaction\n  // by dividing the likelihood under that level by the sum over likelihoods\n  // across levels\n  for (i in 1:N_interactions) {\n    for (g in 1:N_grammaticality_levels) {\n      log_membership[i,g] = theta[i,g] - log_lik_grouped[i];\n    }\n  }\n\n  // declare the log-likelihood (really, log-pointwise predictive density) of \n  // each data point\n  real log_lik[N_resp];\n  \n  // compute the log-likelihood (really, log-pointwise predictive density) of \n  // each data point by weighting the likelihood assuming a particular \n  // grammaticality level by the membership probability of that level \n  // for the interaction corresponding to the data point.\n  for (n in 1:N_resp) {\n    real log_lik_by_level[N_grammaticality_levels];\n    for (g in 1:N_grammaticality_levels) {\n      log_lik_by_level[g] = log_membership[interactions[n],g] + \n                            ordered_logistic_lpmf(resp[n] | acc[n,g], cutpoints);\n    }\n    log_lik[n] = log_sum_exp(log_lik_by_level);\n  }\n}"
  },
  {
    "objectID": "island-effects/model-definition.html#summing-up",
    "href": "island-effects/model-definition.html#summing-up",
    "title": "Model definition",
    "section": "Summing Up",
    "text": "Summing Up\nRemember that we’re interested in the question of how, for a particular family of theories, we can represent the effect on acceptability that any possible analysis under that theory could produce. We defined a range of theories with different levels of expressivity, and now what we need to do is to search among analyses that can be expressed in those theories for those that fit the data best. Once we have those analyses, we can then compare the families of theories by quantitatively measuring the fit of those theories’ best analyses to the data and–as a measure of parsimony–weighing that fit against how many such best analyses there are. We will do this in the next section."
  },
  {
    "objectID": "island-effects/model-definition.html#footnotes",
    "href": "island-effects/model-definition.html#footnotes",
    "title": "Model definition",
    "section": "Footnotes",
    "text": "Footnotes\n\n\nSprouse (2018, 213) notes one idea for such a component: “…participants might be implicitly comparing violation sentences to the minimally different grammatical sentences that have the same meanings…[and] that acceptability judgments are impacted by the similarity/dissimilarity between the violation sentence and the grammatical counterpart.”↩︎\nIn discussing the introduction of the magnitude estimation task by (Stevens 1957), Sprouse (2018, 199) suggests that Likert scale tasks assume “…that participants treat the intervals between the response points as equal, but provides no mechanism to guarantee that.” This suggestion is not quite right: a model that links the acceptability continuum (to use the Sprouse’s terminology) to the Likert scale ratings may assume that response points correspond to intervals of the acceptability continuum that are of equal size; but it need not. For instance, an ordinal logit model–the kind of linking model we use below–can make the assumption that these intervals are of equal size, but most of the time, we use such a model because we don’t want to make that assumption.↩︎\nIt’s important to note that when distance=short and structure=island, the dependency does not cross into an island. It’s merely the case that there is an island in the sentence.↩︎\nAs Sprouse (2018, 196) notes, “[l]inking hypotheses are rarely amenable to direct investigation, so progress can only be measured by the success of the theory that results from the linking hypothesis plus the empirically collected data.”↩︎\nIt is often the case that analyses will assume a shared set of cutpoints for all subjects. This assumption fails to model potential variability in how subjects use the ordinal response scale.↩︎"
  },
  {
    "objectID": "island-effects/model-fitting-and-comparison.html",
    "href": "island-effects/model-fitting-and-comparison.html",
    "title": "Model Fitting and Comparison",
    "section": "",
    "text": "Load Sprouse et al.’s Experiments 1 and 3\nimport os\nfrom pandas import DataFrame, read_csv, concat\n\ndef load_data(fname: str, remove_fillers: bool = False) -&gt; DataFrame:\n    \"\"\"Load Sprouse et al.'s (2016) data\n    \n    Parameters\n    ----------\n    fname\n        The filename of the data\n    remove_fillers\n        Whether to remove the fillers\n    \n    Returns\n    -------\n    data\n        The data\n    \"\"\"\n    # read the raw data skipping comment rows at the beginning\n    data = read_csv(fname, skiprows=5)\n    \n    # remove NaN judgments\n    data = data.query(\"~judgment.isnull()\")\n    \n    # fill NaNs\n    for col in [\"dependency\", \"structure\", \"distance\", \"island\"]:\n        data.loc[:,col] = data[col].fillna(\"filler\")\n    \n    # remove fillers\n    if remove_fillers:\n        data = data.query(\"dependency != 'filler'\")\n    \n    return data\n\ndata_dir = \"./data/SCGC.data/\"\n\ndata_exp1_test = load_data(\n    os.path.join(data_dir, \"Experiment 1 results - English.csv\"),\n    remove_fillers=True\n)\ndata_exp3_test = load_data(\n    os.path.join(data_dir, \"Experiment 3 results - English D-linking.csv\"),\n    remove_fillers=True\n)\n\ndata_exp3_test[\"dependency\"] = data_exp3_test.dependency.map({\n    \"WH\": \"DlinkedWH\", \"RC\": \"DlinkedRC\", \"filler\": \"filler\"\n})\n\ndata_exp1_test[\"exp\"] = 1\ndata_exp3_test[\"exp\"] = 3\n\ndata_test = concat([data_exp1_test, data_exp3_test])\nSilence STAN logger\nimport logging\nlogger = logging.getLogger('cmdstanpy')\nlogger.addHandler(logging.NullHandler())\nlogger.propagate = False\nlogger.setLevel(logging.CRITICAL)\nWe will fit our model families using Markov chain Monte Carlo (MCMC) as implemented in STAN. As I mentioned in the last section, you can find a very brief introduction to MCMC in STAN here in the course notes on statistical inference.\nTo compare our model families, we want to quantitatively measure the fit of those theories’ best analyses to the data (identified by a particular parameterization) and–as a measure of parsimony–weight that fit against how many such best analyses there are. The more constrained the family of theories, the fewer such best analyses it will have and thus the more parsimonious we will consider it. A common way to implement this comparison is using an information criterion.\nMost information criteria attempt to estimate (a family of) models’ performance on data it was not fit to (Gelman, Hwang, and Vehtari 2014). They have have two components: a measure of the model’s fit to the data–usually the log-likelihood of the data–and a measure of the complexity of the family of models. Model complexity can be computed from a point estimate (the maximum likelihood estimate) directly in terms of the number of parameters in the model family–as in the Akaike Information Criterion (AIC) or the Bayesian Information Criterion–or in terms of variability in the likelihood conditioning on samples from the posterior–as in the Deviance Information Criterion (DIC) and the Watanabe-Akaike (or Widely Applicable) Information Criterion (WAIC). The rough idea behind using the latter is that–more expressive models will show more variability in the likelihood for a particular observation, since there are more good analyses under the model due to its flexibility. The information criterion is then a combination of the measure of fit and the measure of complexity.\nWe will use Pareto smoothed importance sampling leave-one-out cross-validation (PSIS-LOO), which is a gold-standard for information criteria (Vehtari, Gelman, and Gabry 2017). This criterion attempts to estimate a model’s performance on responses it was not fit to using importance sampling–a basic version of which we covered here in the course notes on statistical inference."
  },
  {
    "objectID": "island-effects/model-fitting-and-comparison.html#an-initial-fit",
    "href": "island-effects/model-fitting-and-comparison.html#an-initial-fit",
    "title": "Model Fitting and Comparison",
    "section": "An initial fit",
    "text": "An initial fit\nTo get started, let’s fit our intercept-only model using the cmdstanpy interface to STAN. We’ll start by defining how to map (or hash) columns of our data to indices. We’ll use this for hashing subject identifiers here and item identifiers later.\n\nfrom numpy import ndarray\nfrom pandas import Series\n\ndef hash_series(series: Series, indexation: int=1) -&gt; tuple[ndarray, ndarray]:\n    \"\"\"Hash a series to numeric codes\n    \n    Parameters\n    ----------\n    column\n        The series to hash\n    index\n        The starting index (defaults to 1)\n    \"\"\"\n    # enforce 0- or 1-indexation\n    if indexation not in [0, 1]:\n        raise ValueError(\"Must choose either 0- or 1-indexation.\")\n    \n    # convert the series to a category\n    category_series = series.astype(\"category\")\n    \n    # get the hash\n    hash_map = category_series.cat.categories.values\n    \n    # map to one-indexed codes\n    hashed_series = (category_series.cat.codes + indexation).values\n    \n    return hash_map, hashed_series\n\nWe then need to define how to construct data for input to our STAN model from the data collected by (Sprouse et al. 2016).\n\ndef construct_intercept_only_model_data(data: DataFrame) -&gt; dict:\n    subj_hash_map, subj_hashed = hash_series(data.subject)\n    \n    return {\n        \"N_resp\": data.shape[0],\n        \"N_subj\": subj_hash_map.shape[0],\n        \"N_resp_levels\": 7,\n        \"subj\": subj_hashed,\n        \"resp\": data.judgment.astype(int).values\n    }\n\nThe output of this function must exactly match our data block (and it does).\ndata {\n  int&lt;lower=0&gt; N_resp;                           // number of responses\n  int&lt;lower=0&gt; N_subj;                           // number of subjects\n  int&lt;lower=2&gt; N_resp_levels;                    // number of possible likert scale acceptability judgment responses\n  int&lt;lower=1,upper=N_subj&gt; subj[N_resp];        // subject who gave response n\n  int&lt;lower=1,upper=N_resp_levels&gt; resp[N_resp]; // likert scale acceptability judgment responses \n}\nNext, we will define a function that constructs the data, compiles the model, and fits it.\n\nimport arviz\nfrom arviz import InferenceData\nfrom cmdstanpy import CmdStanModel\n\ndef fit_intercept_only_model(data: DataFrame) -&gt; InferenceData:\n    model_path = \"models/intercept-only-model/intercept-only-model.stan\"\n    model = CmdStanModel(stan_file=model_path)\n    model_data = construct_intercept_only_model_data(data_test)\n    model_fit = model.sample(data=model_data)\n    \n    return arviz.from_cmdstanpy(model_fit)\n\n\nintercept_only_model_fit = fit_intercept_only_model(data_test)\n\n\n\n\n\n\n\n\n\n\n\n\n\n                                                                                                                                                                                                                                                                                                                                \n\n\nWe can peak at the posterior distribution over the intercept term (acc_mean) and the cutpoints. We see that the intercept term falls just about at the cutpoint between the 4 and 5 bins.\n\n\nPlotting code\nfrom arviz import plot_forest\n\n_ = plot_forest(\n    intercept_only_model_fit,\n    var_names=[\"acc_mean\", \"cutpoints\"],\n    combined=True,\n    figsize=(11.5, 3),\n)\n\n\n\n\n\nThis slight right bias makes sense in light of the distribution of responses in the data.1\n\n\nPlotting code\nfrom numpy import arange\nfrom matplotlib.pyplot import subplot\n\n\nax = subplot()\nax.hist(data_test.judgment, bins=arange(1, 9), rwidth=0.5, align=\"left\")\n\nax.set_title(\"Likert scale acceptability judgments (Experiments 1 and 3)\")\nax.set_xlabel(\"Likert scale acceptability judgment\")\n_ = ax.set_ylabel(\"Count\")\n\n\n\n\n\nIf we look at the jumps, we note that there tends to be a preference for ordinal response levels that are nearer to the edges of the scale–with the bin size for 4 (jumps[2]) almost half the bin size of 2 (jumps[0]) and 6 (jumps[4]). The relative size of subj_intercept_std indicates that subjects can differ in their left- or right-bias by approximately an entire ordinal response level.\n\n\nPlotting code\n_ = plot_forest(\n    intercept_only_model_fit,\n    var_names=[\"subj_intercept_std\", \"jumps\"],\n    combined=True,\n    figsize=(11.5, 2),\n)"
  },
  {
    "objectID": "island-effects/model-fitting-and-comparison.html#generalizing-to-other-models",
    "href": "island-effects/model-fitting-and-comparison.html#generalizing-to-other-models",
    "title": "Model Fitting and Comparison",
    "section": "Generalizing to other models",
    "text": "Generalizing to other models\nTo faciliate code reuse, we’ll develop an abstract base class (ABC) that defines our fitting procedure. The main things to focus on here are the IslandEffectsModel.construct_model_data and IslandEffectsModel.fit methods–the lattr of which is modeled on the sklearn API.\n\nimport cmdstanpy\nfrom abc import ABC\nfrom typing import Optional\nfrom dataclasses import dataclass\nfrom numpy import ndarray\nfrom cmdstanpy import CmdStanModel\n\n@dataclass\nclass IslandEffectsData:\n    N_resp: int            # number of responses\n    N_subj: int            # number of subjects\n    N_resp_levels: int     # number of possible likert scale acceptability judgment responses\n    subj: ndarray          # subject who gave response n\n    resp: ndarray          # likert scale acceptability judgment responses\n\nclass IslandEffectsModel(ABC):\n    \"\"\"An abstract base class for island effects models\"\"\"\n    \n    stan_file: str\n    data_class = IslandEffectsData\n    \n    def __init__(self):\n        self.model = CmdStanModel(stan_file=self.stan_file)\n        \n    def construct_model_data(self, data: DataFrame):\n        subj_hash_map, subj_hashed = hash_series(data.subject)\n    \n        return {\n            \"N_resp\": data.shape[0],\n            \"N_subj\": subj_hash_map.shape[0],\n            \"N_resp_levels\": 7,\n            \"subj\": subj_hashed,\n            \"resp\": data.judgment.astype(int).values\n        }\n\n    def _validate_data(self):\n        self.data_class(**self.model_data)\n\n    def fit(\n        self, \n        data: DataFrame,\n        save_dir: Optional[str] = None,\n        verbose: bool = False,\n        map_initialization: bool = True,\n        seed: int = 50493,\n        **kwargs\n    ) -&gt; InferenceData:\n        if verbose:\n            print(\"Constructing model data...\")\n            \n        self.model_data = self.construct_model_data(data)\n        \n        self._validate_data()\n        \n        if map_initialization:\n            if verbose:\n                print(\"Fitting model with MAP initialization...\")\n\n            map_estimate = self._compute_map_estimate(seed)\n            \n            if \"inits\" in kwargs:\n                # inits passed to fit() should override MAP\n                map_estimate.update(kwargs[\"inits\"])\n\n            kwargs[\"inits\"] = map_estimate\n        \n        elif verbose:\n            print(\"Fitting model...\")\n        \n        # sample from the posterior starting at the MAP\n        self.raw_model_fit = self.model.sample(\n            data=self.model_data,\n            **kwargs\n        )\n    \n        if save_dir is not None:\n            if verbose:\n                print(\"Saving model...\")\n\n            self.save(save_dir)\n            \n        if verbose:\n            print(\"Running MCMC diagnostics...\")\n            print()\n            print(self.diagnose())\n    \n        return self\n    \n    def _compute_map_estimate(self, seed: int):\n        # compute MAP fit\n        self.map_model_fit = self.model.optimize(\n            data=self.model_data,\n            seed=seed,\n            algorithm=\"lbfgs\",\n            tol_obj=1.\n        )\n\n        return self.map_model_fit.stan_variables()\n    \n    @property\n    def model_fit(self):\n        return arviz.from_cmdstanpy(self.raw_model_fit)\n    \n    def save(self, save_dir: str = \".\"):\n        self.raw_model_fit.save_csvfiles(save_dir)\n    \n    @classmethod\n    def from_csv(cls, path: str, **kwargs):\n        model = cls(**kwargs)\n        model.raw_model_fit = cmdstanpy.from_csv(path)\n        \n    def diagnose(self):\n        return self.raw_model_fit.diagnose()\n\nIt is then straightforward to simply specify the STAN model file as a class attribute of some subclass of this ABC.\n\nclass InterceptOnlyModel(IslandEffectsModel):\n    stan_file = \"models/intercept-only-model/intercept-only-model.stan\"\n\n\nintercept_only_model = InterceptOnlyModel()\nintercept_only_model.fit(data_test)\n\nWe can similarly specify and fit our item random effects model by (i) specifying the appropriate STAN file; and (ii) adding item information to the model’s data representation.\n\n@dataclass\nclass ItemRandomEffectsData(IslandEffectsData):\n    N_item: int              # number of items\n    item: ndarray            # item corresponding to response n\n\nclass ItemRandomEffectsModel(InterceptOnlyModel):\n    stan_file = \"models/item-random-effects-model/item-random-effects-model.stan\"\n    data_class = ItemRandomEffectsData\n    \n    def construct_model_data(self, data: DataFrame):\n        model_data = super().construct_model_data(data)\n    \n        self.item_hash_map, item_hashed = hash_series(data.item)\n\n        model_data.update({\n            \"N_item\": self.item_hash_map.shape[0],\n            \"item\": item_hashed\n        })\n        \n        return model_data\n\n\nitem_random_effects_model = ItemRandomEffectsModel()\nitem_random_effects_model.fit(data_test)\n\nThis model yields a similar posterior for acc_mean and cutpoints–though the posterior of acc_mean has higher variance.\n\n\nPlotting code\n_ = plot_forest(\n    item_random_effects_model.model_fit,\n    var_names=[\"acc_mean\", \"cutpoints\"],\n    combined=True,\n    figsize=(11.5, 3),\n)\n\n\n\n\n\nIt also yields a similar posterior distribution for subj_intercept_std and jumps. As we would expect, since it is the only way that differences among items can be explained, item_intercept_std is substantially larger than subj_intercept_std.\n\n\nPlotting code\n_ = plot_forest(\n    item_random_effects_model.model_fit,\n    var_names=[\"item_intercept_std\", \"subj_intercept_std\", \"jumps\"],\n    combined=True,\n    figsize=(11.5, 2.5),\n)\n\n\n\n\n\nIf we compare these two models using PSIS-LOO–measured in terms of expected log-pointwise density (ELPD)–we observe that (unsurprisingly) the item random effects model fits the data substantially better. This can be seen by the fact that its ELPD is substantially higher.\n\nfrom arviz import compare\n\ncompare_dict = {\n    \"Intercept-only model\": intercept_only_model.model_fit, \n    \"Item random effects model\": item_random_effects_model.model_fit\n}\n\nmodel_comparison = compare(compare_dict)\n\n\n\nPlotting code\nfrom arviz import plot_compare\n\n_ = plot_compare(model_comparison)\n\n\n\n\n\nIf we look at the item random intercept model’s \\(p_\\text{loo}\\), which is the measure of model complexity, we also see that it is substantially higher. But because the fit is so much better, when we combine \\(p_\\text{loo}\\) with the likelihood to derive ELPD\\(_\\text{loo}\\), the model is still preferred.\n\nmodel_comparison[[\"elpd_loo\", \"p_loo\", \"se\", \"elpd_diff\", \"dse\"]]\n\n\n\n\n\n\n\n\nelpd_loo\np_loo\nse\nelpd_diff\ndse\n\n\n\n\nItem random effects model\n-10793.713336\n568.829390\n61.709994\n0.000000\n0.00000\n\n\nIntercept-only model\n-13420.902081\n273.016164\n29.042153\n2627.188745\n57.07066\n\n\n\n\n\n\n\nAs we move forward, we will be particularly interested in elpd_diff and dse. elpd_diff tells us how much better the best model family in terms of PSIS-LOO is, and dse tells us the standard error of that difference. One important thing to note is that we can also compute a standard error of ELPD\\(_\\text{loo}\\) itself (se above), but dse is note computable from this quantity, since dse is computed pointwise.2\n\nMixed effects models\nTo implement our three vanilla mixed effects models–the no interaction model, minimal interaction model, and maximal interaction model–we will develop an generalization of the ABC that accepts formulae for the fixed effects, by-item effect, and by-subject effects.\n\n@dataclass\nclass MixedEffectsData(IslandEffectsData):\n    N_fixed: int                 # number of fixed predictors\n    fixed_predictors: ndarray    # predictors (length and dependency type) including intercept\n    N_item: int                  # number of items\n    N_by_item: int               # number of random by-item predictors\n    by_item_predictors: ndarray  # by-item predictors (length and dependency type) including intercept\n    N_by_subj: int               # number of random by-subject predictors\n    by_subj_predictors: ndarray  # by-subject predictors (length and dependency type) including intercept\n    item: ndarray                # item corresponding to response n\n\n\nimport patsy\nfrom numpy import array\n\nclass MixedEffectsModel(IslandEffectsModel):\n    stan_file = \"models/mixed-effects-model/mixed-effects-model.stan\"\n    data_class = MixedEffectsData\n    \n    def __init__(\n        self, fixed_formula: str, by_subj_formula: str, by_item_formula: str, \n    ):\n        super().__init__()\n        \n        self.fixed_formula = fixed_formula\n        self.by_subj_formula = by_subj_formula\n        self.by_item_formula = by_item_formula\n    \n    def construct_model_data(self, data: DataFrame):\n        model_data = super().construct_model_data(data)\n\n        self.fixed_predictors = patsy.dmatrix(\n            self.fixed_formula, data, return_type=\"dataframe\"\n        )\n        \n        self.by_subj_predictors = patsy.dmatrix(\n            self.by_subj_formula, data, return_type=\"dataframe\"\n        )\n        \n        self.by_item_predictors = patsy.dmatrix(\n            self.by_item_formula, data, return_type=\"dataframe\"\n        )\n        \n        self.item_hash_map, item_hashed = hash_series(data.item)\n        \n        model_data.update({\n            \"N_fixed\": self.fixed_predictors.shape[1],\n            \"fixed_predictors\": self.fixed_predictors.values,\n            \"N_by_subj\": self.by_subj_predictors.shape[1],\n            \"by_subj_predictors\": self.by_subj_predictors.values,\n            \"N_item\": self.item_hash_map.shape[0],\n            \"N_by_item\": self.by_item_predictors.shape[1],\n            \"by_item_predictors\": self.by_item_predictors.values,\n            \"item\": item_hashed\n        })\n        \n        return model_data\n    \n    def _compute_map_estimate(self, seed:int):\n        map_estimate = super()._compute_map_estimate(seed)\n        \n        for vname, v in map_estimate.items():\n            if \"cov\" in vname and not hasattr(v, \"shape\"):\n                map_estimate[vname] = array([[v]])\n                \n        return map_estimate\n\nWe can then fit the three models by specifying the formulae from the last section.\n\ndistance_levels = [\"short\", \"long\"]\nstructure_levels = [\"non\", \"island\"]\ndependency_levels = [\"WH\", \"RC\", \"DlinkedWH\", \"DlinkedRC\"]\nisland_levels = [\"WH\", \"SUB\", \"ADJ\", \"NP\"]\n\ndistance_term = \"C(distance, levels=distance_levels)\"\nstructure_term = \"C(structure, levels=structure_levels)\"\nisland_term = \"C(island, levels=island_levels)\"\ndependency_term = \"C(dependency, levels=dependency_levels)\"\n\nno_interaction_model = MixedEffectsModel(\n    fixed_formula=f\"~ ({distance_term} + {structure_term}) * {island_term} * {dependency_term}\",\n    by_subj_formula=f\"~ 1\",\n    by_item_formula=\"~ 1\",\n)\n\nno_interaction_model.fit(data_test)\n\n\ntwoway_interaction_model = MixedEffectsModel(\n    fixed_formula=no_interaction_model.fixed_formula + f\"+ {distance_term} * {structure_term}\",\n    by_subj_formula=no_interaction_model.by_subj_formula,\n    by_item_formula=\"~ 1\",\n)\n\ntwoway_interaction_model.fit(data_test)\n\n\nfull_interaction_model = MixedEffectsModel(\n    fixed_formula=f\"~ {distance_term} * {structure_term} * {island_term} * {dependency_term}\",\n    by_subj_formula=no_interaction_model.by_subj_formula,\n    by_item_formula=\"~ 1\",\n)\n\nfull_interaction_model.fit(data_test)\n\n\n\nClustered mixed effects models\nTo implement the clustered mixed effects models, we need to add a way of specifying which interactions we would like to model as discrete. We’ll enforce that, if an item does not instantiate distance=long and island=island, it gets mapped to no_interaction.\n\n@dataclass\nclass ClusteredMixedEffectsData(MixedEffectsData):\n    N_grammaticality_levels: int          # number of grammaticality levels\n    N_interactions: int                   # number of interactions to model as discrete\n    interactions: ndarray                 # interactions to model as discrete \n\nclass ClusteredMixedEffectsModel(MixedEffectsModel):\n    data_class = ClusteredMixedEffectsData\n    \n    def __init__(self, n_grammaticality_levels: int, **kwargs):\n        super().__init__(**kwargs)\n        \n        self.n_grammaticality_levels = n_grammaticality_levels\n    \n    def construct_model_data(self, data: DataFrame):\n        model_data = super().construct_model_data(data)\n        \n        self.interactions_hash, interactions = hash_series(\n            data[[\"distance\", \"structure\", \"island\", \"dependency\"]].apply(\n                lambda x: x[2] + \"_\" + x[3] if x[0] == \"long\" and x[1] == \"island\" else \"no_interaction\",\n                axis=1\n            )\n        )\n        \n        model_data.update({\n            \"N_grammaticality_levels\": self.n_grammaticality_levels,\n            \"N_interactions\": self.interactions_hash.shape[0],\n            \"interactions\": interactions\n        })\n        \n        return model_data\n    \nclass ConstrainedClusteredMixedEffectsModel(ClusteredMixedEffectsModel):\n    stan_file = \"models/constrained-clustered-interaction-model/constrained-clustered-interaction-model.stan\"\n    \nclass UnconstrainedClusteredMixedEffectsModel(ClusteredMixedEffectsModel):\n    stan_file = \"models/unconstrained-clustered-interaction-model/unconstrained-clustered-interaction-model.stan\"\n    \n    def _compute_map_estimate(self, seed:int):\n        map_estimate = super()._compute_map_estimate(seed)\n        \n        for vname, v in map_estimate.items():\n            if \"penalty\" in vname and not hasattr(v, \"shape\"):\n                map_estimate[vname] = array([v])\n                \n        return map_estimate\n\nWe will consider models with 2, 3, and 4 levels of grammaticality.\n\ndiscrete_models = {}\ncontinuous_models = {}\n\nfor g in range(2, 5):\n    print(f\"Fitting discrete model with {g} grammaticality levels...\")\n    \n    constrained_models[g] = ConstrainedClusteredMixedEffectsModel(\n        n_grammaticality_levels=g,\n        fixed_formula=no_interaction_model.fixed_formula,\n        by_subj_formula=no_interaction_model.by_subj_formula,\n        by_item_formula=\"~ 1\",\n    )\n    \n    constrained_models[g].fit(data_test)\n    \n    print(f\"Fitting continuous model with {g} grammaticality levels...\")\n    \n    unconstrained_models[g] = UnconstrainedClusteredMixedEffectsModel(\n        n_grammaticality_levels=g,\n        fixed_formula=no_interaction_model.fixed_formula,\n        by_subj_formula=no_interaction_model.by_subj_formula,\n        by_item_formula=\"~ 1\",\n    )\n    \n    unconstrained_models[g].fit(data_test)"
  },
  {
    "objectID": "island-effects/model-fitting-and-comparison.html#model-comparison",
    "href": "island-effects/model-fitting-and-comparison.html#model-comparison",
    "title": "Model Fitting and Comparison",
    "section": "Model comparison",
    "text": "Model comparison\nFinally, we will compute the model comparison using PSIS-LOO. These models are ranked by ELPD\\(_\\text{loo}\\).\n\ncompare_dict = {\n    \"No interaction model\": no_interaction_model.model_fit,\n    \"Minimal interaction model\": twoway_interaction_model.model_fit,\n    \"Maximal interaction model\": full_interaction_model.model_fit\n}\n\nfor n_grammaticality_levels, m in constrained_models.items():\n    name = f\"Constrained model ({n_grammaticality_levels} levels)\"\n    compare_dict[name] = m.model_fit\n    \nfor n_grammaticality_levels, m in unconstrained_models.items():\n    name = f\"Unconstrained model ({n_grammaticality_levels} levels)\"\n    compare_dict[name] = m.model_fit\n\nmodel_comparison = compare(compare_dict)\n\nmodel_comparison[[\"elpd_loo\", \"p_loo\", \"elpd_diff\", \"dse\"]]\n\n\n\n\n\n\n\n\nelpd_loo\np_loo\nelpd_diff\ndse\n\n\n\n\nConstrained model (4 levels)\n-10716.830739\n566.988072\n0.000000\n0.000000\n\n\nUnconstrained model (4 levels)\n-10717.042327\n567.278971\n0.211588\n0.629807\n\n\nConstrained model (3 levels)\n-10718.938079\n569.969504\n2.107341\n0.684705\n\n\nUnconstrained model (3 levels)\n-10719.299001\n569.839128\n2.468262\n0.880495\n\n\nConstrained model (2 levels)\n-10719.712935\n567.872110\n2.882196\n1.703436\n\n\nMinimal interaction model\n-10721.546329\n565.649372\n4.715591\n2.948452\n\n\nUnconstrained model (2 levels)\n-10721.878888\n569.544818\n5.048149\n1.610423\n\n\nMaximal interaction model\n-10721.923465\n574.947989\n5.092726\n1.902887\n\n\nNo interaction model\n-10725.226354\n573.342717\n8.395615\n4.284287\n\n\n\n\n\n\n\nThere are a few things to note about this comparison.\nFirst, all models that have grammatical effects dominate the no interaction model. This ranking is not surprising, given the difference of differences we saw in the last section, but it is a good sanity check.\nSecond, the minimal and maximal interaction models have effectively the same ELPD\\(_\\text{loo}\\), even though the \\(p_\\text{loo}\\) for the maximal interaction model is nearly 10 points higher. This pattern indicates that the maximal interaction model fits better than the minimal interaction model–as we would expect–but when trading complexity off with fit, there is not reason to prefer the better-fitting maximal interaction model to the worse-fitting minimal interaction model (or vice versa).\nFinally, nearly all the clustered mixed effects models dominate the minimal and maximal interaction models, with more levels (at least up to 4) improving the PSIS-LOO. This result, which is driven by improved fit without a substantial increase in complexity as evidenced by the \\(p_\\text{loo}\\)s, is promising for the clustered mixed effects models. We need to be cautious in interpreting this ranking, however, since the ratio of difference in ELPD to dse–especially in for the minimal interaction model–is small and these comparisons are being conducted post hoc. Ideally, to confirm this ranking, we would collect a new sample that would likely need to be quite a bit larger than the one collected by Sprouse et al. (2016)."
  },
  {
    "objectID": "island-effects/model-fitting-and-comparison.html#digging-into-the-clustered-mixed-effects-models",
    "href": "island-effects/model-fitting-and-comparison.html#digging-into-the-clustered-mixed-effects-models",
    "title": "Model Fitting and Comparison",
    "section": "Digging into the clustered mixed effects models",
    "text": "Digging into the clustered mixed effects models\nOne useful aspect of the clustered mixed effects models is that they allow us to dig into (i) the penalty along the acceptability continuum associated with ungrammaticality; and (ii) which level of grammaticality would be associated with a particular structure using the membership probabilities.\n\nGrammaticality penalties\nThe penalty of each level of ungrammaticality in the constrained model is approximately -0.75.\n\n\nPlotting code\n_ = plot_forest(\n    constrained_models[4].model_fit,\n    var_names=[\"penalty\", \"jumps\"],\n    combined=True,\n    figsize=(11.5, 3.5),\n)\n\n\n\n\n\nFor comparison, the effects of distance=long and structure=island are each about -1.5. So the effect of one increment of ungrammaticality is about half that of the effects of distance=long and structure=island.\n\nimport re\nfrom arviz import summary\n\ndef format_factor_levels(x):\n    extracted = re.findall(\"C\\(([A-z]+).+?\\)\\[T\\.([A-z]+)\\]\", x)\n    return ' x '.join([f\"{k}={v}\" for k, v in extracted])\n\nconstrained_coefs = summary(constrained_models[4].model_fit, \"fixed_coefs\")\n\nconstrained_coefs.index = constrained_models[4].fixed_predictors.columns.map(format_factor_levels)\n\nconstrained_coefs[[\"mean\", \"sd\", \"hdi_3%\", \"hdi_97%\"]]\n\n\n\n\n\n\n\n\nmean\nsd\nhdi_3%\nhdi_97%\n\n\n\n\n\n6.935\n0.365\n6.270\n7.634\n\n\ndistance=long\n-1.606\n0.426\n-2.359\n-0.784\n\n\nstructure=island\n-1.407\n0.437\n-2.210\n-0.588\n\n\nisland=SUB\n-2.188\n0.466\n-3.091\n-1.328\n\n\nisland=ADJ\n-1.783\n0.446\n-2.629\n-0.973\n\n\nisland=NP\n-0.181\n0.468\n-0.981\n0.740\n\n\ndependency=RC\n-3.002\n0.467\n-3.894\n-2.119\n\n\ndependency=DlinkedWH\n-0.993\n0.328\n-1.606\n-0.372\n\n\ndependency=DlinkedRC\n-2.717\n0.475\n-3.651\n-1.881\n\n\ndistance=long x island=SUB\n2.820\n0.559\n1.720\n3.854\n\n\ndistance=long x island=ADJ\n-0.187\n0.547\n-1.220\n0.797\n\n\ndistance=long x island=NP\n-1.260\n0.552\n-2.299\n-0.205\n\n\nstructure=island x island=SUB\n-2.169\n0.577\n-3.270\n-1.126\n\n\nstructure=island x island=ADJ\n-0.491\n0.558\n-1.649\n0.480\n\n\nstructure=island x island=NP\n0.869\n0.574\n-0.182\n1.969\n\n\ndistance=long x dependency=RC\n0.648\n0.560\n-0.444\n1.675\n\n\ndistance=long x dependency=DlinkedWH\n1.217\n0.386\n0.546\n1.975\n\n\ndistance=long x dependency=DlinkedRC\n0.424\n0.560\n-0.621\n1.493\n\n\nstructure=island x dependency=RC\n0.672\n0.573\n-0.428\n1.721\n\n\nstructure=island x dependency=DlinkedWH\n0.551\n0.385\n-0.173\n1.250\n\n\nstructure=island x dependency=DlinkedRC\n0.374\n0.573\n-0.631\n1.539\n\n\nisland=SUB x dependency=RC\n2.011\n0.666\n0.759\n3.279\n\n\nisland=ADJ x dependency=RC\n2.763\n0.651\n1.543\n3.957\n\n\nisland=NP x dependency=RC\n1.326\n0.636\n0.165\n2.556\n\n\nisland=SUB x dependency=DlinkedWH\n1.839\n0.410\n1.087\n2.612\n\n\nisland=ADJ x dependency=DlinkedWH\n0.406\n0.402\n-0.319\n1.164\n\n\nisland=NP x dependency=DlinkedWH\n-0.253\n0.435\n-1.049\n0.580\n\n\nisland=SUB x dependency=DlinkedRC\n2.783\n0.646\n1.585\n4.035\n\n\nisland=ADJ x dependency=DlinkedRC\n2.111\n0.636\n0.906\n3.276\n\n\nisland=NP x dependency=DlinkedRC\n1.367\n0.640\n0.194\n2.547\n\n\ndistance=long x island=SUB x dependency=RC\n-1.074\n0.746\n-2.465\n0.341\n\n\ndistance=long x island=ADJ x dependency=RC\n-0.675\n0.805\n-2.237\n0.779\n\n\ndistance=long x island=NP x dependency=RC\n-0.282\n0.758\n-1.678\n1.156\n\n\ndistance=long x island=SUB x dependency=DlinkedWH\n-1.749\n0.496\n-2.721\n-0.874\n\n\ndistance=long x island=ADJ x dependency=DlinkedWH\n-0.086\n0.477\n-0.987\n0.783\n\n\ndistance=long x island=NP x dependency=DlinkedWH\n-0.379\n0.514\n-1.366\n0.538\n\n\ndistance=long x island=SUB x dependency=DlinkedRC\n-0.915\n0.761\n-2.315\n0.527\n\n\ndistance=long x island=ADJ x dependency=DlinkedRC\n-0.359\n0.787\n-1.768\n1.169\n\n\ndistance=long x island=NP x dependency=DlinkedRC\n-0.322\n0.763\n-1.797\n1.046\n\n\nstructure=island x island=SUB x dependency=RC\n0.655\n0.789\n-0.944\n2.056\n\n\nstructure=island x island=ADJ x dependency=RC\n-0.620\n0.831\n-2.219\n0.890\n\n\nstructure=island x island=NP x dependency=RC\n-0.066\n0.777\n-1.468\n1.426\n\n\nstructure=island x island=SUB x dependency=DlinkedWH\n-0.798\n0.497\n-1.715\n0.120\n\n\nstructure=island x island=ADJ x dependency=DlinkedWH\n-0.290\n0.477\n-1.161\n0.603\n\n\nstructure=island x island=NP x dependency=DlinkedWH\n-0.245\n0.522\n-1.294\n0.648\n\n\nstructure=island x island=SUB x dependency=DlinkedRC\n-0.218\n0.801\n-1.740\n1.292\n\n\nstructure=island x island=ADJ x dependency=DlinkedRC\n-0.223\n0.798\n-1.664\n1.271\n\n\nstructure=island x island=NP x dependency=DlinkedRC\n0.150\n0.780\n-1.381\n1.545\n\n\n\n\n\n\n\nIn contrast, the penalty for the first level of ungrammaticality in the unconstrained model is a bit over -1 with the remaining penalties being a bit stronger than -0.5.\n\n\nPlotting code\n_ = plot_forest(\n    unconstrained_models[4].model_fit,\n    var_names=[\"penalty\", \"jumps\"],\n    combined=True,\n    figsize=(11.5, 3.5),\n)\n\n\n\n\n\nAnd the pattern of fixed effects coefficients for the unconstrained model is very similr to that for the constrained model.\n\ndef format_factor_levels(x):\n    extracted = re.findall(\"C\\(([A-z]+).+?\\)\\[T\\.([A-z]+)\\]\", x)\n    return ' x '.join([f\"{k}={v}\" for k, v in extracted])\n\nunconstrained_coefs = summary(unconstrained_models[4].model_fit, \"fixed_coefs\")\n\nunconstrained_coefs.index = unconstrained_models[4].fixed_predictors.columns.map(format_factor_levels)\n\nunconstrained_coefs[[\"mean\", \"sd\", \"hdi_3%\", \"hdi_97%\"]]\n\n\n\n\n\n\n\n\nmean\nsd\nhdi_3%\nhdi_97%\n\n\n\n\n\n7.024\n0.467\n6.161\n7.821\n\n\ndistance=long\n-1.613\n0.421\n-2.376\n-0.795\n\n\nstructure=island\n-1.446\n0.429\n-2.211\n-0.576\n\n\nisland=SUB\n-2.188\n0.466\n-3.069\n-1.322\n\n\nisland=ADJ\n-1.792\n0.457\n-2.624\n-0.912\n\n\nisland=NP\n-0.164\n0.459\n-1.063\n0.682\n\n\ndependency=RC\n-3.018\n0.456\n-3.845\n-2.166\n\n\ndependency=DlinkedWH\n-1.029\n0.335\n-1.640\n-0.382\n\n\ndependency=DlinkedRC\n-2.744\n0.461\n-3.607\n-1.865\n\n\ndistance=long x island=SUB\n2.818\n0.551\n1.709\n3.776\n\n\ndistance=long x island=ADJ\n-0.186\n0.544\n-1.238\n0.800\n\n\ndistance=long x island=NP\n-1.310\n0.546\n-2.324\n-0.258\n\n\nstructure=island x island=SUB\n-2.146\n0.574\n-3.236\n-1.074\n\n\nstructure=island x island=ADJ\n-0.450\n0.566\n-1.523\n0.590\n\n\nstructure=island x island=NP\n0.866\n0.549\n-0.158\n1.899\n\n\ndistance=long x dependency=RC\n0.670\n0.543\n-0.328\n1.694\n\n\ndistance=long x dependency=DlinkedWH\n1.249\n0.411\n0.526\n2.027\n\n\ndistance=long x dependency=DlinkedRC\n0.460\n0.543\n-0.544\n1.486\n\n\nstructure=island x dependency=RC\n0.734\n0.569\n-0.305\n1.812\n\n\nstructure=island x dependency=DlinkedWH\n0.599\n0.407\n-0.183\n1.305\n\n\nstructure=island x dependency=DlinkedRC\n0.451\n0.571\n-0.649\n1.479\n\n\nisland=SUB x dependency=RC\n2.021\n0.664\n0.791\n3.249\n\n\nisland=ADJ x dependency=RC\n2.736\n0.650\n1.471\n3.861\n\n\nisland=NP x dependency=RC\n1.288\n0.622\n0.195\n2.556\n\n\nisland=SUB x dependency=DlinkedWH\n1.876\n0.418\n1.064\n2.609\n\n\nisland=ADJ x dependency=DlinkedWH\n0.443\n0.409\n-0.307\n1.240\n\n\nisland=NP x dependency=DlinkedWH\n-0.246\n0.441\n-1.081\n0.590\n\n\nisland=SUB x dependency=DlinkedRC\n2.784\n0.631\n1.517\n3.905\n\n\nisland=ADJ x dependency=DlinkedRC\n2.101\n0.628\n0.942\n3.262\n\n\nisland=NP x dependency=DlinkedRC\n1.337\n0.626\n0.088\n2.466\n\n\ndistance=long x island=SUB x dependency=RC\n-1.093\n0.739\n-2.407\n0.398\n\n\ndistance=long x island=ADJ x dependency=RC\n-0.645\n0.780\n-2.064\n0.841\n\n\ndistance=long x island=NP x dependency=RC\n-0.240\n0.731\n-1.579\n1.168\n\n\ndistance=long x island=SUB x dependency=DlinkedWH\n-1.784\n0.504\n-2.669\n-0.782\n\n\ndistance=long x island=ADJ x dependency=DlinkedWH\n-0.122\n0.499\n-1.034\n0.803\n\n\ndistance=long x island=NP x dependency=DlinkedWH\n-0.360\n0.539\n-1.402\n0.588\n\n\ndistance=long x island=SUB x dependency=DlinkedRC\n-0.915\n0.750\n-2.318\n0.511\n\n\ndistance=long x island=ADJ x dependency=DlinkedRC\n-0.356\n0.758\n-1.790\n1.014\n\n\ndistance=long x island=NP x dependency=DlinkedRC\n-0.287\n0.736\n-1.637\n1.144\n\n\nstructure=island x island=SUB x dependency=RC\n0.601\n0.787\n-0.846\n2.085\n\n\nstructure=island x island=ADJ x dependency=RC\n-0.652\n0.835\n-2.218\n0.838\n\n\nstructure=island x island=NP x dependency=RC\n-0.064\n0.755\n-1.475\n1.384\n\n\nstructure=island x island=SUB x dependency=DlinkedWH\n-0.850\n0.514\n-1.794\n0.112\n\n\nstructure=island x island=ADJ x dependency=DlinkedWH\n-0.338\n0.505\n-1.272\n0.605\n\n\nstructure=island x island=NP x dependency=DlinkedWH\n-0.241\n0.543\n-1.243\n0.752\n\n\nstructure=island x island=SUB x dependency=DlinkedRC\n-0.268\n0.798\n-1.746\n1.285\n\n\nstructure=island x island=ADJ x dependency=DlinkedRC\n-0.280\n0.799\n-1.807\n1.158\n\n\nstructure=island x island=NP x dependency=DlinkedRC\n0.137\n0.752\n-1.256\n1.592\n\n\n\n\n\n\n\n\n\nMembership probabilities\nTurning to the level of grammaticality associated with particular structures, in the constrained model, we see that the majority split between levels 1 and 2, with level 3 reserved for WH question formation out of an NP or WH island.\n\n\nPlotting code\nfrom numpy import exp, arange, argsort\nfrom matplotlib.pyplot import subplots\n\nlog_membership_probs_constrained = constrained_models[4].raw_model_fit.stan_variable(\"log_membership\")\nmembership_probs_constrained = exp(log_membership_probs_constrained).mean(0)\n\nexpected_membership_constrained = (membership_probs_constrained*arange(4)).mean(1)\n\nsort_indices_constrained = argsort(expected_membership_constrained)\n\nfig, ax = subplots(figsize=(6, 8))\nimg = ax.imshow(membership_probs_constrained[sort_indices_constrained])\nax.set_xticks(arange(4))\nax.set_xlabel(\"Grammaticality level\")\nax.set_yticks(arange(17), discrete_models[4].interactions_hash[sort_indices])\nax.set_ylabel(\"Interaction\")\nimg.set_cmap('binary')\n_ = fig.colorbar(img, label=\"Probability\")\n\n\n\n\n\nWe see a similar pattern in the unconstrained model.\n\n\nPlotting code\nfrom numpy import exp, arange, argsort\nfrom matplotlib.pyplot import subplots\n\nlog_membership_probs_unconstrained = unconstrained_models[3].raw_model_fit.stan_variable(\"log_membership\")\nmembership_probs_unconstrained = exp(log_membership_probs_unconstrained).mean(0)\n\nexpected_membership_unconstrained = (membership_probs_unconstrained*arange(3)).mean(1)\n\nsort_indices = argsort(expected_membership_unconstrained)\n\nfig, ax = subplots(figsize=(6, 8))\nimg = ax.imshow(membership_probs_unconstrained[sort_indices])\nax.set_xticks(arange(3))\nax.set_xlabel(\"Grammaticality level\")\nax.set_yticks(arange(17), unconstrained_models[3].interactions_hash[sort_indices])\nax.set_ylabel(\"Interaction\")\nimg.set_cmap('binary')\n_ = fig.colorbar(img, label=\"Probability\")\n\n\n\n\n\nComparing the expected grammaticality level for each structure with the difference of differences we observed for that structure, we see a very tight correlation.\n\n\nPlotting code\nfrom pandas import merge\nfrom seaborn import PairGrid, scatterplot, histplot\n\nfactors = [\n    \"island\", \"dependency\",\n    \"distance\", \"structure\" \n]\n\ndata_test_itemmeans = data_test.groupby(\n    factors + [\"item\"]\n)[[\"zscores\"]].mean().reset_index()\n\ndata_test_itemmeans[\"itemnum\"] = data_test_itemmeans.item.map(\n    lambda x: x.split(\".\")[-1]\n)\n\ndata_test_itemmeans_cast = data_test_itemmeans.pivot_table(\n    index=[\"island\", \"dependency\", \"itemnum\"], \n    columns=[\"distance\", \"structure\"], \n    values=\"zscores\"\n)\n\nshort_diffs = data_test_itemmeans_cast.short.non -\\\n              data_test_itemmeans_cast.short.island\nlong_diffs = data_test_itemmeans_cast.long.non -\\\n             data_test_itemmeans_cast.long.island\n\ndiffs_of_diffs = (short_diffs - long_diffs).reset_index()\n\ndiffs_of_diffs[\"island_dependency\"] = diffs_of_diffs.island + \"_\" + diffs_of_diffs.dependency\n\ndiffs_of_diffs = diffs_of_diffs.rename(columns={\n    0: \"diff_of_diffs\"\n})\n\ndiffs_of_diffs_mean = diffs_of_diffs.groupby(\"island_dependency\")[[\"diff_of_diffs\"]].mean()\n\nexpected_membership_constrained_df = DataFrame(\n    expected_membership_constrained,\n    index=constrained_models[3].interactions_hash,\n    columns=[\"constrained\"]\n)\n\nexpected_membership_unconstrained_df = DataFrame(\n    expected_membership_unconstrained,\n    index=unconstrained_models[3].interactions_hash,\n    columns=[\"unconstrained\"]\n)\n\ndiffs_of_diffs_expected_membership = merge(\n    diffs_of_diffs_mean, \n    merge(\n        expected_membership_unconstrained_df, \n        expected_membership_constrained_df, \n        left_index=True, right_index=True), \n    left_index=True, right_index=True\n)\n\ng = PairGrid(\n    diffs_of_diffs_expected_membership,\n    diag_sharey=False, corner=True\n)\n\ng.map_diag(histplot, bins=4)\n_ = g.map_lower(scatterplot)"
  },
  {
    "objectID": "island-effects/model-fitting-and-comparison.html#summing-up",
    "href": "island-effects/model-fitting-and-comparison.html#summing-up",
    "title": "Model Fitting and Comparison",
    "section": "Summing up",
    "text": "Summing up\nIn this first module of the course, we focused on minimally extending standard statistical models used in analyzing acceptability judgments–generalized linear mixed effects models–in order to probe the nature of the grammatical representations that drive acceptability judgments. We considered two possibilities discussed by Sprouse (2018): (a) that the grammatical representations underlying acceptability judgments are discrete (or categorical); and (b) the grammatical representations are continuous (or gradient).\nThe basic recipe, which we will repeat through the course, was (i) to define two or more (families of) models–in this case, our not interaction, minimal interaction, maximal interaction, and clustered interaction models; (ii) to fit both models to the data from some acceptability judgment data–in this case, to the data collected by Sprouse et al. (2016); and (iii) to compare how well the two models fit the data, weighed against some measure of how parsimonious (or conversely, complex) each model is using PSIS-LOO.\nWe saw that the models that inject additional discrete structure into the standard mixed effects models not only imrpove fit while keeping complexity at bay, they are also quite interpretable. In the next module, we will look at a similar approach to modeling inference judgment data."
  },
  {
    "objectID": "island-effects/model-fitting-and-comparison.html#footnotes",
    "href": "island-effects/model-fitting-and-comparison.html#footnotes",
    "title": "Model Fitting and Comparison",
    "section": "Footnotes",
    "text": "Footnotes\n\n\nNote that this distribution is different from the one observed here because we are only fitting to the test items. The fillers are removed.↩︎\nA good analogy here is between an unpaired \\(t\\)-test and a paired \\(t\\)-test.↩︎"
  },
  {
    "objectID": "projective-content/index.html",
    "href": "projective-content/index.html",
    "title": "Overview",
    "section": "",
    "text": "Reading\n\n\n\nData: Degen and Tonhauser (2021) on how prior beliefs modulate projectivity inferences. We will use the data collected for that paper, which can be found here, in this module.\nTheory: Degen and Tonhauser (2022) and Kane, Gantt, and White (2022) on whether there is a discrete category of factive predicates. We will specifically be concerned with Degen and Tonhauser’s discussion–broadly, but most specifically in Section 4–about the sources of gradience.\n\n\nLike in the first module of the course, in this second module of the course, we are going to focus on minimally extending standard statistical models used in analyzing inference judgments in order to probe how semantic semantic representations and/or reasoning processes interact with world knowledge (or prior beliefs) in driving inference judgments. We’re going to consider two subtly distinct questions: (i) whether there is evidence for discrete classes of lexical representations that determine inferences commonly associated with factive predicates or whether this knowledge is fundamentally continuous; and (ii) how, for aspects of lexical knowledge that are fundamentally continuous, that knowledge is integrated with world knowledge.\nThe first question is the main focus of the paper by Degen and Tonhauser (2022), who argue (p. 553) “…that there is little empirical support from [their six] experiments for the assumed categorical distinction between factive and nonfactive predicates.” We’ll first discuss some modeling evidence presented by Kane, Gantt, and White (2022) that countervails this argument. We won’t implement Kane et al.’s model, though all of the data is available here, and their code is documented and publicly available here. The gist is that, when we appropriately account for various sources of gradience in inference judgments, we observe a small number of clear cluster of predicates, all of which correspond cleanly to the predicate classes one might expect from the literature of clause-embedding predicates and a subset of which correspond to traditional subclassifications of factives.\nOur main reason for looking the finding by Kane, Gantt, and White (2022) is to sharpen the second question, which we will address by modeling data collected by Degen and Tonhauser (2021) for a slightly different purpose. As in Module 1, the basic recipe will be (i) to define two or more (families of) models; (ii) to fit both models to the data from some acceptability judgment data–in this case, to the data collected by Degen and Tonhauser (2021); and (iii) to compare how well the two models fit the data, weighed against some measure of how parsimonious (or conversely, complex) each model is.\n\n\n\n\nReferences\n\nDegen, Judith, and Judith Tonhauser. 2021. “Prior Beliefs Modulate Projection.” Open Mind 5 (September): 59–70. https://doi.org/10.1162/opmi_a_00042.\n\n\n———. 2022. “Are There Factive Predicates? An Empirical Investigation.” Language 98 (3): 552–91. https://doi.org/10.1353/lan.0.0271.\n\n\nKane, Benjamin, Will Gantt, and Aaron Steven White. 2022. “Intensional Gaps: Relating Veridicality, Factivity, Doxasticity, Bouleticity, and Neg-Raising.” Semantics and Linguistic Theory 31 (January): 570–605. https://doi.org/10.3765/salt.v31i0.5137."
  },
  {
    "objectID": "projective-content/inferentially-defined-classes-of-predicates.html",
    "href": "projective-content/inferentially-defined-classes-of-predicates.html",
    "title": "Inferentially defined classes of predicates",
    "section": "",
    "text": "In discussing the results of their Experiments 1a and 1b, Degen and Tonhauser (2022, 565) suggest “…that projection does not categorically distinguish canonically factive predicates from others: contrary to what is expected on definition 3a, we observed that the [contents of the complements (CCs)] of predicates standardly classified as factive are not categorically more projective than the CCs of all other predicates.”1\nIndeed, in discussing Experiment 1a (p. 563), they make the much stronger claim that “…the results of experiment 1a suggest that projection does not identify a coherent class of factive predicates” because drawing a line “between factive predicates and others based on the projection of the CCs…cannot be done in a nonarbitrary way” (p. 562).\nDegen and Tonhauser (2022, 567) furthermore argue on the basis of similar datasets–the MegaVeridicality dataset (White and Rawlins 2018; White et al. 2018), the CommitmentBank (Marneffe, Simons, and Tonhauser 2019), and the VerbVeridicality (Ross and Pavlick 2019) datasets–that “…contrary to what is expected under the definition of factive predicates in 3a, the results of our experiments 1a and 1b as well as our meta-analyses of the CommitmentBank, the VerbVeridicality data set, and the MegaVeridicality data set suggest that projection of the CC does not identify a coherent class of factive predicates” and that this challenge is made even stronger by “…the diversity of the empirical evidence: it comes from constructed and naturally occurring examples, from examples presented with and without a context, from examples with diverse and with minimal lexical content, from clause-embedding predicates embedded under different entailment-canceling operators, and from projection ratings collected through different response tasks” (ibid, p. 568)."
  },
  {
    "objectID": "projective-content/inferentially-defined-classes-of-predicates.html#the-lexical-indeterminacy-possibility",
    "href": "projective-content/inferentially-defined-classes-of-predicates.html#the-lexical-indeterminacy-possibility",
    "title": "Inferentially defined classes of predicates",
    "section": "The lexical indeterminacy possibility",
    "text": "The lexical indeterminacy possibility\nThey go on to admit, however, that (p. 583) “…the observed gradience in projection may be compatible with a binary factivity category in combination with two assumptions: first, that predicates may be ambiguous between a factive lexical entry, on which the CC is presupposed and hence projects, and a nonfactive lexical entry, on which the CC is not presupposed (for such a proposal for clause-embedding predicates see Spector and Egré 2015, 1736; for a similar proposal for evaluative adjectives see Karttunen et al. 2014); and, second, that interpreters may be uncertain about which lexical entry a speaker intended in their utterance” and that “[u]nder such a view, a categorical notion of factivity is upheld, and the observed projection gradience can be hypothesized to be due to listeners’ uncertainty about the use of any given predicate, which may be resolved preferentially one way or another through pragmatic factors.”\nThis possibility remains live in large part because, while they are working with quantitative data, the stronger argument that the measures of projection they look at does not “identify a coherent class of factive predicates” is based purely on qualitative arguments. So in point of fact, the paper really only provides evidence for the weaker claim that “predicates standardly classified as factive are not categorically more projective than the CCs of all other predicates.” But of course, the standard classification could just be wrong.\nIn this context, they go on to discuss the idea that one might assess the stronger argument quantitatively using mixture models, but they decline to do so. They have two reasons for this. The first is another argument based on qualitative analysis: ““[t]he account sketched above, on which predicates may have a factive lexical entry, a nonfactive one, or both, does not lead us to expect projection data distributions…that are best captured by three or four components, let alone distributions that are best captured by five or six components” (p. 583). The second is that “[m]ixture models are not, however, a theory of factivity or projection, and as such they do not specify what the generative model underlying the components is.”\nWe will discuss second argument as a motivation for the modeling we will do in the next section. Before doing that, we’ll assess the first argument in the context of the work by Kane, Gantt, and White (2022)."
  },
  {
    "objectID": "projective-content/inferentially-defined-classes-of-predicates.html#are-there-factive-predicates-yes.",
    "href": "projective-content/inferentially-defined-classes-of-predicates.html#are-there-factive-predicates-yes.",
    "title": "Inferentially defined classes of predicates",
    "section": "Are there factive predicates? Yes.",
    "text": "Are there factive predicates? Yes.\nThe main motivation for Kane, Gantt, and White (2022) is to understand “which patterns of lexically triggered doxastic, bouletic, neg(ation)-raising, and veridicality inferences are (un)attested across clause-embedding verbs in English”, with the overarching aim of understanding where we see “[g]aps in logically possible patterns of lexically triggered inferences…because they suggest potentially deep constraints on lexicalization (Horn 1972; Barwise and Cooper 1981; Levin and Rappaport Hovav 1991, a.o.)” (ibid, p. 570). To carry out this investigation, they use a multiview mixed effects mixture model to synthesize data from the MegaVeridicality dataset–the same used by Degen and Tonhauser (2022)–along with the MegaNegRaising (An and White 2020) and MegaIntensionality datasets.\nWhat Kane, Gantt, and White (2022) find is that, once we appropriately model potential sources of noise in the way people approach various tasks, there are a small number of clusters of inference patterns attested across predicates that not only correspond extremely closely to those one might expect from the literature but that predict the syntactic distribution of those predicates surprisingly well.\nThey plot (their Figure 2, p. 580) the centroids of these clusters in terms of the mean likelihood for a particular inference associated with that cluster. We will not be concerned with their particular labels for the clusters except to say that they are based on qualitative analysis of the predicates that show up in those clusters.\n\n\n\nCluster centroids from Kane, Gantt, and White (2022) for veridicality responses.\n\n\nThe first thing to note about this plot are the five clusters to the right–whose likelihoods for both the entailment inference A __ that S ~&gt; S and the projective inference A not __ that S ~&gt; S–are extremely close to 1.2 The second thing to note is that, among the predicates that show lower likelihood for the projective inference (A not __ that S ~&gt; S), there is substantial variability in how strong that projective inference is."
  },
  {
    "objectID": "projective-content/inferentially-defined-classes-of-predicates.html#summing-up",
    "href": "projective-content/inferentially-defined-classes-of-predicates.html#summing-up",
    "title": "Inferentially defined classes of predicates",
    "section": "Summing up",
    "text": "Summing up\nThe findings of Kane, Gantt, and White (2022) suggest two things: (i) there are in fact clearly distinguishable subclasses of factive predicates (generally, constituted by emotives and/or miratives); and (ii) consistent with what Degen and Tonhauser (2022) observe, some classes of predicates are associated with inferences that are somehow “weaker” (on average) than those that are sometimes called the “true factives” (Karttunen 1971). The main question we’ll deal with in our models for this module is what it means for the inferences associated with some class to be “weaker”."
  },
  {
    "objectID": "projective-content/inferentially-defined-classes-of-predicates.html#footnotes",
    "href": "projective-content/inferentially-defined-classes-of-predicates.html#footnotes",
    "title": "Inferentially defined classes of predicates",
    "section": "Footnotes",
    "text": "Footnotes\n\n\nA similar qualitative observation is also made in passing by White and Rawlins (2018, 228) using the MegaVeridicality dataset: “…there are not necessarily clear dividing lines between these classes present in the data, suggesting that speaker’s inferences about veridicality are generally quite gradient and likely influenced by the fine-grained semantics of particular verbs.”↩︎\nThese clusters furthermore tend to include emotive–e.g. love and hate–and/or mirative predicates–e.g. surprise. This pattern accords with evidence about the strength of these inferences observed in other experimental work (see, e.g., Djärv, Zehr, and Schwarz 2018).↩︎"
  },
  {
    "objectID": "projective-content/model-definition.html",
    "href": "projective-content/model-definition.html",
    "title": "Model definition",
    "section": "",
    "text": "We’ll address the question of what it means for the projective inferences associated with some class of predicates to be “weaker” by considering two possibilities. The first is that variability in the likelihoods of projective inferences associated with each class indicates that elements of each class share a representation that is fundamentally gradient in nature. For instance, one way to implement this idea is to model projective inferences as analogous to the sort of vagueness one sees in predicates like tall–e.g. assuming that each class has a different projectivity threshold. I’ll refer to this hypothesis as the fundamental gradience hypothesis.\nAn alternative idea, following the discussion of Degen and Tonhauser (2022), is to assume that these likelihoods indicate the probability with which one chooses a factive v. non-factive variant of a predicate.1 I’ll refer to this hypothesis as the indeterminacy hypothesis.\nWe investigate this question by looking at the data collected by Degen and Tonhauser (2021). This dataset is useful for us because–not only does it contain judgments relevant to projectivity–it also explicitly measures how likely the content of the complement of a particular verb is. Degen and Tonhauser (2021) use these data to demonstrate that inference judgments in projectivity experiments using the paradigm discussed by Degen and Tonhauser (2022) are modulated by this likelihood–which Degen and Tonhauser (2021) discuss as a measure of subjects’ prior beliefs.\nDownload the data\n!git clone https://github.com/judith-tonhauser/projective-probability.git data/projective-probability/\n\ndata_dir = \"data/\""
  },
  {
    "objectID": "projective-content/model-definition.html#laying-out-the-possibilities",
    "href": "projective-content/model-definition.html#laying-out-the-possibilities",
    "title": "Model definition",
    "section": "Laying out the possibilities",
    "text": "Laying out the possibilities\nOur question will be: how does this modulation of inference judgments in the projectivity experiments occur? The first thing to ask is how knowledge about a predicate’s projectivity \\(\\pi^\\text{verb}_v\\) might be combined with prior knowledge about likelihood of some propositional contents in some context \\(\\pi^\\text{context}_c\\). We will consider a very simple general form for this combination: probabilistic fuzzy logic disjunction.\nTo see why this form is useful for our purposes, let’s consider an informal description of how a proponent of the indeterminacy theory might describe what happens when someone makes an inference judgment in the projectivity experiments: decide, on the basis of prior knowledge about how frequently the factive variant of a predicate occurs, whether to select a factive or non-factive variant of the predicate; if you selected a factive variant, respond yes; otherwise, respond based on your prior beliefs about the contents.\n\nTwo versions of the indeterminacy hypothesis\nIn the case where the response is based on prior beliefs, there are two ways one might go. The first is to decide whether the content is true and, if it is responde yes; and if it isn’t, respond no. I will refer to this as the wholly discrete hypothesis because all responses are at least intended to be no or yes (though they may be obcured by noise, response biases, etc.). If \\(\\tau^\\text{verb}_n \\sim \\text{Bernoulli}\\left(\\pi^\\text{verb}_{\\text{verb}(n)}\\right)\\) is the decision about whether or not the verb is factive and \\(\\tau^\\text{context}_n \\sim \\text{Bernoulli}\\left(\\pi^\\text{context}_{\\text{context}(n)}\\right)\\) is the decision about whether the content is true in the relevant context, then we can describe the intended response \\(n\\) (again, up to noise) as \\(\\tau^\\text{verb}_n \\lor (\\tau^\\text{verb}_n \\rightarrow \\tau^\\text{context}_n) = \\tau^\\text{verb}_n \\lor \\tau^\\text{context}_n\\). I will refer to this first hypothesis as the wholly discrete model.\nThe second option is to assume that one decides whether or not the verb is factive \\(\\tau^\\text{verb}_n \\sim \\text{Bernoulli}\\left(\\pi^\\text{verb}_{\\text{verb}(n)}\\right)\\), but that if it’s not we respond with the raw likelihood \\(\\pi^\\text{context}_c\\) (again, potentially subject to noise). We can describe this as \\(\\tau^\\text{verb}_n \\lor \\pi^\\text{context}_n\\), assuming that \\(\\lor\\) is interpreted as probabilistic fuzzy logic disjunction: \\(p \\lor p' \\equiv = p + (1-p)p' = 1 - (1-p)(1-p')\\), where classical disjunction is a special case with \\(p, p' \\in \\{0, 1\\}\\).2 So then:\n\\[\\tau^\\text{verb}_n \\lor \\pi^\\text{context}_n = \\begin{cases}\n1 & \\text{if } \\tau^\\text{verb}_n = 1\\\\\n\\pi^\\text{context}_n & \\text{otherwise}\n\\end{cases}\\]\nI will refer to this second hypothesis as the verb discrete model.\n\n\nTwo versions of the fundamental gradience hypothesis\nThe setup above suggests two additional possibilities: responding based on \\(\\pi^\\text{verb}_n \\lor \\tau^\\text{context}_n\\) or responding based on \\(\\pi^\\text{verb}_n \\lor \\pi^\\text{context}_n\\). The first of these options–which I will refer to as the context discrete model is a logical possibility, but it is not clear what kind of theory it might be associated with. Nonetheless, it assumes that responses are based directly on gradient knowledge about the verb. The second of these options–which I will refer to as the wholly gradient model–is a more natural fit for an implementation of the fundamental gradience hypothesis: it seems that at least the use of prior knowledge would be gradient; the question is whether is use of the lexical knowledge is as well."
  },
  {
    "objectID": "projective-content/model-definition.html#prior-beliefs",
    "href": "projective-content/model-definition.html#prior-beliefs",
    "title": "Model definition",
    "section": "Prior beliefs",
    "text": "Prior beliefs\nThe use we are going to put the norming data collected by Degen and Tonhauser (2021) is the estimation of distributions representing prior beliefs about particular contexts. That is, we will use it to estimate a distribution on \\(\\pi^\\text{context}_c\\).\n\n\nLoad the norming data\nimport os\nfrom pandas import DataFrame, read_csv\n\ndef load_norming_data(fname: str) -&gt; DataFrame:\n    data = read_csv(fname, index_col=0)\n\n    data = data[~data.item.isin([\"F1\", \"F2\"])]\n    \n    return data.drop(columns=\"comments\")\n\ndata_norming = load_norming_data(\n    os.path.join(\n        data_dir, \n        \"projective-probability/results/1-prior/data/cd.csv\"\n    )\n)\n\n\nOur main focus in this dataset will be modeling the distribution of respones to each itemType + itemNr, which corresponds to a particular pairing of fact and prompt. I’ll refer to these together as the context.\n\ndata_norming[[\"workerid\", \"itemType\", \"itemNr\", \"prompt\", \"fact\", \"response\"]].head()\n\n\n\n\n\n\n\n\nworkerid\nitemType\nitemNr\nprompt\nfact\nresponse\n\n\n\n\n1\n0\nH\n12\nHow likely is it that Frank got a cat?\nFrank has always wanted a pet.\n0.83\n\n\n2\n0\nL\n7\nHow likely is it that Isabella ate a steak on ...\nIsabella is a vegetarian.\n0.14\n\n\n3\n0\nH\n10\nHow likely is it that Zoe calculated the tip?\nZoe is a math major.\n0.93\n\n\n5\n0\nL\n3\nHow likely is it that Emma studied on Saturday...\nEmma is in first grade.\n0.64\n\n\n6\n0\nL\n13\nHow likely is it that Jackson ran 10 miles?\nJackson is obese.\n0.25\n\n\n\n\n\n\n\nEach prompt is paired with two different facts: one for which the prompt should elicit higher likelihood responses (itemType=H) and another for which the prompt should elicit lower likelihood responses (itemType=L). One example can be seen below.\n\ndata_norming_sub = data_norming.query('item.isin([\"10H\", \"10L\"])')\n\n\n\nPlotting code\nfrom seaborn import histplot\n\np = histplot(\n    data=data_norming_sub, x=\"response\", hue=\"fact\", \n    hue_order=[\"Zoe is 5 years old.\", \"Zoe is a math major.\"]\n)\n\n_ = p.set_title(\"How likely is it that Zoe calculated the tip?\")\n\n\n\n\n\nIn general, the intended likelihood corresponds quite well to the distribution of responses.\n\n\nPlotting code\nfrom matplotlib.pyplot import subplots\nfrom seaborn import boxplot\n\nfig, ax = subplots(figsize=(11.5, 7))\n\nprompt_order = data_norming.groupby(\"prompt\").response.max().sort_values(ascending=False)\n\n_ = boxplot(data_norming, y=\"prompt\", x=\"response\", hue=\"itemType\", hue_order=[\"L\", \"H\"], order=prompt_order.index)\n\n\n\n\n\nBefore discussing the prior belief model, we need to consider how exactly to model these sorts of bounded scale responses.\n\nModeling bounded scale responses\nA common way to model bounded scale responses is to assume that responses \\(Y_n\\) are distributed beta with mean \\(\\mu_{\\text{item}(n)} \\in (0, 1)\\) and sample size \\(\\nu \\in \\mathbb{R}_+\\):\n\\[Y_n \\sim \\text{Beta}(\\nu\\mu_{\\text{item}(n)}, \\nu(1-\\mu_{\\text{item}(n)}))\\]\nThis parameterization–in contrast to the parameterization directly in terms of \\(\\alpha\\) and \\(\\beta\\) that we discussed here–allows us to more directly model the expected value of \\(Y_n\\), since:\n\\[\\mathbb{E}[Y_n] = \\frac{\\nu\\mu_{\\text{item}(n)}}{\\nu\\mu_{\\text{item}(n)} + \\nu(1-\\mu_{\\text{item}(n)})} = \\mu_{\\text{item}(n)}\\]\nThis ability to more directly model the expected value–rather than having to model the two parameters \\(\\alpha\\) and \\(\\beta\\) directly–is useful for interpretability.\nOne challenge that arises with making this assumption is that the beta distribution does not have support on 0 or 1. This challenge is a real one, since there are a small (but nontrivial) number of 0 and 1 responses in the norming data (as well as the projection data).\n\n\nPlotting code\nfrom seaborn import countplot\n\ndef bin_responses(response):\n    if response == 1:\n        return \"one\"\n    elif response == 0:\n        return \"zero\"\n    else:\n        return \"neither\"\n\ndata_norming[\"responsetype\"] = data_norming.response.map(bin_responses)\n\n_ = countplot(x = \"responsetype\", data = data_norming, order = [\"zero\", \"neither\", \"one\"])\n\n\n\n\n\nOne way that researchers deal with this issue–especially when the number of 0 and 1 responses is small is to nudge those responses toward 0.5 slightly. The issue with this approach is that this nudging requires one to specify the amount that the value should be nudged, and that amount can matter a lot for models fit to the data–depending on what sort of model it is.\nThere are at least two ways one might try to avoid this issue. The first is to use what is known as a zero-one-inflated beta model. This sort of model assumes that the responses come from some mixture of a continuous random variable \\(\\gamma_n \\sim \\text{Beta}\\left(\\nu\\mu_n, \\nu\\left(1-\\mu_n\\right)\\right)\\) and two Bernoulli distributions \\(\\zeta_n \\sim \\text{Bernoulli}\\left(\\pi^\\text{zero}_n\\right)\\) and \\(\\omega_n \\sim \\text{Bernoulli}\\left(\\pi^\\text{one}_n\\right)\\). The mixture itself is defined in terms of a selection \\(d_n \\sim \\text{Cat}(\\boldsymbol\\theta_n)\\) of which random variable to sample from:\n\\[Y_n = \\begin{cases}\n\\zeta_n & \\text{if } d_n = 0\\\\\n\\omega_n & \\text{if } d_n = 1\\\\\n\\gamma_{\\text{item}(n)} & \\text{otherwise}\\\\\n\\end{cases}\\]\nThis approach is useful because it provides an intrepretable way of assessing how likely it is that the model believes the likelihood to be exactly 0 or exactly 1 is. But besides requiring a substantial number of additional parameters that one would need to design definitions for–\\(\\pi^\\text{zero}_n\\), \\(\\pi^\\text{one}_n\\), and \\(\\boldsymbol\\theta_n\\)–this model makes some assumptions that we just don’t want to make. For instance, it assumes that if you as a responder are targeting 0 or 1 (as indicated by \\(d_n\\)), you always hit it exactly. But no one is that accurate; there is always noise in response scale use–especially when you get subjects who are responding very quickly, as crowd-sourced workers tend to.\nAn alternative model that both reduce this complexity and provides support on \\(\\{0, 1\\}\\) in addition to \\((0, 1)\\) uses the truncated normal distribution to model the slider responses.\n\\[p(y_n; \\mu_n, \\sigma, a, b) = \\begin{cases}\n\\frac{\\mathcal{N}(y_n; \\mu_n, \\sigma_n^2)}{\\Phi(b; \\mu_n, \\sigma_n^2) - \\Phi(a; \\mu_n, \\sigma_n^2)} & \\text{if } y_n \\in [a, b]\\\\\n0 & \\text{otherwise}\n\\end{cases}\\]\nwhere \\(\\Phi\\) is the CDF of the normal distribution. So this distribution basically constrains the support of a \\(\\mathcal{N}(\\mu, \\sigma^2)\\) to \\([a, b]\\) and then renormalizes the distribution to ensure that it satisfies the assumption of unit measure.3 One way to think of what this distribution assumes is that subjects target some value \\(\\mu_n\\) when they respond, but they miss that exact value–e.g. because of uninteresting motor planning factors (and any other potential source of uncorrelated noise).\n\n\nThe prior belief model\nTo estimate the distributions over prior knowledge from the data collected by Degen and Tonhauser (2021), we use a random effects model with by-subject and by-item random intercepts. I will refer to the latter as by-context random intercepts, since we will need to distinguish by-context intercepts from by-verb intercepts when we begin modeling the projection data, and verbs are also constitutive of the items.\nThe data block needs to specify both the number of subjects and their identity as well as the number of contexts and their identity.\ndata {\n  int&lt;lower=0&gt; N_resp;                           // number of responses\n  int&lt;lower=0&gt; N_context;                        // number of contexts\n  int&lt;lower=0&gt; N_subj;                           // number of subjects\n  int&lt;lower=1,upper=N_context&gt; context[N_resp];  // context corresponding to response n\n  int&lt;lower=1,upper=N_subj&gt; subj[N_resp];        // subject corresponding to response n\n  vector&lt;lower=0,upper=1&gt;[N_resp] resp;          // bounded slider response     \n}\nWe use a standard parameterization of the random intercepts \\(\\rho_s^\\text{subj} \\sim \\mathcal{N}(0, \\sigma_\\text{subj}^2)\\) and \\(\\rho_c^\\text{context} \\sim \\mathcal{N}(0, \\sigma_\\text{context}^2)\\), specified in the parameters block.\nparameters {\n  real&lt;lower=0&gt; context_intercept_std;           // the context random intercept standard deviation\n  vector[N_context] context_intercept;           // the context random intercepts\n  real&lt;lower=0&gt; subj_intercept_std;              // the subject random intercept standard deviation\n  vector[N_subj] subj_intercept;                 // the subject random intercepts\n  real&lt;lower=0,upper=1&gt; sigma;\n}\nTo model how by-subject and by-context random intercepts combine, we will view them representations in log-odds space and define \\(\\mu_n \\equiv \\text{logit}^{-1}\\left(\\rho_{\\text{subj}(n)}^\\text{subj} + \\rho_{\\text{context}(n)}^\\text{context}\\right)\\) in the transformed parameters block.\ntransformed parameters {\n  real mu[N_resp];\n  for (n in 1:N_resp)\n    mu[n] = inv_logit(context_intercept[context[n]] + subj_intercept[subj[n]]);\n}\nWe could technically define \\(\\mu_n \\equiv \\rho_{\\text{subj}(n)}^\\text{subj} + \\rho_{\\text{context}(n)}^\\text{context}\\). This definition is possible because the mean of a truncated normal need not itself be in \\([a, b]\\). The issue with this definition is that it’s not really clear what the random intercepts represent.\nAnother possibility is to define \\(\\mu_n \\equiv \\text{logit}^{-1}\\left(\\rho_{\\text{subj}(n)}^\\text{subj}\\right) + \\rho_{\\text{context}(n)}^\\text{context}\\), where \\(\\text{logit}^{-1}\\left(\\rho_{\\text{subj}(n)}^\\text{subj}\\right) \\in (0, 1)\\) is interpretable as an average measure (though not technically the mean) for the context and the subject intercepts operate in scale space rather than log-odds space. This definition is a bit odd, however, because it would suggest that subjects can target values below 0 or above 1, and it’s not clear what it would mean to intend to respond with a likelihood below 0 or above 1.\nIn the model block, we specify the distributional assumptions for the random effects as well as the truncated normal assumption for the responses.4\nmodel {\n  context_intercept_std ~ exponential(1);\n  subj_intercept_std ~ exponential(1);\n\n  // sample the context intercepts\n  context_intercept ~ normal(0, context_intercept_std);\n\n  // sample the subject intercepts\n  subj_intercept ~ normal(0, subj_intercept_std);\n  \n  // sample the responses\n  for (n in 1:N_resp)\n    resp[n] ~ normal(mu[n], sigma) T[0,1];\n}\nFinally, it will be useful to define an additional quantity in the generated quantities block: the average likelihood associated with the context when zeroing out the subject intercept. This quantity corresponds to \\(\\pi^\\text{context}_c\\).\ngenerated quantities {\n  // compute the average context probabilities for the average subject\n  vector[N_context] context_prob;\n\n  for (c in 1:N_context) {\n    context_prob[c] = inv_logit(\n      context_intercept[c]\n    );\n  }\n}\nWith the aim of incorporating prior knowledge into our models of projection, what we’re going to do with this model is to use it’s posterior distribution over each by-context intercept as the prior for our models of the projection data. As we will see, these posterior distributions are very close to normal in log-odds space, so what we will do is to estimate, for each context \\(c\\), a \\(\\mu^\\text{context}_c\\) and a \\(\\sigma^\\text{context}_c\\) from the distribution we obtain and place \\(\\rho^\\text{context}_c \\sim \\mathcal{N}\\left(\\mu^\\text{context}_c, \\sigma^\\text{context}_c\\right)\\) on the by-context random intercepts \\(\\rho^\\text{context}_c\\)."
  },
  {
    "objectID": "projective-content/model-definition.html#projection-data",
    "href": "projective-content/model-definition.html#projection-data",
    "title": "Model definition",
    "section": "Projection Data",
    "text": "Projection Data\nThe projection data uses the same set of contexts but embeds the content of the prompt under a particular verb. The prompt itself also differs: rather than being about the likelihood of the content, it is about whether a speaker is certainty about that content on a bounded slider from no to yes.\n\n\nLoad the norming data\ndef load_projection_data(fname: str) -&gt; DataFrame:\n    data = read_csv(fname, index_col=0)\n    \n    if \"comments\" in data.columns:\n        data = data.drop(columns=\"comments\")\n\n    data = data[data.trigger_class != \"control\"]\n\n    data[\"itemType\"] = data.fact_type.str.replace(\"fact\", \"\")\n    data[\"item\"] = data.contentNr.astype(str) + data.fact_type.str.replace(\"fact\", \"\")\n    \n    return data\n\ndata_projection = load_projection_data(\n    os.path.join(\n        data_dir, \n        \"projective-probability/results/3-projectivity/data/cd.csv\"\n    )\n)\n\n\n\ndata_projection[[\"workerid\", \"itemType\", \"verb\", \"fact\", \"content\", \"response\"]].head()\n\n\n\n\n\n\n\n\nworkerid\nitem\nverb\nfact\ncontent\nresponse\n\n\n\n\n3\n0\n8H\nestablish\nEmily has been saving for a year\nEmily bought a car yesterday\n0.61\n\n\n4\n0\n12H\nprove\nFrank has always wanted a pet\nFrank got a cat\n0.72\n\n\n5\n0\n20H\nreveal\nCharley lives in Mexico\nCharley speaks Spanish\n0.92\n\n\n6\n0\n19L\nconfirm\nJon lives 10 miles away from work\nJon walks to work\n0.42\n\n\n7\n0\n6H\nacknowledge\nMia is a college student\nMia drank 2 cocktails last night\n0.81\n\n\n\n\n\n\n\nConsidering the responses for a verb like pretend, we see that, consistent with intuition, they tend to fairly heavily bias toward no, with responses for the higher likelihood contexts pushing the distribution slightly toward yes.5\n\ndata_projection_pretend = data_projection.query(\"verb == 'pretend'\")\n\n\n\n\n\n\n\n\nverb\nitemType\ncontent\nfact\nresponse\n\n\n\n\n21\npretend\nL\nOwen shoveled snow last winter\nOwen lives in New Orleans\n0.22\n\n\n35\npretend\nL\nJackson ran 10 miles\nJackson is obese\n0.05\n\n\n60\npretend\nH\nDanny ate the last cupcake\nDanny loves cake\n0.03\n\n\n98\npretend\nH\nJosh learned to ride a bike yesterday\nJosh is a 5-year old boy\n0.55\n\n\n118\npretend\nH\nTony had a drink last night\nTony really likes to party with his friends\n0.43\n\n\n\n\n\n\n\n\n\nPlotting code\np = histplot(\n    data=data_projection_pretend, x=\"response\", hue=\"itemType\", \n    hue_order=[\"L\", \"H\"]\n)\n\n\n\n\n\nIn contrast, for know, we see that, consistent with intuition, responses tend to fairly heavily bias toward yes, with responses for the higher likelihood contexts pushing the distribution slightly more toward yes and the distribution for the lower likelihood responses pushing the distribution slightly more toward no.\n\ndata_projection_know = data_projection.query(\"verb == 'know'\")\n\n\n\n\n\n\n\n\nverb\nitemType\ncontent\nfact\nresponse\n\n\n\n\n15\nknow\nL\nDanny ate the last cupcake\nDanny is a diabetic\n0.97\n\n\n27\nknow\nH\nOwen shoveled snow last winter\nOwen lives in Chicago\n0.12\n\n\n55\nknow\nH\nSophia got a tattoo\nSophia is a hipster\n0.04\n\n\n83\nknow\nH\nJackson ran 10 miles\nJackson is training for a marathon\n0.74\n\n\n121\nknow\nL\nFrank got a cat\nFrank is allergic to cats\n0.61\n\n\n\n\n\n\n\n\n\nPlotting code\np = histplot(\n    data=data_projection_know, x=\"response\", hue=\"itemType\", \n    hue_order=[\"L\", \"H\"]\n)\n\n\n\n\n\nThis qualitatively observed modulation by itemType is indicative of the finding by Degen and Tonhauser (2021) that prior knowledge modulates projection. More broadly, we observe this modulation qualitatively when plotting the distributions for all of the predicates.\n\n\nPlotting code\nfig, ax = subplots(figsize=(11.5, 7))\n\nverb_order = data_projection.groupby(\"verb\").response.mean().sort_values(ascending=False)\n\n_ = boxplot(\n    data_projection, \n    y=\"verb\", x=\"response\", hue=\"itemType\", \n    hue_order=[\"L\", \"H\"], order=verb_order.index, \n    ax=ax, fliersize=0.)\n\n\n\n\n\n\nSparsity in the projection data\nIn both cases, an important thing to note is how sparse these distributions are: the modulation of the projection repsonses by prior beliefs tends to reveal itself in shifts of the probability mass from one extreme of the scale to the other, which is particularly apparent in the case of know. That is, it doesn’t appear as though the effect simply shifts the entire down linearly (or as linearly as possible while retaining the bounding on the scale).\nThis pattern only really becomes apparent when plotting the full distribution. When plotting using–e.g. boxplots–it gets obscured. It is this sparsity that makes the models assuming some discreteness a live possibility.\n\n\nImplementing the models\nEach model of this data will differ only in the likelihood function it defines. All such likelihoods are defined either directly as a truncated normal (the fully gradient model) or as a discrete mixture of truncated normals (the three other models). In each case where we need a mixture, we will use the log_mix.\nWe’ll define these likelihoods in a functions block, so that the other pieces of model code can remain the same across models.\nFully discrete likelihood\nfunctions {\n  real truncated_normal_lpdf(real x, real mu, real sigma, real a, real b) {\n    return normal_lpdf(x | mu, sigma) - \n           log_diff_exp(normal_lcdf(b | mu, sigma), \n                        normal_lcdf(a | mu, sigma));\n  }\n  real log_lik_lpdf(real resp, real verb_prob, real context_prob, real sigma) {\n    real prob_or = 1.0 - (1.0 - verb_prob) * (1.0 - context_prob);\n\n    return log_mix(\n      prob_or,\n      truncated_normal_lpdf(resp | 1, sigma, 0, 1),\n      truncated_normal_lpdf(resp | 0, sigma, 0, 1)\n    );\n  }\n}\nVerb discrete likelihood\nfunctions {\n  real truncated_normal_lpdf(real x, real mu, real sigma, real a, real b) {\n    return normal_lpdf(x | mu, sigma) - \n           log_diff_exp(normal_lcdf(b | mu, sigma), \n                        normal_lcdf(a | mu, sigma));\n  }\n  real log_lik_lpdf(real resp, real verb_prob, real context_prob, real sigma) {\n    return log_mix(\n      verb_prob,\n      truncated_normal_lpdf(resp | 1, sigma, 0, 1),\n      truncated_normal_lpdf(resp | context_prob, sigma, 0, 1)\n    );\n  }\n}\nContext discrete likelihood\nfunctions {\n  real truncated_normal_lpdf(real x, real mu, real sigma, real a, real b) {\n    return normal_lpdf(x | mu, sigma) - \n           log_diff_exp(normal_lcdf(b | mu, sigma), \n                        normal_lcdf(a | mu, sigma));\n  }\n  real log_lik_lpdf(real resp, real verb_prob, real context_prob, real sigma) {\n    return log_mix(\n      context_prob,\n      truncated_normal_lpdf(resp | 1, sigma, 0, 1),\n      truncated_normal_lpdf(resp | verb_prob, sigma, 0, 1)\n    );\n  }\n}\nFully gradient likelihood\nfunctions {\n  real truncated_normal_lpdf(real x, real mu, real sigma, real a, real b) {\n    return normal_lpdf(x | mu, sigma) - \n           log_diff_exp(normal_lcdf(b | mu, sigma), \n                        normal_lcdf(a | mu, sigma));\n  }\n  real log_lik_lpdf(real resp, real verb_prob, real context_prob, real sigma) {\n    real prob_or = 1.0 - (1.0 - verb_prob) * (1.0 - context_prob);\n\n    return truncated_normal_lpdf(resp | prob_or, sigma, 0, 1);\n  }\n}\nThe data block across all models will remain the same.\ndata {\n  int&lt;lower=0&gt; N_resp;                                // number of responses\n  int&lt;lower=0&gt; N_verb;                                // number of verbs\n  int&lt;lower=0&gt; N_context;                             // number of contexts\n  int&lt;lower=0&gt; N_subj;                                // number of subjects\n  vector[N_verb] verb_mean;                           // the verb means inferred from a previous model fit\n  vector[N_verb] verb_std;                            // the verb standard deviations inferred from a previous model fit\n  vector[N_context] context_mean;                     // the context means inferred from the norming data\n  vector[N_context] context_std;                      // the context standard deviations inferred from the norming data\n  int&lt;lower=1,upper=N_verb&gt; verb[N_resp];             // verb corresponding to response n\n  int&lt;lower=1,upper=N_context&gt; context[N_resp];       // context corresponding to response n\n  int&lt;lower=1,upper=N_subj&gt; subj[N_resp];             // subject corresponding to response n\n  vector&lt;lower=0,upper=1&gt;[N_resp] resp;               // bounded slider response   \n}\nThe main thing to note here is that we can specify the estimated parameters \\(\\mu^\\text{context}_c\\) and \\(\\sigma^\\text{context}_c\\) of the posterior over the by-context intercepts.6\nThe parameters and model themselves are defined using what’s known as a non-centered parameterization (Papaspiliopoulos, Roberts, and Sköld 2007). In this sort of parameterization, which is used mainly for practical reasons, we define distributions like \\(\\rho \\sim \\mathcal{N}(\\mu, \\sigma^2)\\) in terms of draws from a standard normal \\(Z \\sim \\mathcal{N}(0, 1)\\) along with a shift and scale by \\(\\mu\\) and \\(\\sigma\\), respectively: \\(\\rho \\equiv \\sigma Z + \\mu\\). This reparameterization works–i.e. when defined in terms of \\(Z\\) in this way, \\(\\rho \\sim \\mathcal{N}(\\mu, \\sigma^2)\\) for reasons mentioned here.\nThis reparameterization is the reason for the _z variables in the parameters block.\nparameters {\n  real&lt;lower=0&gt; verb_intercept_std;                   // the verb random intercept standard deviation\n  vector[N_verb] verb_intercept_z;                    // the verb random intercepts z-score\n  vector[N_context] context_intercept_z;              // the context random intercepts z-score\n  real&lt;lower=0&gt; subj_intercept_verb_std;              // the subject random verb intercept standard deviation\n  vector[N_subj] subj_intercept_verb_z;               // the subject random verb intercepts z-score\n  real&lt;lower=0&gt; subj_intercept_context_std;           // the subject random context intercept standard deviation\n  vector[N_subj] subj_intercept_context_z;            // the subject random context intercepts z-score\n  real&lt;lower=0,upper=1&gt; sigma;                        // the standard deviation of the likelihood\n}\nAnd it’s why the transformed parameters block defines the intercept terms in the way it does.\ntransformed parameters {\n  // verb parameters\n  vector[N_verb] verb_intercept = verb_intercept_std * verb_intercept_z;\n\n  // context parameters\n  vector[N_context] context_intercept = context_std .* context_intercept_z + context_mean;\n\n  // subject parameters\n  vector[N_subj] subj_intercept_verb = subj_intercept_verb_std * subj_intercept_verb_z;\n  vector[N_subj] subj_intercept_context = subj_intercept_context_std * subj_intercept_context_z;\n\n  // log-likelihood\n  vector[N_resp] log_lik;\n  vector[N_resp] verb_prob_by_resp;\n  vector[N_resp] context_prob_by_resp;\n\n  for (n in 1:N_resp) {\n    verb_prob_by_resp[n] = inv_logit(\n      verb_intercept[verb[n]] + subj_intercept_verb[subj[n]]\n    );\n    context_prob_by_resp[n] = inv_logit(\n      context_intercept[context[n]] + subj_intercept_context[subj[n]]\n    );\n    log_lik[n] = log_lik_lpdf(\n      resp[n] | verb_prob_by_resp[n], context_prob_by_resp[n], sigma\n    );\n  }\n}\nOne thing to note about both of these blocks is that we assume by-subject intercepts shifting both the by-context intercepts and the by-verb intercepts. The reasoning here is that particular subjects may tend upweight or downweight the projectivity of verbs in general or they may upweight or downweight the likelihood of the content; and there need not be a correlation between the two.\nNote also that the transformed parameters block is where we compute our (log-)likelihood using the model-specific likelihood specified in the functions block.\nThe model block then simply specifies the random effects assumptions and adds the likelihood for each response to target.\nmodel {\n  // sample the verb intercepts\n  verb_intercept_std ~ exponential(1);\n  verb_intercept_z ~ std_normal();\n\n  // sample the context intercepts\n  context_intercept_z ~ std_normal();\n\n  // sample the subject intercepts\n  subj_intercept_verb_std ~ exponential(1);\n  subj_intercept_verb_z ~ std_normal();\n\n  subj_intercept_context_std ~ exponential(1);\n  subj_intercept_context_z ~ std_normal();\n  \n  // sample the responses\n  for (n in 1:N_resp)\n    target += log_lik[n];\n}\nThe generated quantities block does something similar to our model for the norming data by computing \\(\\pi^\\text{context}_c\\)–additionally computing \\(\\pi^\\text{verb}_v\\).\ngenerated quantities {\n  vector[N_verb] verb_prob = inv_logit(\n    verb_intercept\n  );\n\n  vector[N_context] context_prob = inv_logit(\n    context_intercept\n  );\n}"
  },
  {
    "objectID": "projective-content/model-definition.html#additional-experiments",
    "href": "projective-content/model-definition.html#additional-experiments",
    "title": "Model definition",
    "section": "Additional experiments",
    "text": "Additional experiments\nTo further evaluate our models of the data collected by Degen and Tonhauser (2021), we’ll look at a couple of additional (unpublished) datasets–collected by Grove and White (in prep)–that combine the prompt used by Degen and Tonhauser with the item construction method used for the MegaVeridicality and MegaIntentionsality datasets. In both cases, we attempt to remove all information that one might use for forming prior beliefs about the contents of the complement in order to assess how well the models fit to Degen and Tonhauser’s capture information about the verb.\nThe main difference between the model we’ll use for these datasets and the one we developed for Degen and Tonhauser’s data is that, rather than specifying context-specific priors on the context intercepts, we will specify verb-specific priors on the verb intercepts. We’ll derive the estimates for these priors from our fits to Degen and Tonhauser’s projection data in the same way we estimated the context-specific priors from the our fits to their norming data.\nImplementing this idea requires two small changes to the parameters block: (a) adding a context_intercept_std for the prior over context intercepts and (b) removing the verb_intercept_std, since it is specified.\nparameters {\n  vector[N_verb] verb_intercept_z;                    // the verb random intercepts z-score\n  real&lt;lower=0&gt; context_intercept_std;                // the context random intercept standard deviation\n  vector[N_context] context_intercept_z;              // the context random intercepts z-score\n  real&lt;lower=0&gt; subj_intercept_verb_std;              // the subject random verb intercept standard deviation\n  vector[N_subj] subj_intercept_verb_z;               // the subject random verb intercepts z-score\n  real&lt;lower=0&gt; subj_intercept_context_std;           // the subject random context intercept standard deviation\n  vector[N_subj] subj_intercept_context_z;            // the subject random context intercepts z-score\n  real&lt;lower=0,upper=1&gt; sigma;                        // the standard deviation of the likelihood\n}\nIn the transformed parameters block, we similarly need to flip how we deal with by-verb and by-context intercepts. The rest remains the same.\ntransformed parameters {\n  // verb parameters\n  vector[N_verb] verb_intercept = verb_std .* verb_intercept_z + verb_mean;\n\n  // context parameters\n  vector[N_context] context_intercept = context_intercept_std * context_intercept_z;\n\n  // subject parameters\n  vector[N_subj] subj_intercept_verb = subj_intercept_verb_std * subj_intercept_verb_z;\n  vector[N_subj] subj_intercept_context = subj_intercept_context_std * subj_intercept_context_z;\n\n  // log-likelihood\n  vector[N_resp] log_lik;\n  vector[N_resp] verb_prob_by_resp;\n  vector[N_resp] context_prob_by_resp;\n\n  for (n in 1:N_resp) {\n    verb_prob_by_resp[n] = inv_logit(\n      verb_intercept[verb[n]] + subj_intercept_verb[subj[n]]\n    );\n    context_prob_by_resp[n] = inv_logit(\n      context_intercept[context[n]] + subj_intercept_context[subj[n]]\n    );\n    log_lik[n] = log_lik_lpdf(\n      resp[n] | verb_prob_by_resp[n], context_prob_by_resp[n], sigma\n    );\n  }\n}\nFinally, we need to do something similar in the model block.\nmodel {\n  // sample the verb intercepts\n  verb_intercept_z ~ std_normal();\n\n  // sample the context intercepts\n  context_intercept_std ~ exponential(1);\n  context_intercept_z ~ std_normal();\n\n  // sample the subject intercepts\n  subj_intercept_verb_std ~ exponential(1);\n  subj_intercept_verb_z ~ std_normal();\n\n  subj_intercept_context_std ~ exponential(1);\n  subj_intercept_context_z ~ std_normal();\n  \n  // sample the responses\n  for (n in 1:N_resp)\n    target += log_lik[n];\n}\n\nBleached contexts\nIn our bleached context experiments–which use an item construction method analogous to the one used for MegaVeridicality by White and Rawlins (2018)–we use an analogous prompt to the one that Degen and Tonhauser use, where \\(P_1\\) and \\(P_2\\) are replaced with randomly selected names and \\(V\\) is replaced with one of the verbs from the original experiment.\n\nYou are at a party. You walk into the kitchen and overhear \\(P_1\\) ask somebody else a question. \\(P_1\\) doesn’t know you and wants to be secretive, so speaks in somewhat coded language.\n\n\n\\(P_1\\) asks: “Did \\(P_2\\) \\(V\\) that a particular thing happened?”\n\n\nIs \\(P_1\\) certain that that thing happened?\n\n\n\nLoad the bleached data\ndata_projection_bleached = load_projection_data(\n    os.path.join(\n        data_dir, \n        \"projective-probability-replication/bleached.csv\"\n    )\n)\n\n\nThe correlation between the mean response in this experiment and the one in Degen and Tonhauser’s experiment is extremely high.\n\n\nPlotting code\nfrom scipy.stats import pearsonr\nfrom pandas import merge\nfrom seaborn import scatterplot\n\nax = subplot()\n\nbleached_verb_mean = data_projection_bleached.groupby(\"verb\").response.mean()\ncontentful_verb_mean = data_projection.groupby(\"verb\").response.mean()\n\nverb_means_bleached = merge(\n    bleached_verb_mean, contentful_verb_mean, \n    left_index=True, right_index=True\n).rename(columns={\n    \"response_x\": \"Mean bleached response\",\n    \"response_y\": \"Mean contentful response\"\n})\n\nscatterplot(verb_means_bleached, x=\"Mean contentful response\", y=\"Mean bleached response\", ax=ax)\n\nr, p = pearsonr(x=verb_means_bleached[\"Mean contentful response\"], y=verb_means_bleached[\"Mean bleached response\"])\n_ = ax.text(.5, .05, \"Pearson's r = {:.2f}\".format(r), fontdict={\"fontsize\": 16}, transform=ax.transAxes)\n\n\n\n\n\n\n\nTemplatic contexts\nIn our templatic context experiments–which use an item construction method analogous to the one used for MegaVeridicality by Kane, Gantt, and White (2022)–we also use an analogous prompt to the one that Degen and Tonhauser use, where \\(P_1\\) and \\(P_2\\) are replaced with randomly selected names and \\(V\\) is replaced with one of the verbs from the original experiment.\n\nYou are at a party. You walk into the kitchen and overhear \\(P_1\\) ask somebody else a question. The party is very noisy, and you only hear part of what is said. The part you don’t hear is represented by the ‘X’.\n\n\n\\(P_1\\) asks: “Did \\(P_2\\) \\(V\\) that X happened?”\n\n\nIs \\(P_1\\) certain that X happened?\n\n\n\nLoad the templatic data\ndata_projection_templatic = load_projection_data(\n    os.path.join(\n        data_dir, \n        \"projective-probability-replication/templatic.csv\"\n    )\n)\n\n\nWe again see an extremely high correlation between the mean response in this experiment and the one in Degen and Tonhauser’s experiment.\n\n\nPlotting code\nfrom scipy.stats import pearsonr\nfrom pandas import merge\nfrom seaborn import scatterplot\n\nax = subplot()\n\ntemplatic_verb_mean = data_projection_templatic.groupby(\"verb\").response.mean()\n\nverb_means_templatic = merge(\n    templatic_verb_mean, contentful_verb_mean, \n    left_index=True, right_index=True\n).rename(columns={\n    \"response_x\": \"Mean templatic response\",\n    \"response_y\": \"Mean contentful response\"\n})\n\nscatterplot(verb_means_templatic, x=\"Mean contentful response\", y=\"Mean templatic response\", ax=ax)\n\nr, p = pearsonr(x=verb_means_templatic[\"Mean contentful response\"], y=verb_means_templatic[\"Mean templatic response\"])\n_ = ax.text(.5, .05, \"Pearson's r = {:.2f}\".format(r), fontdict={\"fontsize\": 16}, transform=ax.transAxes)"
  },
  {
    "objectID": "projective-content/model-definition.html#footnotes",
    "href": "projective-content/model-definition.html#footnotes",
    "title": "Model definition",
    "section": "Footnotes",
    "text": "Footnotes\n\n\nAs Degen and Tonhauser (2022, 583) note this assumption seems to be the default, and it is made explicitly in work by, at least, Karttunen et al. (2014) and Spector and Egré (2015).↩︎\nThese forms can be derived from an application of de Morgan’s laws \\(p \\lor p' = \\lnot\\lnot(p \\lor p') = \\lnot(\\lnot p \\land \\lnot p')\\) plus an assumption that \\(p\\) and \\(p'\\) parameterize independent Bernoulli distributions.↩︎\nImportantly, the truncated normal does not behave like the logit-normal distribution, we saw here in the course notes on statistical inference. As the variance of a truncated normal increases, it tends toward a \\(\\mathcal{U}(a, b)\\) distribution. In contrast, when the variance of a logit-normal increases, it tends toward a \\(\\text{Bernoulli}(\\text{logit}^{-1}(\\mu_n))\\) distribution. Further, the logit-normal technically only has support on \\((0, 1)\\), making it a similarly bad candidate for our linking model.↩︎\nWe additionally specify fairly strong \\(\\text{Exponential}(1)\\) priors on the random effect standard deviations that are necessary for practical reasons having to do with model fitting.↩︎\nI’m following the terminology used by the data in calling this column the verb column. This terminology isn’t quite right, since there are non-verbal predicates–e.g. be right–in the data.↩︎\nWe can specify similar parameters \\(\\mu^\\text{verb}_v\\) and \\(\\sigma^\\text{verb}_v\\). We’ll return to this possibility in a second.↩︎"
  },
  {
    "objectID": "projective-content/model-fitting-and-comparison.html",
    "href": "projective-content/model-fitting-and-comparison.html",
    "title": "Model fitting and comparison",
    "section": "",
    "text": "As in Module 1, we will implement a relatively thin wrapper around cmdstanpy’s CmdStanModel class. This abstract base class (ABC) is effectively the same as our IslandEffectsModel ABC. The important differences are: (i) that it accepts kwargs in StanModel.__init__, which we will use to pass in information for setting the priors on the by-context or by-verb intercepts; and (ii) that we don’t implement a default StanModel.construct_model_data method. The reason for not implementing this method is that we will use StanModel as an ABC for both the norming models and the projection models.\nfrom abc import ABC, abstractmethod, abstractproperty\nfrom typing import Optional\nfrom cmdstanpy import CmdStanModel\nfrom typing import Optional\nfrom enum import Enum\nfrom dataclasses import dataclass\nfrom pandas import DataFrame\nfrom arviz import InferenceData, from_cmdstanpy\n\nclass StanModel(ABC):\n    \"\"\"An abstract base class for STAN models\"\"\"\n\n    def __init__(self, **kwargs):\n        self.model = CmdStanModel(stan_file=self.stan_file)\n        self.init_params = kwargs\n\n    @abstractproperty\n    def stan_file(self) -&gt; str: \n        raise NotImplementedError\n        \n    @abstractmethod\n    def construct_model_data(self, data: DataFrame) -&gt; dict:\n        raise NotImplementedError\n\n    def _validate_data(self) -&gt; None:\n        self.data_class(**self.model_data)\n\n    def fit(\n        self, \n        data: DataFrame,\n        save_dir: Optional[str] = None,\n        verbose: bool = False,\n        map_initialization: bool = True,\n        seed: int = 40392,\n        iter_warmup: int = 50_000,\n        iter_sampling: int = 50_000,\n        **kwargs\n    ) -&gt; InferenceData:\n        if verbose:\n            print(\"Constructing model data...\")\n            \n        self.model_data = self.construct_model_data(data)\n        \n        self._validate_data()\n        \n        if map_initialization:\n            if verbose:\n                print(\"Fitting model with MAP initialization...\")\n\n            map_estimate = self._compute_map_estimate(seed)\n            \n            if \"inits\" in kwargs:\n                # inits passed to fit() should override MAP\n                map_estimate.update(kwargs[\"inits\"])\n\n            kwargs[\"inits\"] = map_estimate\n        \n        elif verbose:\n            print(\"Fitting model...\")\n        \n        # sample from the posterior starting at the MAP\n        self.raw_model_fit = self.model.sample(\n            data=self.model_data,\n            iter_warmup=iter_warmup,\n            iter_sampling=iter_sampling,\n            **kwargs\n        )\n    \n        if save_dir is not None:\n            if verbose:\n                print(\"Saving model...\")\n\n            self.save(save_dir)\n            \n        if verbose:\n            print(\"Running MCMC diagnostics...\")\n            print()\n            print(self.diagnose())\n    \n        return self\n    \n    def _compute_map_estimate(self, seed: int) -&gt; dict:\n        # compute MAP fit\n        self.map_model_fit = self.model.optimize(\n            data=self.model_data,\n            seed=seed,\n        )\n\n        return self.map_model_fit.stan_variables()\n    \n    @property\n    def model_fit(self) -&gt; InferenceData:\n        return from_cmdstanpy(\n            self.raw_model_fit,\n            coords=self.coords,\n            dims=self.dims\n        )\n    \n    def save(self, save_dir: str = \".\"):\n        self.raw_model_fit.save_csvfiles(save_dir)\n    \n    @classmethod\n    def from_csv(cls, path: str, **kwargs) -&gt; 'StanModel':\n        model = cls(**kwargs)\n        model.raw_model_fit = cmdstanpy.from_csv(path)\n        \n    def diagnose(self) -&gt; str:\n        return self.raw_model_fit.diagnose()\nAlso as in Module 1, we’ll want a way of mapping (or hashing) columns of our data to indices, which we’ll use for hashing verb, context, and subject identifiers. This version of hash_series additionally allows us to specify the hashmap via the categories parameter, which will be necessary for ensuring we are associating the correct prior on by-context intercepts with the correct context.\nfrom numpy import ndarray\nfrom pandas import Series, CategoricalDtype\n\ndef hash_series(series: Series, categories: Optional[list[str]] = None, indexation: int=1) -&gt; tuple[ndarray, ndarray]:\n    \"\"\"Hash a series to numeric codes\n    \n    Parameters\n    ----------\n    column\n        The series to hash\n    index\n        The starting index (defaults to 1)\n    \"\"\"\n    # enforce 0- or 1-indexation\n    if indexation not in [0, 1]:\n        raise ValueError(\"Must choose either 0- or 1-indexation.\")\n    \n    # convert the series to a category\n    if categories is None:\n        category_series = series.astype(\"category\")\n    else:\n        cat_type = CategoricalDtype(categories=categories)\n        category_series = series.astype(cat_type)\n    \n    # get the hash\n    hash_map = category_series.cat.categories.values\n    \n    # map to one-indexed codes\n    hashed_series = (category_series.cat.codes + indexation).values\n    \n    return hash_map, hashed_series"
  },
  {
    "objectID": "projective-content/model-fitting-and-comparison.html#model-of-prior-beliefs",
    "href": "projective-content/model-fitting-and-comparison.html#model-of-prior-beliefs",
    "title": "Model fitting and comparison",
    "section": "Model of prior beliefs",
    "text": "Model of prior beliefs\nOur model for estimating prior beliefs from Degen and Tonhauser’s norming data will subclass StanModel ABC and look similar to the models we wrote for Module 1. The main addition we make is a property NormingModel.context_posterior_estimates which returns estimates of \\(\\mu^\\text{context}_c\\) and \\(\\sigma^\\text{context}_c\\), assuming that \\(\\rho_c \\mid \\mathbf{y}_\\text{norming} \\sim \\mathcal{N}(\\mu^\\text{context}_c, \\sigma^\\text{context}_c)\\).\n\nfrom scipy.stats import norm\nfrom pandas import merge\n\n@dataclass\nclass NormingData:\n    N_resp: int                  # number of responses\n    N_context: int               # number of contexts\n    N_subj: int                  # number of subjects\n    context: ndarray             # context corresponding to response n\n    subj: ndarray                # subject who gave response n\n    resp: ndarray                # likert scale acceptability judgment responses\n\nclass NormingModel(StanModel):\n    \"\"\"A STAN model for Degen and Tonhauser's (2021) norming data\"\"\"\n    \n    stan_file = \"models/norming-model/norming-model.stan\"\n    data_class = NormingData\n    \n    def __init__(self):\n        super().__init__()\n    \n    def construct_context_info(self, data: DataFrame):\n        self.context_info = data[[\"item\", \"prompt\", \"fact\"]].drop_duplicates(ignore_index=True)\n        self.context_info = self.context_info.rename(columns={\"item\": \"context\"})\n    \n    def construct_model_data(self, data: DataFrame):\n        self.construct_context_info(data)\n        \n        if hasattr(self, \"subj_hash_map\"):\n            _, subj_hashed = hash_series(data.workerid, self.subj_hash_map)\n        else:\n            self.subj_hash_map, subj_hashed = hash_series(data.workerid)\n            \n        if hasattr(self, \"context_hash_map\"):\n            _, context_hashed = hash_series(data.item, self.context_hash_map)\n        else:\n            self.context_hash_map, context_hashed = hash_series(data.item)\n        \n        self.coords = {\n            \"subj\": self.subj_hash_map,\n            \"context\": self.context_hash_map\n        }\n        \n        self.dims = {\n            \"context_intercept\": [\"context\"],\n            \"context_prob\": [\"context\"],\n        }\n        \n        self.model_data = {\n            \"N_resp\": data.shape[0],\n            \"N_context\": self.context_hash_map.shape[0],\n            \"N_subj\": self.subj_hash_map.shape[0],\n            \"context\": context_hashed,\n            \"subj\": subj_hashed,\n            \"resp\": data.response.astype(float).values\n        }\n        \n        return self.model_data\n    \n    @property\n    def context_posterior_estimates(self):\n        context_intercept_samples = self.raw_model_fit.stan_variable(\"context_intercept\")\n\n        params = []\n\n        for i in range(context_intercept_samples.shape[1]):\n            mu, sigma = norm.fit(context_intercept_samples[:,i])\n            context = self.context_hash_map[i]\n            params.append([context, mu, sigma])\n\n        params_df = DataFrame(params, columns=[\"context\", \"context_mean\", \"context_std\"])\n        params_df[\"order\"] = params_df.index\n        params_df = merge(params_df, self.context_info).sort_values(\"order\")\n\n        return params_df[[\"fact\", \"context\", \"prompt\", \"context_mean\", \"context_std\", \"order\"]]\n\n\n\nLoad norming data\nimport os\nfrom pandas import read_csv\n\ndata_dir = \"data/\"\n\ndef load_norming_data(fname: str) -&gt; DataFrame:\n    data = read_csv(fname, index_col=0)\n\n    data = data[~data.item.isin([\"F1\", \"F2\"])]\n    \n    return data.drop(columns=\"comments\")\n\ndata_norming = load_norming_data(\n    os.path.join(\n        data_dir, \n        \"projective-probability/results/1-prior/data/cd.csv\"\n    )\n)\n\n\n\n\nSilence STAN logger\nimport logging\nlogger = logging.getLogger('cmdstanpy')\nlogger.addHandler(logging.NullHandler())\nlogger.propagate = False\nlogger.setLevel(logging.CRITICAL)\n\n\n\nFitting the model\nWe can then fit this model to the norming data.\n\nnorming_model = NormingModel()\n_ = norming_model.fit(\n    data_norming, map_initialization=False\n)\n\n\n\nInvestigating the fit\nIn plotting the posterior samples for \\(\\rho^\\text{context}_c\\), we observe a clear effect of itemType–both in log-odds space…\n\nfrom arviz import plot_forest\n\n_ = plot_forest(\n    norming_model.model_fit,\n    var_names=[\"context_intercept\"],\n    combined=True,\n    figsize=(11.5, 10)\n)\n\n\n\n\n…and in probability space.\n\n_ = plot_forest(\n    norming_model.model_fit,\n    var_names=[\"context_prob\"],\n    combined=True,\n    figsize=(11.5, 10)\n)\n\n\n\n\nIf we look at the concrete example we looked at here, we see that these posterior estimates accord with expectation.\n\nfrom scipy.special import expit\nfrom pandas import merge, melt\n\n# the norming data for 10H and 10L\ndata_norming_sub = data_norming.query('item.isin([\"10H\", \"10L\"])')\n\n# the samples from the posterior for 10H and 10L\nsamples = DataFrame(\n    norming_model.raw_model_fit.stan_variable(\"context_intercept\"),\n    columns=norming_model.context_hash_map\n)\n\nsamples = merge(\n    melt(samples, var_name=\"context\", value_name=\"logodds\"), \n    norming_model.context_info\n)\n\nsamples[\"prob\"] = expit(samples.logodds)\n\nsamples[\"itemType\"] = samples.context.map(lambda x: x[-1])\n\nsamples_sub = samples.query('context.isin([\"10H\", \"10L\"])')\n\n\n\n\n\n\n\n\ncontext\nfact\nprompt\nlogodds\nprob\n\n\n\n\n0\n10H\nZoe is a math major.\nHow likely is it that Zoe calculated the tip?\n1.85264\n0.864437\n\n\n1\n10H\nZoe is a math major.\nHow likely is it that Zoe calculated the tip?\n1.72780\n0.849131\n\n\n2\n10H\nZoe is a math major.\nHow likely is it that Zoe calculated the tip?\n1.79174\n0.857140\n\n\n3\n10H\nZoe is a math major.\nHow likely is it that Zoe calculated the tip?\n1.88675\n0.868385\n\n\n4\n10H\nZoe is a math major.\nHow likely is it that Zoe calculated the tip?\n1.72497\n0.848768\n\n\n...\n...\n...\n...\n...\n...\n\n\n15995\n10L\nZoe is 5 years old.\nHow likely is it that Zoe calculated the tip?\n-7.80021\n0.000409\n\n\n15996\n10L\nZoe is 5 years old.\nHow likely is it that Zoe calculated the tip?\n-6.95483\n0.000953\n\n\n15997\n10L\nZoe is 5 years old.\nHow likely is it that Zoe calculated the tip?\n-3.82970\n0.021255\n\n\n15998\n10L\nZoe is 5 years old.\nHow likely is it that Zoe calculated the tip?\n-5.37417\n0.004613\n\n\n15999\n10L\nZoe is 5 years old.\nHow likely is it that Zoe calculated the tip?\n-5.15523\n0.005736\n\n\n\n\n16000 rows × 5 columns\n\n\n\n\n\nPlotting code\nfrom matplotlib.pyplot import subplots\nfrom seaborn import histplot\n\nfig, (ax1, ax2) = subplots(1, 2, figsize=(10, 4))\nfig.suptitle(\"How likely is it that Zoe calculated the tip?\")\n\nax1.set_title(\"Distribution of responses\")\n\np = histplot(\n    data=data_norming_sub, x=\"response\", hue=\"fact\", \n    hue_order=[\"Zoe is 5 years old.\", \"Zoe is a math major.\"],\n    bins=15,\n    ax=ax1,\n    stat=\"density\"\n)\n\nax2.set_title(\"Samples from the posterior\")\n\np = histplot(\n    data=samples_sub, x=\"prob\", hue=\"fact\",\n    hue_order=[\"Zoe is 5 years old.\", \"Zoe is a math major.\"],\n    bins=30,\n    ax=ax2,\n    stat=\"density\"\n)\n\n\n\n\n\nNote that the posterior samples are for what amounts to the mean response, so we don’t expect the distribution of samples to be the same as the distribution of responses.\n\n\nEstimating context-specific priors\nOur aim in fitting this model is to be able to estimate context-specific priors. Ideally, we could just use the samples from the prior visualized above, but we can’t for practical reasons: STAN needs a known functional form for the prior. That is the point of trying to estimate \\(\\mu^\\text{context}_c\\) and \\(\\sigma^\\text{context}_c\\) under the assumption that \\(\\rho_c \\mid \\mathbf{y}_\\text{norming} \\sim \\mathcal{N}(\\mu^\\text{context}_c, \\sigma^\\text{context}_c)\\).\n\ncontext_posterior_estimates = norming_model.context_posterior_estimates\ncontext_posterior_estimates[\"itemType\"] = context_posterior_estimates.context.map(lambda x: x[-1])\ncontext_posterior_estimates = context_posterior_estimates.set_index(\"context\")\n\n\n\nPlotting code\np = histplot(\n    data=context_posterior_estimates, x=\"context_mean\",\n    hue=\"itemType\", hue_order=[\"L\", \"H\"], bins=15\n)\n\np.set_title(\"Distribution of means for context-specific priors\")\n_ = p.set_xlabel(r\"$\\mu_c$\")\n\n\n\n\n\nTo assess how good this assumption of normality is, we can compare the empirical CDF derived from the posterior samples with the normal CDF implied by \\(\\mu^\\text{context}_c\\) and \\(\\sigma^\\text{context}_c\\) for a particular context \\(c\\).\nWhen \\(\\mu_c\\) is in the middle of the scale, the normal approximation is effectively perfect.\n\n\nPlotting code\nfrom numpy import mgrid\nfrom scipy.special import logit\nfrom statsmodels.distributions.empirical_distribution import ECDF\nfrom matplotlib.pyplot import subplot, Axes\n\ndef plot_context_intercept_posterior(context_id: str, ax: Axes, axis: str=\"unit\", plot_diff: bool=True):\n    context_estimates = context_posterior_estimates.loc[context_id]\n    \n    estimated_dist = norm(context_estimates.context_mean, context_estimates.context_std)\n    \n    samples = norming_model.raw_model_fit.stan_variable(\"context_intercept\")[:,context_estimates.order]\n    \n    if axis == \"unit\":\n        x_axis = mgrid[0.01:1:0.01]\n        \n        samples = expit(samples)\n        \n        ax.plot(\n            x_axis, \n            ECDF(samples)(x_axis),\n            label=\"ECDF\"\n        )\n        \n        ax.plot(\n            x_axis, \n            estimated_dist.cdf(logit(x_axis)), \n            label=\"Normal approximation\"\n        )\n    \n        if plot_diff:\n            ax.plot(\n                x_axis, \n                ECDF(samples)(x_axis) - estimated_dist.cdf(logit(x_axis)),\n                label=\"difference\"\n            )\n        \n    elif axis==\"reals\":\n        x_axis = mgrid[samples.min():samples.max():0.01]\n        \n        ax.plot(\n            x_axis, \n            ECDF(samples)(x_axis),\n            label=\"ECDF\"\n        )\n        \n        ax.plot(\n            x_axis, estimated_dist.cdf(x_axis),\n            label=\"Normal approximation\"\n        )\n        \n        if plot_diff:\n            ax.plot(\n                x_axis, \n                ECDF(samples)(x_axis) - estimated_dist.cdf(x_axis),\n                label=\"Difference\"\n            )\n        \n    else:\n        raise ValueError(\"'axis' must be \\\"unit\\\" or \\\"reals\\\".\")\n    \n    return ax\n\nfig, (ax1, ax2) = subplots(1, 2, figsize=(10, 4))\nfig.suptitle(\"Josh is a 5-year old boy.\\nHow likely is it that Josh learned to ride a bike yesterday?\")\n\nplot_context_intercept_posterior(\"16H\", axis=\"reals\", ax=ax1)\nplot_context_intercept_posterior(\"16H\", axis=\"unit\", ax=ax2)\n\nax1.legend()\n\nax1.set_xlabel(\"Log-odds\")\n_ = ax2.set_xlabel(\"Probability\")\n\n\n\n\n\nWhen the likelihood is low, the approximation is slightly worse, though it remains quite good.\n\nfig, (ax1, ax2) = subplots(1, 2, figsize=(10, 4))\nfig.suptitle(\"Isabella is a vegetarian.\\nHow likely is it that Isabella ate a steak on Sunday?\")\n\nplot_context_intercept_posterior(\"7L\", axis=\"reals\", ax=ax1)\nplot_context_intercept_posterior(\"7L\", axis=\"unit\", ax=ax2)\n\nax1.legend()\n\nax1.set_xlabel(\"Log-odds\")\n_ = ax2.set_xlabel(\"Probability\")\n\n\n\n\nA similar phenomenon is observed when the mean is high–though, again, the approximation remains quite good.\n\n\nPlotting code\nfig, (ax1, ax2) = subplots(1, 2, figsize=(10, 4))\nfig.suptitle(\"Mary is taking a prenatal yoga class.\\nHow likely is it that Mary is pregnant?\")\n\nplot_context_intercept_posterior(\"1H\", axis=\"reals\", ax=ax1)\nplot_context_intercept_posterior(\"1H\", axis=\"unit\", ax=ax2)\n\nax1.legend()\n\nax1.set_xlabel(\"Log-odds\")\n_ = ax2.set_xlabel(\"Probability\")"
  },
  {
    "objectID": "projective-content/model-fitting-and-comparison.html#models-of-projection",
    "href": "projective-content/model-fitting-and-comparison.html#models-of-projection",
    "title": "Model fitting and comparison",
    "section": "Models of projection",
    "text": "Models of projection\nTurning now to the models of the projection data: we’ll also implement these as a subclass of our StanModel ABC. Because there are a few different versions of this model we’ll want to use–one that uses context-specific priors and another that uses verb-specific priors–we’ll need to set this class up in a slightly more complicated way. Basically, we’ll store different blocks of STAN code in different files and have class construct the full model specification on the fly based on the parameters to ProjectionModel.__init__.\nTo actually use the estimates for context- or verb-specific priors from some other model fit, we’ll additionally need to pass that fit model to ProjectionModel.__init__. This makes the initialization logic–as well as the data construction logic–somewhat complex, while keeping the core fitting procedure the same.\n\nfrom numpy import zeros, ones\n\n@dataclass\nclass ProjectionData(NormingData):\n    N_verb: int                           # number of verbs\n    verb: ndarray                         # verb corresponding to response n\n    verb_mean: ndarray                    # the verb means inferred from a previous model fit\n    verb_std: ndarray                     # the verb standard deviations inferred from a previous model fit\n    context_mean: ndarray                 # the context means inferred from the norming data\n    context_std: ndarray                  # the context standard deviations inferred from the norming data\n\n\nfrom typing import Union\n\nparameters_and_model_block_files = {\n    \"no_priors_fixed\": \"parameters-and-model-block.stan\",\n    \"verb_priors_fixed\": \"parameters-and-model-block-verb-prior-fixed.stan\",\n    \"context_priors_fixed\": \"parameters-and-model-block-context-prior-fixed.stan\",\n    \"both_priors_fixed\": \"parameters-and-model-block-context-and-verb-priors-fixed.stan\",\n}\n\nclass ProjectionModel(StanModel):\n    stan_data_block_file = \"models/projection-model/data-block.stan\"\n    stan_generated_quantities_block_file = \"models/projection-model/generated-quantities-block.stan\"\n    \n    data_class = ProjectionData\n    \n    def __init__(\n        self, prior_model: Optional[Union[NormingModel, 'ProjectionModel']] = None, \n        use_context_prior: bool = True\n    ):\n        self.prior_model = prior_model\n        \n        self.use_context_priors = use_context_prior and prior_model is not None\n        self.use_verb_priors = hasattr(\n            prior_model, \"verb_posterior_estimates\"\n        )\n        \n        if self.use_context_priors and self.use_verb_priors:\n            print(\"Model initialized with context- and verb-specific priors derived \"\n                  \"from context- and verb-specific posteriors from prior_model.\")\n            self.context_hash_map = prior_model.context_hash_map\n            self.verb_hash_map = prior_model.verb_hash_map\n            \n            self.stan_parameters_and_model_block_file = os.path.join(\n                \"models/projection-model/parameters-and-model-block/\", \n                parameters_and_model_block_files[\"both_priors_fixed\"]\n            )\n        \n        elif self.use_context_priors:\n            print(\"Model initialized with context-specific priors derived \"\n                  \"from context-specific posteriors from prior_model.\")\n            self.context_hash_map = prior_model.context_hash_map\n            \n            self.stan_parameters_and_model_block_file = os.path.join(\n                \"models/projection-model/parameters-and-model-block/\", \n                parameters_and_model_block_files[\"context_priors_fixed\"]\n            )\n        \n        elif self.use_verb_priors:\n            print(\"Model initialized with verb-specific priors derived \"\n                  \"from verb-specific posteriors from prior_model.\")\n            self.verb_hash_map = prior_model.verb_hash_map\n            \n            self.stan_parameters_and_model_block_file = os.path.join(\n                \"models/projection-model/parameters-and-model-block/\", \n                parameters_and_model_block_files[\"verb_priors_fixed\"]\n            )\n            \n        else:\n            self.stan_parameters_and_model_block_file = os.path.join(\n                \"models/projection-model/parameters-and-model-block/\", \n                parameters_and_model_block_files[\"no_priors_fixed\"]\n            )\n            \n        self._write_stan_file()\n            \n        super().__init__()\n    \n    def _write_stan_file(self):\n        functions_block = open(self.stan_functions_block_file, \"r\").read()\n        data_block = open(self.stan_data_block_file, \"r\").read()\n        parameters_and_model_block = open(self.stan_parameters_and_model_block_file, \"r\").read()\n        generated_quantities_block = open(self.stan_generated_quantities_block_file, \"r\").read()\n        \n        print(f\"Writing STAN file to {self.stan_file}...\")\n        \n        with open(self.stan_file, \"w\") as f:\n            f.write(functions_block+\"\\n\\n\")\n            f.write(data_block+\"\\n\\n\")\n            f.write(parameters_and_model_block+\"\\n\\n\")\n            f.write(generated_quantities_block)\n    \n    @abstractproperty\n    def stan_functions_block_file(self):\n        raise NotImplementedError\n    \n    def construct_context_info(self, data: DataFrame):\n        if hasattr(self.prior_model, \"context_info\"):\n            self.context_info = self.prior_model.context_info\n        else:\n            data[\"prompt\"] = data[\"content\"]\n            NormingModel.construct_context_info(self, data)\n    \n    def construct_model_data(self, data: DataFrame):\n        self.model_data = NormingModel.construct_model_data(self, data)\n        \n        if hasattr(self, \"verb_hash_map\"):\n            _, verb_hashed = hash_series(data.verb, self.verb_hash_map)\n        else:\n            self.verb_hash_map, verb_hashed = hash_series(data.verb)\n        \n        self.coords.update({\n            \"verb\": self.verb_hash_map\n        })\n        \n        self.dims.update({\n            \"verb_intercept\": [\"verb\"],\n            \"verb_prob\": [\"verb\"]\n        })\n        \n        self.model_data.update({\n            \"N_verb\": self.verb_hash_map.shape[0],\n            \"verb\": verb_hashed\n        })\n        \n        if self.use_context_priors:\n            self.model_data.update({\n                \"context_mean\": self.context_prior_estimates.context_mean.values,\n                \"context_std\": self.context_prior_estimates.context_std.values\n            })\n        else:\n            self.model_data.update({\n                \"context_mean\": zeros(self.model_data[\"N_context\"]),\n                \"context_std\": ones(self.model_data[\"N_context\"]),\n            })\n        \n        if self.use_verb_priors:\n            self.model_data.update({\n                \"verb_mean\": self.verb_prior_estimates.verb_mean.values,\n                \"verb_std\": self.verb_prior_estimates.verb_std.values,\n            })\n        else:\n            self.model_data.update({\n                \"verb_mean\": zeros(self.model_data[\"N_verb\"]),\n                \"verb_std\": ones(self.model_data[\"N_verb\"]),\n            })\n\n        return self.model_data\n        \n    @property\n    def context_prior_estimates(self):\n        if self.use_context_priors:\n            return self.prior_model.context_posterior_estimates\n        else:\n            raise AttributeError(\"no prior_model supplied for context priors\")\n    \n    @property\n    def context_posterior_estimates(self):\n        context_intercept_samples = self.raw_model_fit.stan_variable(\"context_intercept\")\n\n        params = []\n\n        for i in range(context_intercept_samples.shape[1]):\n            mu, sigma = norm.fit(context_intercept_samples[:,i])\n            context = self.context_hash_map[i]\n            params.append([context, mu, sigma])\n\n        params_df = DataFrame(params, columns=[\"context\", \"context_mean\", \"context_std\"])\n        params_df[\"order\"] = params_df.index\n        params_df = merge(params_df, self.context_info).sort_values(\"order\")\n\n        return params_df[[\"fact\", \"context\", \"prompt\", \"context_mean\", \"context_std\", \"order\"]]\n\n            \n    @property\n    def verb_prior_estimates(self):\n        if self.use_verb_priors:\n            return self.prior_model.verb_posterior_estimates\n        else:\n            raise AttributeError(\"prior_model must have verb_posterior_estimates\")\n            \n    @property\n    def verb_posterior_estimates(self):\n        verb_intercept_samples = self.raw_model_fit.stan_variable(\"verb_intercept\")\n\n        params = []\n\n        for i in range(verb_intercept_samples.shape[1]):\n            mu, sigma = norm.fit(verb_intercept_samples[:,i])\n            verb = self.verb_hash_map[i]\n            params.append([verb, mu, sigma])\n\n        params_df = DataFrame(params, columns=[\"verb\", \"verb_mean\", \"verb_std\"])\n        params_df[\"order\"] = params_df.index\n\n        return params_df\n\nTo implement a particular subtype of projection model, we then simply need to define a subclass that specifies where the functions block is located–remember, we factored the models such that they differ only in their definitions of the likelihood function–and where to write the full model code out to.\n\nclass FullyDiscreteProjectionModel(ProjectionModel):\n    stan_functions_block_file = \"models/projection-model/fully-discrete/fully-discrete-likelihoods.stan\"\n    stan_file = \"models/projection-model/fully-discrete/fully-discrete-model.stan\"\n    \nclass VerbDiscreteProjectionModel(ProjectionModel):\n    stan_functions_block_file = \"models/projection-model/verb-discrete/verb-discrete-likelihoods.stan\"\n    stan_file = \"models/projection-model/verb-discrete/verb-discrete-model.stan\"\n\nclass ContextDiscreteProjectionModel(ProjectionModel):\n    stan_functions_block_file = \"models/projection-model/context-discrete/context-discrete-likelihoods.stan\"\n    stan_file = \"models/projection-model/context-discrete/context-discrete-model.stan\"\n\nclass FullyGradientProjectionModel(ProjectionModel):\n    stan_functions_block_file = \"models/projection-model/fully-gradient/fully-gradient-likelihoods.stan\"\n    stan_file = \"models/projection-model/fully-gradient/fully-gradient-model.stan\"\n\n\n\nLoad norming data\ndef load_projection_data(fname: str) -&gt; DataFrame:\n    data = read_csv(fname, index_col=0)\n    \n    if \"comments\" in data.columns:\n        data = data.drop(columns=\"comments\")\n\n    data = data[data.trigger_class != \"control\"]\n\n    data[\"itemType\"] = data.fact_type.str.replace(\"fact\", \"\")\n    data[\"item\"] = data.contentNr.astype(str) + data.fact_type.str.replace(\"fact\", \"\")\n    \n    return data\n\ndata_projection = load_projection_data(\n    os.path.join(\n        data_dir, \n        \"projective-probability/results/3-projectivity/data/cd.csv\"\n    )\n)\n\n\n\nFitting the model\nWe can then fit each of the models. We’ll look at what different models learn about the verbs in more detail once we’ve fit them all and run our model comparison.\n\nfully_discrete_projection_model = FullyDiscreteProjectionModel(norming_model)\n_ = fully_discrete_projection_model.fit(data_projection)\n\n\nverb_discrete_projection_model = VerbDiscreteProjectionModel(norming_model)\n_ = verb_discrete_projection_model.fit(data_projection)\n\n\ncontext_discrete_projection_model = ContextDiscreteProjectionModel(norming_model)\ncontext_discrete_projection_model.fit(data_projection)\n\n\nfully_gradient_projection_model = FullyGradientProjectionModel(norming_model)\n_ = fully_gradient_projection_model.fit(data_projection)\n\n\n\nModel comparison\nWe can now run model comparison.\n\nfrom arviz import compare, plot_compare\n\nmodels = {\n    \"Verb Discrete\\nContext Discrete\": fully_discrete_projection_model,\n    \"Verb Discrete\\nContext Gradient\": verb_discrete_projection_model,\n    \"Verb Gradient\\nContext Discrete\": context_discrete_projection_model,\n    \"Verb Gradient\\nContext Gradient\": fully_gradient_projection_model\n}\n\nprojection_model_comparison = compare({\n    m_name: m.model_fit for m_name, m in models.items()\n})\n\n\n\nPlotting code\n_ = plot_compare(projection_model_comparison)\n\n\n\n\n\nThe main thing to note here is that both models associated with the indeterminacy hypothesis dominate both models associated with the fundamental gradience hypothesis, with the verb discrete model performing the best by far.\n\n\nInvestigating the fits\nWe can now turn to understanding how each model fits the data. To do this, we can look at the probabilities associated with each verb.\n\nfrom pandas import concat\n\nverb_probs = []\n \nfor m_name, m in models.items():\n    verb_probs_sub = DataFrame(\n        m.raw_model_fit.stan_variable(\"verb_prob\"),\n        columns=m.verb_hash_map\n    )\n    \n    verb_probs_sub[\"model\"] = m_name\n    \n    verb_probs.append(verb_probs_sub)\n    \nverb_probs = concat(verb_probs)\n\nverb_probs = melt(verb_probs, id_vars=\"model\")\n\n\n\n\n\n\n\n\nmodel\nvariable\nvalue\n\n\n\n\n0\nVerb Discrete\\nContext Discrete\nacknowledge\n2.699850e-01\n\n\n1\nVerb Discrete\\nContext Discrete\nacknowledge\n2.912600e-01\n\n\n2\nVerb Discrete\\nContext Discrete\nacknowledge\n2.696550e-01\n\n\n3\nVerb Discrete\\nContext Discrete\nacknowledge\n1.921890e-01\n\n\n4\nVerb Discrete\\nContext Discrete\nacknowledge\n2.014510e-01\n\n\n...\n...\n...\n...\n\n\n639995\nVerb Gradient\\nContext Gradient\nthink\n4.363940e-22\n\n\n639996\nVerb Gradient\\nContext Gradient\nthink\n6.227660e-15\n\n\n639997\nVerb Gradient\\nContext Gradient\nthink\n1.147610e-17\n\n\n639998\nVerb Gradient\\nContext Gradient\nthink\n1.003010e-17\n\n\n639999\nVerb Gradient\\nContext Gradient\nthink\n2.235940e-10\n\n\n\n\n640000 rows × 3 columns\n\n\n\n\n\nPlotting code\nfrom matplotlib.pyplot import subplots\nfrom seaborn import boxplot\n\nverb_probs_fully_gradient = verb_probs[verb_probs.model==\"Verb Gradient\\nContext Gradient\"]\n\nverb_order = verb_probs_fully_gradient.groupby(\"variable\")[\"value\"].mean()\nverb_order = verb_order.sort_values(ascending=False)\n\nmodel_order = verb_probs.groupby(\"model\")[\"value\"].max()\nmodel_order = model_order.sort_values(ascending=False)\n\nfig, ax = subplots(figsize=(11.5, 14))\n\n_ = boxplot(\n    verb_probs, \n    x=\"value\", y=\"variable\", hue=\"model\",\n    order=verb_order.index, \n    hue_order=model_order.index,\n    fliersize=0., ax=ax)\n\n\n\n\n\nOne interesting thing to note here is that both the fully gradient model (verb gradient-context gradient) and the contrext discrete model (verb gradient-context discrete) tend to have much more extreme probabilities associated with each verb than the two other models. We can see this pattern even more clearly if we plot the mean value for each verb.\n\n\nPlotting code\nfrom seaborn import kdeplot\n\nmean_verb_probs_by_model = verb_probs.groupby([\"model\", \"variable\"]).value.mean().reset_index()\n\n_ = kdeplot(\n    mean_verb_probs_by_model, \n    x=\"value\", hue=\"model\", \n    cut=0., hue_order=model_order.index\n)\n\n\n\n\n\nWhat this pattern would seem to suggest is that the two models associated with the fundamental gradience hypothesis are, in some sense, trying to simulate those associated with the indeterminacy hypothesis.\nConversely, the probabilities associated with the models associated with the indeterminacy hypothesis, suggest much more variability in projectivity–consistent with the original observation by White and Rawlins (2018) and the later observations by Degen and Tonhauser (2022) and Kane, Gantt, and White (2022). Putting the findings of Kane, Gantt, and White (2022) together with these findings would seem to lend strong support to the indeterminacy hypothesis."
  },
  {
    "objectID": "projective-content/model-fitting-and-comparison.html#modeling-the-bleached-and-templatic-data",
    "href": "projective-content/model-fitting-and-comparison.html#modeling-the-bleached-and-templatic-data",
    "title": "Model fitting and comparison",
    "section": "Modeling the bleached and templatic data",
    "text": "Modeling the bleached and templatic data\nTo further evaluate these models, let’s fit the variants discussed in the last section to the bleached and templatic datasets. The main change in how we fit these models–compared to the models we fit to Degen and Tonhauser data–is that we’ll use the models fit to their data to determine the verb-specific priors on the by-verb random intercepts.\n\nModeling the bleached data\nFirst, we’ll fit to the bleached data.\n\n\nLoad bleached data\ndata_projection_bleached = load_projection_data(\n    os.path.join(\n        data_dir, \n        \"projective-probability-replication/bleached.csv\"\n    )\n)\n\ndata_projection_bleached[\"workerid\"] = data_projection_bleached.participant\n\n\n\nfully_discrete_projection_model_bleached = FullyDiscreteProjectionModel(\n    fully_discrete_projection_model, use_context_prior=False\n)\nfully_discrete_projection_model_bleached.fit(\n    data_projection_bleached, map_initialization=False,\n)\n\n\nverb_discrete_projection_model_bleached = VerbDiscreteProjectionModel(\n    verb_discrete_projection_model, use_context_prior=False\n)\nverb_discrete_projection_model_bleached.fit(\n    data_projection_bleached, map_initialization=False,\n)\n\n\ncontext_discrete_projection_model_bleached = ContextDiscreteProjectionModel(\n    context_discrete_projection_model, use_context_prior=False\n)\ncontext_discrete_projection_model_bleached.fit(\n    data_projection_bleached, map_initialization=False,\n)\n\n\nfully_gradient_projection_model_bleached = FullyGradientProjectionModel(\n    fully_gradient_projection_model, use_context_prior=False\n)\nfully_gradient_projection_model_bleached.fit(\n    data_projection_bleached, map_initialization=False,\n)\n\nIn running the model comparison, we observe the same pattern of results we observed for Degen and Tonhauser’s data.\n\nprojection_model_bleached_comparison = compare({\n    \"Verb Discrete\\nContext Discrete\": fully_discrete_projection_model_bleached.model_fit,\n    \"Verb Discrete\\nContext Gradient\": verb_discrete_projection_model_bleached.model_fit,\n    \"Verb Gradient\\nContext Discrete\": context_discrete_projection_model_bleached.model_fit,\n    \"Verb Gradient\\nContext Gradient\": fully_gradient_projection_model_bleached.model_fit\n})\n\n\n\nPlotting code\n_ = plot_compare(projection_model_bleached_comparison)\n\n\n\n\n\nWe can also see that the standard deviation of the by-context intercepts is extremely small–especially compared to the standard deviations of the by-subject intercepts.1\n\n\nPlotting code\n_ = plot_forest(\n    verb_discrete_projection_model_bleached.model_fit,\n    var_names=[\"context_intercept_std\", \"subj_intercept_verb_std\", \"subj_intercept_context_std\"],\n    combined=True,\n    figsize=(11.5, 2),\n)\n\n\n\n\n\nThis small standard deviation is what we should expect here: one cannot in fact have prior beliefs about the beliefs contexts, so subjects just assume that the bleached content has a roughly 50-50 chance of being true.\n\n\nModeling the templatic data\nWe’ll do the same for the templatic data.\n\n\nLoad templatic data\ndata_projection_templatic = load_projection_data(\n    os.path.join(\n        data_dir, \n        \"projective-probability-replication/templatic.csv\"\n    )\n)\n\ndata_projection_templatic[\"workerid\"] = data_projection_templatic.participant\n\n\n\nfully_discrete_projection_model_templatic = FullyDiscreteProjectionModel(\n    fully_discrete_projection_model, use_context_prior=False\n)\n_ = fully_discrete_projection_model_templatic.fit(\n    data_projection_templatic, map_initialization=False,\n)\n\n\nverb_discrete_projection_model_templatic = VerbDiscreteProjectionModel(\n    verb_discrete_projection_model, use_context_prior=False\n)\n_ = verb_discrete_projection_model_templatic.fit(\n    data_projection_templatic, map_initialization=False,\n)\n\n\ncontext_discrete_projection_model_templatic = ContextDiscreteProjectionModel(\n    context_discrete_projection_model, use_context_prior=False\n)\n_ = context_discrete_projection_model_templatic.fit(\n    data_projection_templatic, map_initialization=False,\n)\n\n\nfully_gradient_projection_model_templatic = FullyGradientProjectionModel(\n    fully_gradient_projection_model, use_context_prior=False\n)\n_ = fully_gradient_projection_model_templatic.fit(\n    data_projection_templatic, map_initialization=False, \n)\n\n\nprojection_model_templatic_comparison = compare({\n    \"Verb Discrete\\nContext Discrete\": fully_discrete_projection_model_templatic.model_fit,\n    \"Verb Discrete\\nContext Gradient\": verb_discrete_projection_model_templatic.model_fit,\n    \"Verb Gradient\\nContext Discrete\": context_discrete_projection_model_templatic.model_fit,\n    \"Verb Gradient\\nContext Gradient\": fully_gradient_projection_model_templatic.model_fit\n})\n\nIn running this model comparison, we observe a similar pattern of results, with the verb discrete model pulling even father ahead.\n\n\nPlotting code\n_ = plot_compare(projection_model_templatic_comparison)\n\n\n\n\n\nAs expected, we also observe that the standard deviation of the by-context intercepts is extremely small, which we expect for the same reasons we expected in for the models fit to the bleached data.\n\n\nPlotting code\n_ = plot_forest(\n    verb_discrete_projection_model_templatic.model_fit,\n    var_names=[\"context_intercept_std\", \"subj_intercept_verb_std\", \"subj_intercept_context_std\"],\n    combined=True,\n    figsize=(11.5, 2),\n)"
  },
  {
    "objectID": "projective-content/model-fitting-and-comparison.html#summing-up",
    "href": "projective-content/model-fitting-and-comparison.html#summing-up",
    "title": "Model fitting and comparison",
    "section": "Summing up",
    "text": "Summing up\nIn this module, we considered two subtly distinct questions: (i) whether there is evidence for discrete classes of lexical representations that determine inferences commonly associated with factive predicates or whether this knowledge is fundamentally continuous; and (ii) how, for aspects of lexical knowledge that are fundamentally continuous, that knowledge is integrated with world knowledge. Relevant to the first question, we saw evidence from Kane, Gantt, and White (2022) that, when we appropriately account for various sources of gradience in inference judgments, we observe a small number of clear cluster of predicates, all of which correspond cleanly to the predicate classes one might expect from the literature of clause-embedding predicates and a subset of which correspond to traditional subclassifications of factives. To address the second question, we modeled data collected by Degen and Tonhauser (2021) showing that models assuming that gradience comes from indeterminacy outperform models that assume fundamental gradience."
  },
  {
    "objectID": "projective-content/model-fitting-and-comparison.html#footnotes",
    "href": "projective-content/model-fitting-and-comparison.html#footnotes",
    "title": "Model fitting and comparison",
    "section": "Footnotes",
    "text": "Footnotes\n\n\nRemember that this standard deviation is in log-odds space.↩︎"
  },
  {
    "objectID": "selection/index.html",
    "href": "selection/index.html",
    "title": "Selection",
    "section": "",
    "text": "Reading\n\n\n\nData: White and Rawlins (2020) on collecting a broad-coverage acceptability judgment dataset focused on complement clauses and White and Rawlins (2016) on using that dataset to develop a computational model of selection. We will use the data collected for those papers, which can be found here, in this module.\nTheory: Lohninger and Wurmbrand (to appear) on the typology of complement clauses. We will specifically be concerned with their hypothesis that the distributional complement clauses is constrained by a monotonicity constraint relating ordered semantic types to ordered syntactic types.\nTELL ENT ENT PROP\nB       B      B       B      I         I\nsomeone told   someone that   something happened\n#!wget http://megaattitude.io/projects/mega-acceptability/mega-acceptability-v1.zip -P data/\n#!unzip data/mega-acceptability-v1.zip -d data/\n\ndata_dir = \"./data/mega-acceptability-v1/\"\nimport os\nimport pandas as pd\n\ndef load_data(fname: str, verbose: bool = True) -&gt; pd.DataFrame:\n    # read the raw data skipping comment rows at the beginning\n    data = pd.read_csv(fname, sep=\"\\t\")\n    \n    if verbose:\n        n_datapoints = data.shape[0]\n        print(f\"The full dataset has {n_datapoints} datapoints.\")\n    \n    # remove non-native speakers\n    data = data.query(\"nativeenglish\")\n    \n    if verbose:\n        n_datapoints_native = data.shape[0]\n        print(f\"Removing {n_datapoints - n_datapoints_native} \"\n              \"responses from nonnative speakers.\")\n    \n    # remove NaN judgments\n    data = data.query(\"~response.isnull()\")\n    \n    if verbose:\n        n_datapoints_nonnull = data.shape[0]\n        print(f\"Removing {n_datapoints_native - n_datapoints_nonnull} NA responses.\")\n    \n    return data\ndata = load_data(os.path.join(data_dir, \"mega-acceptability-v1.tsv\"))\n\ndata\n\nThe full dataset has 250000 datapoints.\nRemoving 600 responses from nonnative speakers.\nRemoving 10 NA responses.\n\n\n\n\n\n\n\n\n\nparticipant\nlist\npresentationorder\nverb\nframe\nresponse\nnativeenglish\nsentence\n\n\n\n\n0\n4\n862\n1\nturn_out\nNP was Ved whichNP to VP\n2.0\nTrue\nSomeone was turned out which thing to do.\n\n\n1\n381\n862\n1\nturn_out\nNP was Ved whichNP to VP\n1.0\nTrue\nSomeone was turned out which thing to do.\n\n\n2\n395\n862\n1\nturn_out\nNP was Ved whichNP to VP\n2.0\nTrue\nSomeone was turned out which thing to do.\n\n\n3\n621\n862\n1\nturn_out\nNP was Ved whichNP to VP\n1.0\nTrue\nSomeone was turned out which thing to do.\n\n\n4\n527\n862\n1\nturn_out\nNP was Ved whichNP to VP\n1.0\nTrue\nSomeone was turned out which thing to do.\n\n\n...\n...\n...\n...\n...\n...\n...\n...\n...\n\n\n249995\n113\n928\n50\nmadden\nNP Ved about NP\n4.0\nTrue\nSomeone maddened about something.\n\n\n249996\n32\n928\n50\nmadden\nNP Ved about NP\n2.0\nTrue\nSomeone maddened about something.\n\n\n249997\n544\n928\n50\nmadden\nNP Ved about NP\n1.0\nTrue\nSomeone maddened about something.\n\n\n249998\n727\n928\n50\nmadden\nNP Ved about NP\n7.0\nTrue\nSomeone maddened about something.\n\n\n249999\n294\n928\n50\nmadden\nNP Ved about NP\n1.0\nTrue\nSomeone maddened about something.\n\n\n\n\n249390 rows × 8 columns\nWhite and Rawlins (2016) model the ordinal acceptability judgments \\(r_i\\) associated with a sentence \\(s_i\\) to be a function of the probability \\(\\alpha_{vf}\\) that the main clause verb \\(v = \\text{verb}(i)\\) in \\(s_i\\) is acceptable in the syntactic frame \\(f = \\text{frame}(i)\\) instantiated in \\(s_i\\).1 They model this probability as a function of two other kinds of probability: (i) the probability \\(\\lambda_{vs}\\) that a particular verb \\(v\\) can have a particular semantic type signature \\(s\\); and (ii) the probability \\(\\mu_{sf}\\) that a particular semantic type signature \\(s\\) can be mapped onto a particular syntactic frame \\(f\\).\nThe basic idea is that we should predict a verb to be good–modulo other factors, such as its case assignment properties (pesetsky_zero_1991?)–in a particular syntactic frame insofar as it can have at least one semantic type signature that maps onto that frame. That is, they define the probability \\(\\alpha_{vf}\\) that a main clause verb \\(v\\) is acceptable in a syntactic frame \\(f\\) to be \\(p\\left(\\bigvee_s l_{vs} \\land m_{sf}\\right)\\), where:\n\\[\\begin{align*}\nl_{vs} &= \\begin{cases}\n\\top & \\text{if } v \\text{ can have semantic type signature } s\\\\\n\\bot & \\text{otherwise}\n\\end{cases}\\\\\nm_{sf} &= \\begin{cases}\n\\top & \\text{if } s \\text{ can map onto syntactic frame } f\\\\\n\\bot & \\text{otherwise}\n\\end{cases}\n\\end{align*}\\]\nInsofar as a verb’s having a particular type signature is independent of that type signature mapping onto a particular syntactic frame, this probability can be factored into an expression in terms of \\(\\lambda_{vs}\\) and \\(\\mu_{sf}\\):\n\\[\\begin{align*}\np\\left(\\bigvee_s l_{vs} \\land m_{sf}\\right) &= p\\left(\\lnot\\lnot\\bigvee_s l_{vs} \\land m_{sf}\\right)\\\\\n&= 1 - p\\left(\\lnot\\bigvee_s l_{vs} \\land m_{sf}\\right)\\\\\n&= 1 - p\\left(\\bigwedge_s \\lnot\\left[ l_{vs} \\land m_{sf}\\right]\\right)\\\\\n&= 1 - \\prod_s p\\left(\\lnot\\left[ l_{vs} \\land m_{sf}\\right]\\right)\\\\\n&= 1 - \\prod_s 1 - p\\left(l_{vs} \\land m_{sf}\\right)\\\\\n&= 1 - \\prod_s 1 - p\\left(l_{vs}\\right)p\\left(m_{sf}\\right)\\\\\n&= 1 - \\prod_s 1 - \\lambda_{vs}\\mu_{sf}\\\\\n\\end{align*}\\]\nImportantly, they assume: (a) that verbs can be compatible with multiple semantic type signatures; (b) that multiple semantic type signatures can map onto the same frame; and (c) that multiple frames can be mapped onto by the same semantic type signature. So \\(\\sum_s \\lambda_{vs}\\) and \\(\\sum_s \\mu_{sf}\\) can be anywhere between \\(0\\) and the number of type signatures, and \\(\\sum_f \\mu_{sf}\\) can be anywhere between \\(0\\) and the number of syntactic frames. None of the three need to be \\(1\\).\nSolving for \\(\\lambda_{vs}\\) and \\(\\mu_{sf}\\), from which \\(\\alpha_{vf}\\) can be computed deterministically, is an instance of a matrix factorization problem–of which principal component analysis [PCA; Pearson (1901)], factor analysis, and postive/non-negative matrix factorization [NMF; Paatero and Tapper (1994)] are common forms.\nfrom numpy import ndarray\nfrom pandas import CategoricalDtype\n\ndef hash_series(series: pd.Series, categories: Optional[list[str]] = None, indexation: int=1) -&gt; tuple[ndarray, ndarray]:\n    \"\"\"Hash a series to numeric codes\n    \n    Parameters\n    ----------\n    column\n        The series to hash\n    index\n        The starting index (defaults to 1)\n    \"\"\"\n    # enforce 0- or 1-indexation\n    if indexation not in [0, 1]:\n        raise ValueError(\"Must choose either 0- or 1-indexation.\")\n    \n    # convert the series to a category\n    if categories is None:\n        category_series = series.astype(\"category\")\n    else:\n        cat_type = CategoricalDtype(categories=categories)\n        category_series = series.astype(cat_type)\n    \n    # get the hash\n    hash_map = category_series.cat.categories.values\n    \n    # map to one-indexed codes\n    hashed_series = (category_series.cat.codes + indexation).values\n    \n    return hash_map, hashed_series\nimport cmdstanpy, arviz\nfrom cmdstanpy import CmdStanModel\nfrom typing import Optional\nfrom enum import Enum\nfrom dataclasses import dataclass\nfrom arviz import InferenceData\n\nclass FitType(Enum):\n    OPTIMIZE = 0\n    SAMPLE = 1\n\n@dataclass\nclass SelectionData:\n    N_verb: int\n    N_frame: int\n    N_component: int\n    N_subj: int\n    N_resp: int\n    N_resp_levels: int\n    verb: ndarray\n    frame: ndarray\n    subj: ndarray\n    resp: ndarray\n    \nclass UnconstrainedSelectionModel:\n    stan_file = \"./models/fuzzy-logic-factorization.stan\"\n    data_class = SelectionData\n    \n    def __init__(self, n_component: int):\n        self.model = CmdStanModel(stan_file=self.stan_file)\n        self.n_component = n_component\n        \n    def construct_model_data(self, data: pd.DataFrame):\n        self.verb_hash_map, verb_hashed = hash_series(data.verb)\n        self.frame_hash_map, frame_hashed = hash_series(data.frame)\n        self.subj_hash_map, subj_hashed = hash_series(data.participant)\n        \n        model_data = {\n            \"N_verb\": self.verb_hash_map.shape[0],\n            \"N_frame\": self.frame_hash_map.shape[0],\n            \"N_component\": self.n_component,\n            \"N_subj\": self.subj_hash_map.shape[0],\n            \"N_resp\": data.shape[0],\n            \"N_resp_levels\": 7,\n            \"verb\": verb_hashed,\n            \"frame\": frame_hashed,\n            \"subj\": subj_hashed,\n            \"resp\": data.response.astype(int).values\n        }\n        \n        return model_data\n        \n    def _validate_data(self):\n        self.data_class(**self.model_data)\n\n    def fit(\n        self, \n        data: pd.DataFrame,\n        fit_type: FitType = FitType.OPTIMIZE,\n        save_dir: Optional[str] = None,\n        verbose: bool = True, \n        show_progress: bool = True\n    ) -&gt; InferenceData:\n        self.model_data = self.construct_model_data(data)\n        \n        self._validate_data()\n        \n        if verbose:\n            print(\"Fitting model...\")\n        \n        self.fit_type = fit_type\n        \n        if fit_type == FitType.OPTIMIZE:\n            self.raw_model_fit = self.model.optimize(\n                data=self.model_data\n            )\n        else:\n            self.raw_model_fit = self.model.sample(\n                data=self.model_data, \n                show_progress=show_progress\n            )\n    \n        if save_dir is not None:\n            if verbose:\n                print(\"Saving model...\")\n\n            self.save(save_dir)\n        \n        if verbose:\n            print(\"Saving model...\")\n    \n        return self\n    \n    def pointwise_log_likelihoods(self, data: Optional[pd.DataFrame] = None, **kwargs) -&gt; InferenceData:\n        if data is None:\n            model_data = self.model_data\n        else:\n            model_data = self.construct_model_data(data, **kwargs)\n            \n        log_likelihoods = self.model.generate_quantities(\n            data=model_data, \n            previous_fit=self.raw_model_fit\n        )\n\n        return arviz.from_cmdstanpy(log_likelihoods)\n    \n    @property\n    def model_fit(self):\n        if fit_type == FitType.OPTIMIZE:\n            return self.raw_model_fit\n        else:\n            return arviz.from_cmdstanpy(self.raw_model_fit)\n    \n    def save(self, save_dir: str = \".\"):\n        self.raw_model_fit.save_csvfiles(save_dir)\n    \n    @classmethod\n    def from_csv(cls, path: str, **kwargs):\n        model = cls(**kwargs)\n        model.raw_model_fit = cmdstanpy.from_csv(path)\nmodel = UnconstrainedSelectionModel(2, 1., False).fit(data, fit_type=FitType.OPTIMIZE)\n\nTypeError: FuzzyLogicFactorizationModel.__init__() takes 2 positional arguments but 4 were given\nimport seaborn as sns\n\nfrom scipy.stats import spearmanr\n\ndata[\"prediction\"] = model.raw_model_fit.stan_variable('mu')\n\n_ = sns.boxplot(data, x=\"response\", y=\"prediction\")\n\nspearmanr(data[[\"response\", \"prediction\"]])\n\nSignificanceResult(statistic=0.40889891447222454, pvalue=0.0)\nmodel.raw_model_fit.stan_variables()\n\n{'verb_component_prior_aux': array([0.128443, 0.125146, 0.656217, 0.779327, 0.827608, 0.312784,\n        0.848003, 0.808027, 0.422028, 0.375185, 0.353681, 0.327297,\n        0.733399, 0.854325, 0.778634, 0.227325, 0.146691, 0.721576,\n        0.527884, 0.123827, 0.275521, 0.370464, 0.702175, 0.879695,\n        0.138056, 0.174648, 0.21029 , 0.766008, 0.151918, 0.292663]),\n 'frame_component_prior_aux': array([0.128859, 0.439508, 0.856828, 0.384938, 0.652028, 0.662436,\n        0.824644, 0.492884, 0.45846 , 0.13276 , 0.347303, 0.768129,\n        0.386184, 0.876037, 0.26281 , 0.127104, 0.329268, 0.743779,\n        0.685283, 0.393859, 0.327524, 0.212908, 0.138822, 0.342837,\n        0.870582, 0.866983, 0.29064 , 0.391456, 0.875311, 0.81953 ]),\n 'verb_component_prior_precision': array([3.94606 , 6.85934 , 2.14684 , 0.355818, 4.316   , 0.66685 ,\n        2.00714 , 2.95657 , 0.277982, 0.313856, 3.66564 , 3.61452 ,\n        0.270871, 6.10048 , 0.198073, 0.690347, 0.306669, 0.487583,\n        0.321813, 0.260728, 0.31567 , 2.29999 , 2.5018  , 0.404016,\n        1.23719 , 4.43367 , 0.811716, 2.26288 , 4.82592 , 0.685407]),\n 'frame_component_prior_precision': array([2.47689 , 6.94865 , 1.14166 , 0.836653, 0.262048, 3.33315 ,\n        1.06894 , 2.26159 , 0.192062, 2.89519 , 0.906216, 0.373096,\n        2.43317 , 0.250202, 0.304647, 0.292793, 2.11231 , 0.964812,\n        2.65006 , 1.22376 , 2.49388 , 1.91038 , 1.1461  , 0.1658  ,\n        1.44303 , 4.07296 , 2.55249 , 3.40739 , 6.50941 , 0.165849]),\n 'verb_component': array([[0.631036, 0.12458 , 0.750635, ..., 0.713654, 0.701122, 0.859162],\n        [0.484222, 0.319344, 0.861388, ..., 0.580126, 0.725599, 0.86963 ],\n        [0.851271, 0.499822, 0.655394, ..., 0.187742, 0.133366, 0.73629 ],\n        ...,\n        [0.456762, 0.502419, 0.210684, ..., 0.217777, 0.839811, 0.631872],\n        [0.134225, 0.769278, 0.559535, ..., 0.195162, 0.213416, 0.876293],\n        [0.207543, 0.879065, 0.863831, ..., 0.855847, 0.12572 , 0.339096]]),\n 'frame_component': array([[0.148117, 0.139249, 0.867981, ..., 0.217972, 0.787618, 0.690592],\n        [0.143749, 0.607432, 0.713306, ..., 0.49488 , 0.72556 , 0.812185],\n        [0.239083, 0.560894, 0.251543, ..., 0.14582 , 0.198369, 0.138268],\n        ...,\n        [0.584786, 0.405192, 0.493362, ..., 0.797333, 0.353267, 0.154806],\n        [0.298372, 0.119673, 0.287615, ..., 0.747307, 0.389407, 0.160099],\n        [0.66831 , 0.50375 , 0.194715, ..., 0.608931, 0.436724, 0.751809]]),\n 'scale': 0.342677,\n 'subject_intercept': array([ 4.74424e-01,  5.81169e-01,  1.52451e-01, -1.21523e+00,\n        -3.76642e-01,  4.12773e-01,  4.93730e-01, -1.55746e+00,\n         4.30370e-01, -2.45055e-03, -4.16315e-01, -9.36667e-01,\n        -1.57720e+00,  8.99032e-01, -3.84752e-01, -7.86858e-01,\n         5.51128e-01, -8.23691e-01,  2.46000e-01, -9.24073e-01,\n        -5.02015e-01,  5.28516e-01,  7.43493e-03, -6.26881e-02,\n        -1.12118e+00, -8.09475e-01,  8.53874e-01,  3.55306e-01,\n        -1.24594e+00, -6.87277e-02, -1.80899e-01, -1.91844e-01,\n         3.68925e-01, -1.21469e+00, -9.09536e-01, -1.11137e+00,\n         1.25902e-01, -3.76982e-01,  7.98636e-01,  5.91311e-02,\n        -6.42357e-01,  2.30568e-01, -5.81096e-01,  3.53952e-01,\n         2.48313e-01, -1.33410e+00,  7.01760e-01,  6.26869e-01,\n        -1.04620e+00, -6.86099e-03,  6.30465e-01,  8.49885e-01,\n        -1.13165e+00, -2.04142e+00,  3.30557e-01,  9.89475e-01,\n         5.87273e-01, -8.70097e-01,  1.64817e+00, -3.46082e-01,\n         2.48271e-01, -1.45393e-01,  7.38582e-01, -3.39631e-01,\n         9.56582e-02, -7.41979e-01,  6.49592e-01,  9.33503e-01,\n         1.56984e+00, -4.53466e-01,  5.06329e-01, -5.76661e-01,\n         2.65088e+00,  9.89681e-01,  1.07587e+00, -1.29228e+00,\n         4.34748e-01,  1.30630e-01,  5.28397e-02, -1.84634e+00,\n        -3.37688e-02, -5.73385e-01, -1.37377e+00, -3.23291e-01,\n         5.50752e-01, -1.52814e+00,  7.78625e-01,  2.76436e-01,\n         3.18751e-01, -2.71143e-01,  2.58047e-01, -5.05047e-01,\n         5.30805e-01,  3.67817e-01,  2.02014e-02, -1.44350e+00,\n         3.49213e-02,  2.71423e-01,  5.93516e-01,  6.83710e-01,\n        -8.02496e-01, -1.08427e+00, -7.12690e-01, -5.94339e-01,\n         1.18571e+00, -1.60786e+00,  5.32612e-02,  7.92068e-01,\n        -6.67420e-02,  8.86533e-02,  4.38447e-01,  1.93246e-02,\n         4.69271e-01,  1.50089e-01, -6.52321e-03, -7.05430e-01,\n         1.02084e+00, -1.44481e-01,  1.34385e+00, -7.06620e-01,\n         5.99348e-01,  2.23753e-01,  3.03024e-01, -1.16437e+00,\n         6.20510e-01,  2.39010e-01,  6.33210e-01,  7.83420e-02,\n        -5.35018e-01, -7.68897e-01,  2.48338e-01, -8.21896e-01,\n        -1.50753e-02,  7.70642e-01,  4.07584e-01, -3.21323e-01,\n         2.71655e-01, -5.90605e-02,  4.25167e-01,  3.13657e-02,\n        -8.97341e-01, -1.77354e+00,  8.26726e-01,  1.76854e+00,\n        -5.74292e-01,  5.09806e-01,  7.04516e-01, -8.08557e-03,\n        -9.93954e-01,  8.03876e-02,  6.90031e-01,  4.02817e-01,\n        -7.98484e-01, -8.91539e-01,  1.28409e-01,  1.71990e-01,\n         7.75928e-01, -1.03386e+00,  4.42372e-02,  5.15516e-01,\n        -3.44331e-01,  1.18200e-03,  1.13494e+00, -4.79905e-02,\n        -2.73264e-01, -5.49827e-01, -2.60540e-01,  2.46635e-01,\n         6.07760e-01,  7.34930e-01,  3.75429e-01,  3.40623e-01,\n         4.57374e-02,  1.63316e-01, -6.37417e-01, -3.88078e-01,\n         9.41364e-02, -8.36724e-02,  5.30396e-01,  5.32977e-01,\n        -7.62135e-02, -5.23548e-01, -1.02387e+00,  6.36379e-01,\n        -1.52251e+00,  1.21847e-01, -2.27075e-01, -1.19180e+00,\n         8.35557e-01, -8.33588e-01, -1.19962e-01,  2.15247e-01,\n        -7.90993e-01, -3.38465e-01,  6.49465e-01, -9.55126e-01,\n        -3.13049e-02,  1.81868e+00,  8.47810e-02, -2.25852e+00,\n         2.29785e-01, -6.79092e-01, -3.57089e-02,  1.18436e+00,\n         3.88629e-01, -1.56359e-01, -9.52949e-01,  1.04602e+00,\n         1.24202e+00,  9.83614e-01, -2.74759e-02,  6.20111e-01,\n         5.98930e-01,  2.17615e-01,  7.86091e-01, -8.29147e-01,\n         6.39468e-01, -1.25558e+00,  9.26507e-03, -3.13464e-01,\n         9.38088e-01,  2.27649e+00, -2.53768e+00, -3.83406e-01,\n         2.79527e-01,  6.11449e-01,  6.82550e-01,  3.97554e-01,\n         4.47691e-01, -5.54276e-01,  1.76410e-01,  8.73556e-02,\n        -3.99629e-01,  6.94054e-01,  3.43673e-01,  1.01187e+00,\n        -2.18517e+00, -5.70515e-01, -6.79002e-01,  2.22539e-01,\n         4.84307e-01,  2.40932e+00, -6.47600e-01,  6.68794e-01,\n         6.12225e-01,  5.45909e-01,  6.54368e-01,  1.03091e-02,\n        -1.41465e-01,  1.56109e-01, -1.41005e+00,  7.13663e-01,\n         1.11277e-01,  3.64858e-01,  3.34982e-01,  6.26717e-01,\n         5.26949e-01, -4.01259e-01,  9.06606e-01, -1.19428e+00,\n         1.52844e-01,  1.01377e+00,  6.43483e-01,  6.97471e-01,\n         1.14382e+00, -3.99871e-03,  2.66114e-01, -1.49591e-01,\n         2.57018e-01, -4.66524e-01,  9.44353e-01,  2.17188e-01,\n         8.85961e-01,  2.14621e-02,  1.02294e+00,  6.70271e-01,\n        -5.41427e-01, -1.48982e-01, -3.07123e-01, -1.10756e+00,\n        -3.00867e-01,  3.96404e-01,  1.59119e-01, -3.03103e-01,\n         5.77373e-02, -8.40116e-01, -5.53462e-01,  8.28390e-01,\n        -4.80625e-01, -1.49606e+00,  1.87902e-01, -1.46884e+00,\n        -6.33657e-01, -3.71626e-01, -8.77436e-01, -7.03373e-02,\n         7.40037e-01, -8.93051e-01,  1.30231e+00, -1.45159e-01,\n        -2.01342e-01, -1.97197e+00, -5.74940e-01,  8.54658e-01,\n        -1.43819e-01, -7.21665e-02, -5.45656e-01,  1.07217e+00,\n        -6.01677e-01, -1.59161e+00,  4.54926e-01, -1.59611e+00,\n         2.19739e-01,  4.70924e-01, -5.36177e-01,  7.58519e-01,\n         1.27801e-01,  4.78080e-01,  2.33537e-01, -6.89422e-01,\n         8.83141e-01,  4.86207e-01,  2.37032e-01,  8.08333e-01,\n         7.32945e-01, -1.17114e+00,  7.33238e-01, -1.08420e+00,\n         1.93273e+00,  6.09959e-01,  1.83113e+00,  6.52965e-01,\n         1.24981e+00, -2.20897e-01, -8.82339e-02, -8.73349e-01,\n         7.39357e-01, -7.77731e-02,  7.29637e-01, -1.15229e+00,\n         8.94273e-02,  2.04990e-01,  5.52298e-02, -1.13349e+00,\n         8.61106e-01, -4.88224e-01,  9.01410e-01, -9.71639e-01,\n         2.77285e-01, -1.21580e-01, -7.44914e-01,  8.31934e-01,\n         2.40882e-01,  6.88906e-01, -7.45428e-01,  6.96323e-02,\n        -1.30449e-01, -1.05073e+00,  5.51754e-02,  7.47091e-01,\n        -1.19242e+00, -2.65441e-01, -2.56910e-01,  4.35275e-01,\n        -1.23404e-01,  9.67246e-02,  2.44612e-01, -9.98314e-01,\n         1.17133e-01,  1.50953e-01,  3.72173e-01,  1.81027e+00,\n         6.08010e-01,  1.65044e-01,  6.97150e-01, -8.59175e-01,\n         3.64691e-01, -9.03866e-01, -1.71463e-01, -4.97181e-01,\n         3.59801e-01,  2.02395e-01, -6.40316e-01, -1.36781e+00,\n         6.25449e-01,  3.91780e-01,  1.22762e-01, -2.09249e+00,\n         1.59385e-01,  1.02802e+00,  1.30957e+00,  5.12622e-01,\n        -3.10065e-03,  1.38047e+00,  6.46599e-01,  1.27330e+00,\n         1.47127e+00, -1.94907e-01,  1.02943e+00, -1.27448e-01,\n         6.99052e-01, -1.70971e-01,  2.70797e-01, -4.46774e-01,\n        -2.18086e-01,  1.76370e-01,  3.67291e-01,  7.24871e-01,\n         6.20429e-01,  4.54635e-01,  1.60206e-01,  2.11376e-01,\n         6.58752e-01, -1.21890e+00, -3.25728e+00, -6.34088e-01,\n         3.30526e-01,  3.92794e-01,  8.37157e-01, -8.29547e-02,\n         1.07893e+00, -3.17053e-01, -1.09768e+00, -8.34819e-01,\n         3.79134e-01,  1.58639e-01,  3.88338e-01, -1.26107e+00,\n        -1.44337e+00, -6.61995e-01,  1.56509e-01,  1.07669e+00,\n         4.32753e-01, -4.59803e-01, -3.60443e-01,  1.37046e+00,\n        -1.08646e+00, -7.79049e-01, -8.56338e-01,  7.26129e-01,\n         1.11191e+00, -5.38990e-01,  8.07547e-01, -5.00520e-01,\n         9.30688e-01, -1.08224e+00, -2.32093e-01,  1.09179e+00,\n        -1.07688e-01, -1.43090e+00, -3.02642e-01,  7.92652e-01,\n         9.86079e-02,  6.58361e-01, -1.05491e+00,  8.25960e-01,\n         1.26836e+00,  5.04173e-01,  8.12961e-01,  4.23600e-01,\n         1.54567e+00, -1.27906e+00, -2.46772e-01, -6.27626e-01,\n        -1.20863e+00,  8.53035e-01, -1.93384e+00, -1.37296e+00,\n         7.02432e-03, -1.33295e+00, -3.05969e-01,  4.15330e-01,\n         4.14983e-01,  3.42292e-01, -1.29219e+00,  1.79922e-01,\n         2.98742e-02, -8.96372e-01,  3.42554e-01, -6.75668e-01,\n        -8.03111e-02,  7.92982e-01,  1.09564e+00,  5.07590e-01,\n        -3.43324e-01,  5.83436e-01, -8.66205e-01,  4.49343e-01,\n         2.74063e-01, -1.07467e-03, -8.82549e-01,  3.26919e-02,\n        -9.19501e-01,  1.00034e+00,  8.26838e-01,  3.25850e-01,\n        -2.18428e-01,  3.44479e-01, -5.93609e-01,  5.44990e-01,\n         4.69017e-01,  5.32558e-01, -5.76181e-01, -3.87983e-02,\n        -1.38106e-02,  8.28738e-02,  6.83411e-01, -5.76905e-01,\n         8.58287e-01,  1.16795e+00,  9.24057e-01,  1.14211e+00,\n         4.92365e-02,  1.29232e-01,  8.43683e-02,  1.75745e-01,\n         4.00143e-02,  6.23554e-01,  1.75570e-01, -1.96493e+00,\n        -7.44102e-01, -1.19723e+00,  6.60265e-01,  2.02981e+00,\n         7.68875e-01,  5.95512e-02, -2.64178e+00,  1.04027e-01,\n        -4.58022e-02,  1.01061e+00, -6.00788e-01, -5.27978e-01,\n         9.55317e-01,  1.01556e+00,  1.24528e-01, -7.53803e-01,\n         1.64385e-01,  1.13961e-01, -2.21407e-01, -4.54925e-01,\n        -4.62257e-01, -1.72978e-01, -1.51815e-01, -1.03305e+00,\n         4.59110e-01, -3.58224e-02,  1.29174e-01,  1.17854e+00,\n        -7.00523e-01,  1.18655e-01,  4.62443e-01, -2.73184e-01,\n         4.26115e-01,  6.13271e-01, -9.68027e-02,  4.41299e-01,\n        -6.01965e-01,  3.65829e-01,  3.65260e-01, -1.10523e+00,\n         2.34591e-01,  8.73458e-01,  3.58993e-02, -5.87541e-03,\n        -8.15921e-01,  5.31774e-01, -3.70548e-02,  2.39167e-01,\n        -6.25066e-01,  2.41151e-01,  2.02517e-01,  1.17971e+00,\n        -1.19871e+00, -3.86237e-01,  1.93197e-01,  3.59750e-01,\n        -2.99647e-01, -1.87421e-01,  3.84670e+00, -4.39198e-01,\n         6.66417e-01,  6.64133e-01, -1.23445e+00,  4.13822e-02,\n         9.10363e-01,  7.03194e-01,  6.37879e-01, -1.54531e+00,\n        -1.93263e+00,  5.77746e-01,  1.29742e+00, -2.80598e-01,\n        -7.05573e-01, -3.06071e+00, -4.75422e-01,  3.65198e-01,\n         9.74521e-01,  7.32553e-01, -8.00326e-01,  4.41971e-01,\n        -1.95516e-01, -2.43647e-01, -6.74946e-02, -1.44551e-01,\n        -1.31030e-01,  5.22529e-01,  2.52823e-01, -1.03373e-01,\n        -6.31948e-01, -2.81622e-01, -9.36986e-04,  1.54589e-02,\n        -5.68423e-01,  3.00506e-01,  4.62269e-01, -3.53738e-01,\n        -2.06421e+00,  2.69334e-01,  3.93483e-01, -1.14338e+00,\n         1.07983e+00,  5.48180e-01, -5.45344e-01,  3.05104e-02,\n         3.15502e-01, -1.58942e+00, -9.85861e-01,  1.49249e-01,\n        -7.88658e-01,  6.68504e-01,  5.33568e-01,  7.36544e-01,\n        -1.05825e+00,  1.02985e-01, -2.35514e+00, -7.23614e-01,\n        -6.70479e-01, -1.46119e-01,  4.97112e-01, -1.04240e+00,\n         7.24753e-01,  5.18291e-01, -1.37861e+00, -1.04266e+00,\n         4.86643e-01,  3.66984e-01,  7.86917e-01, -1.19986e+00,\n        -9.10797e-02, -3.21514e-01,  6.13457e-01, -4.11578e-01,\n        -7.19788e-02, -5.84740e-01, -1.54333e+00,  9.77076e-01,\n         5.75926e-01, -1.00221e+00, -3.25447e-01, -1.46595e+00,\n        -6.01940e-01, -7.13286e-01, -6.50424e-01,  7.77025e-01,\n         6.20243e-01,  1.30215e-01,  2.77166e-03,  5.73520e-01,\n        -9.29842e-01, -6.83950e-01,  5.97183e-01,  1.02583e+00,\n         2.38601e-01, -2.39362e-01,  1.32720e-01,  4.07196e-01,\n         7.34207e-01,  3.55592e-01,  3.64512e-01,  3.96730e-01,\n         4.66226e-01, -7.16174e-01,  8.75962e-02,  2.02811e-01,\n        -4.34386e-01, -8.45573e-01,  1.04871e+00,  5.96921e-01,\n        -1.73109e+00,  7.61483e-01,  6.69625e-01,  1.85631e-01,\n         2.67182e-01,  1.09866e+00, -5.32408e-01,  6.28556e-01,\n         8.70480e-01, -1.96992e+00,  6.84554e-01, -3.95174e-01,\n         2.01807e-01,  2.72352e-01, -5.72349e-01,  4.86605e-01,\n         4.87756e-01,  3.66553e-01,  3.28475e-01,  3.75401e-01,\n         5.53631e-01,  6.53921e-01, -1.49613e+00, -6.38289e-01,\n        -1.65964e+00,  3.01679e-01,  8.20036e-03, -7.31041e-01,\n        -7.63256e-02, -3.52873e-01,  1.07270e-01,  1.01285e+00,\n        -1.52660e-01, -7.00161e-02, -8.24873e-01, -4.52995e-01,\n        -3.28376e-01, -4.90847e-01, -2.89744e-01]),\n 'cutpoints': array([-0.720339,  0.18709 ,  0.552617,  0.906846,  1.3986  ,  2.15084 ]),\n 'verb_component_prior_mean': array([1.28443e-01, 1.60741e-02, 1.05481e-02, 8.22040e-03, 6.80327e-03,\n        2.12795e-03, 1.80451e-03, 1.45810e-03, 6.15357e-04, 2.30873e-04,\n        8.16554e-05, 2.67256e-05, 1.96005e-05, 1.67452e-05, 1.30384e-05,\n        2.96395e-06, 4.34786e-07, 3.13732e-07, 1.65614e-07, 2.05075e-08,\n        5.65024e-09, 2.09321e-09, 1.46980e-09, 1.29298e-09, 1.78503e-10,\n        3.11753e-11, 6.55585e-12, 5.02183e-12, 7.62907e-13, 2.23275e-13]),\n 'verb_component_prior_alpha': array([5.06843e-01, 1.10258e-01, 2.26451e-02, 2.92497e-03, 2.93629e-02,\n        1.41903e-03, 3.62190e-03, 4.31096e-03, 1.71058e-04, 7.24609e-05,\n        2.99320e-04, 9.66002e-05, 5.30920e-06, 1.02154e-04, 2.58255e-06,\n        2.04616e-06, 1.33335e-07, 1.52970e-07, 5.32966e-08, 5.34687e-09,\n        1.78361e-09, 4.81436e-09, 3.67715e-09, 5.22383e-10, 2.20843e-10,\n        1.38221e-10, 5.32149e-12, 1.13638e-11, 3.68172e-12, 1.53034e-13]),\n 'verb_component_prior_beta': array([3.43922 , 6.74908 , 2.1242  , 0.352893, 4.28663 , 0.665431,\n        2.00352 , 2.95226 , 0.277811, 0.313784, 3.66534 , 3.61443 ,\n        0.270865, 6.10038 , 0.19807 , 0.690345, 0.306669, 0.487583,\n        0.321812, 0.260728, 0.31567 , 2.29999 , 2.5018  , 0.404016,\n        1.23719 , 4.43367 , 0.811716, 2.26288 , 4.82592 , 0.685407]),\n 'frame_component_prior_mean': array([1.28859e-01, 5.66346e-02, 4.85261e-02, 1.86795e-02, 1.21796e-02,\n        8.06819e-03, 6.65339e-03, 3.27935e-03, 1.50345e-03, 1.99599e-04,\n        6.93213e-05, 5.32477e-05, 2.05634e-05, 1.80143e-05, 4.73435e-06,\n        6.01754e-07, 1.98138e-07, 1.47371e-07, 1.00991e-07, 3.97762e-08,\n        1.30277e-08, 2.77370e-09, 3.85050e-10, 1.32009e-10, 1.14925e-10,\n        9.96380e-11, 2.89588e-11, 1.13361e-11, 9.92260e-12, 8.13187e-12]),\n 'frame_component_prior_alpha': array([3.19170e-01, 3.93534e-01, 5.54003e-02, 1.56283e-02, 3.19164e-03,\n        2.68925e-02, 7.11207e-03, 7.41656e-03, 2.88757e-04, 5.77876e-04,\n        6.28201e-05, 1.98665e-05, 5.00343e-05, 4.50722e-06, 1.44231e-06,\n        1.76189e-07, 4.18530e-07, 1.42186e-07, 2.67632e-07, 4.86764e-08,\n        3.24894e-08, 5.29883e-09, 4.41308e-10, 2.18872e-11, 1.65840e-10,\n        4.05822e-10, 7.39170e-11, 3.86265e-11, 6.45902e-11, 1.34866e-12]),\n 'frame_component_prior_beta': array([2.15772 , 6.55512 , 1.08626 , 0.821024, 0.258857, 3.30626 ,\n        1.06183 , 2.25418 , 0.191774, 2.89461 , 0.906153, 0.373076,\n        2.43312 , 0.250198, 0.304646, 0.292793, 2.11231 , 0.964812,\n        2.65006 , 1.22376 , 2.49388 , 1.91038 , 1.1461  , 0.1658  ,\n        1.44303 , 4.07296 , 2.55249 , 3.40739 , 6.50941 , 0.165849]),\n 'verb_frame': array([[0.999849, 0.999951, 0.999031, ..., 0.998878, 0.999747, 0.999946],\n        [0.999996, 0.999996, 0.999937, ..., 0.999911, 0.999997, 0.999995],\n        [0.999773, 0.999885, 0.999436, ..., 0.999494, 0.999845, 0.99987 ],\n        ...,\n        [0.99999 , 0.999953, 0.999848, ..., 0.999734, 0.999978, 0.99993 ],\n        [0.999919, 0.999907, 0.999864, ..., 0.999264, 0.999826, 0.999921],\n        [0.999754, 0.999943, 0.999812, ..., 0.99994 , 0.999983, 0.99995 ]]),\n 'mu': array([-0.20531  , -0.325849 ,  1.5518   , ...,  0.0194879, -0.319544 ,\n        -0.462354 ])}\ntorch.tensor??\n\n\nDocstring:\ntensor(data, *, dtype=None, device=None, requires_grad=False, pin_memory=False) -&gt; Tensor\nConstructs a tensor with no autograd history (also known as a \"leaf tensor\", see :doc:`/notes/autograd`) by copying :attr:`data`.\n.. warning::\n    When working with tensors prefer using :func:`torch.Tensor.clone`,\n    :func:`torch.Tensor.detach`, and :func:`torch.Tensor.requires_grad_` for\n    readability. Letting `t` be a tensor, ``torch.tensor(t)`` is equivalent to\n    ``t.clone().detach()``, and ``torch.tensor(t, requires_grad=True)``\n    is equivalent to ``t.clone().detach().requires_grad_(True)``.\n.. seealso::\n    :func:`torch.as_tensor` preserves autograd history and avoids copies where possible.\n    :func:`torch.from_numpy` creates a tensor that shares storage with a NumPy array.\nArgs:\n    data (array_like): Initial data for the tensor. Can be a list, tuple,\n        NumPy ``ndarray``, scalar, and other types.\nKeyword args:\n    dtype (:class:`torch.dtype`, optional): the desired data type of returned tensor.\n        Default: if ``None``, infers data type from :attr:`data`.\n    device (:class:`torch.device`, optional): the device of the constructed tensor. If None and data is a tensor\n        then the device of data is used. If None and data is not a tensor then\n        the result tensor is constructed on the CPU.\n    requires_grad (bool, optional): If autograd should record operations on the\n        returned tensor. Default: ``False``.\n    pin_memory (bool, optional): If set, returned tensor would be allocated in\n        the pinned memory. Works only for CPU tensors. Default: ``False``.\nExample::\n    &gt;&gt;&gt; torch.tensor([[0.1, 1.2], [2.2, 3.1], [4.9, 5.2]])\n    tensor([[ 0.1000,  1.2000],\n            [ 2.2000,  3.1000],\n            [ 4.9000,  5.2000]])\n    &gt;&gt;&gt; torch.tensor([0, 1])  # Type inference on data\n    tensor([ 0,  1])\n    &gt;&gt;&gt; torch.tensor([[0.11111, 0.222222, 0.3333333]],\n    ...              dtype=torch.float64,\n    ...              device=torch.device('cuda:0'))  # creates a double tensor on a CUDA device\n    tensor([[ 0.1111,  0.2222,  0.3333]], dtype=torch.float64, device='cuda:0')\n    &gt;&gt;&gt; torch.tensor(3.14159)  # Create a zero-dimensional (scalar) tensor\n    tensor(3.1416)\n    &gt;&gt;&gt; torch.tensor([])  # Create an empty tensor (of size (0,))\n    tensor([])\nType:      builtin_function_or_method\n@dataclass\nclass SelectionModelParameters:\n    n_verb: int\n    n_frame: int\n    n_subj: int\n    n_resp_levels: int\n    \n@dataclass\nclass UnconstrainedSelectionModelParameters(SelectionModelParameters):\n    n_component: int\n\n@dataclass\nclass SelectionData:\n    verb: ndarray\n    frame: ndarray\n    subj: ndarray\n    resp: ndarray\nimport torch\nfrom torch import Tensor\n\ndef ordered_logistic_likelihood(value: Tensor, jumps: Tensor, center: bool = True) -&gt; Tensor:\n    \"\"\"Compute the ordered logistic likelihood given a value\n    \n    Parameters\n    ----------\n    value\n        The value to compute the likelihood for \n        (shape: batch_size)\n    jumps\n        The distance between cutpoints \n        (shape: batch_size x number of response levels - 1)\n\n    Returns\n    -------\n    log_likelihood\n        the ordered logistic log-likelihood\n    \"\"\"\n    cutpoints = torch.cumsum(jumps, 1) \n    \n    if center:\n        cutpoints = cutpoints - cutpoints.mean()\n    \n    cdfs = torch.sigmoid(cutpoints - value[:,None])\n\n    low_prob = torch.cat(\n        [torch.zeros([cdfs.shape[0], 1]), cdfs],\n        axis=1\n    )\n    high_prob = torch.cat(\n        [cdfs, torch.ones([cdfs.shape[0], 1])],\n        axis=1\n    )\n    \n    return high_prob - low_prob\nclass UnconstrainedSelectionModel(torch.nn.Module):\n    parameter_class = UnconstrainedSelectionModelParameters\n    data_class = SelectionData\n    \n    def __init__(self, parameters: UnconstrainedSelectionModelParameters):\n        super().__init__()\n        \n        self.model_parameters = parameters\n        \n        self.verb_component_aux = torch.nn.Parameter(\n            torch.randn([\n                parameters.n_verb, parameters.n_component\n            ]), \n            requires_grad=True\n        )\n        self.frame_component_aux = torch.nn.Parameter(\n            torch.randn([\n                parameters.n_frame, parameters.n_component\n            ]), \n            requires_grad=True\n        )\n        \n        self.log_jumps = torch.nn.Parameter(\n            torch.ones([\n                parameters.n_subj, parameters.n_resp_levels-1\n            ]), \n            requires_grad=True\n        )\n        \n\n    def forward(self, data: SelectionData):\n        verb_frame_prob = self.verb_frame_prob(data.verb, data.frame)\n        verb_frame_logodds = torch.log(verb_frame_prob) - torch.log(1. - verb_frame_prob)\n        \n        jumps = self.jumps[data.subj]\n        \n        return ordered_logistic_likelihood(\n            verb_frame_logodds, jumps\n        )\n    \n    def verb_frame_prob(\n        self, \n        verb_idx: Optional[ndarray] = None, \n        frame_idx: Optional[ndarray] = None\n    ) -&gt; Tensor:\n        if verb_idx is not None or frame_idx is not None:\n            return 1. - torch.prod(\n                1. - self.verb_component_prob[verb_idx,:] * \n                     self.frame_component_prob[frame_idx,:],\n                axis=1\n            )\n        elif verb_idx is None and frame_idx is not None:\n            return 1. - torch.prod(\n                1. - self.verb_component_prob[:,None,:] * \n                     self.frame_component_prob[:,frame_idx,:],\n                axis=2\n            )\n        elif verb_idx is not None and frame_idx is None:\n            return 1. - torch.prod(\n                1. - self.verb_component_prob[verb_idx,None,:] * \n                     self.frame_component_prob[None,:,:],\n                axis=2\n            )\n        else:\n            return 1. - torch.prod(\n                1. - self.verb_component_prob[:,None,:] * \n                     self.frame_component_prob[None,:,:],\n                axis=2\n            )       \n    \n    @property\n    def verb_component_prob(self) -&gt; Tensor:\n        return torch.sigmoid(self.verb_component_aux)\n    \n    @property\n    def frame_component_prob(self) -&gt; Tensor:\n        return torch.sigmoid(self.frame_component_aux)\n    \n    @property\n    def jumps(self):\n        return torch.exp(self.log_jumps)\nfrom abc import ABC, abstractmethod\n\nclass SelectionModelTrainer(ABC):\n    data_class = SelectionData\n    \n    @abstractmethod\n    def construct_model_parameters(self, data: pd.DataFrame) -&gt; SelectionModelParameters:\n        raise NotImplementedError\n        \n    def construct_model_data(self, data: pd.DataFrame) -&gt; SelectionData:            \n        if hasattr(self, \"frame_hash_map\"):\n            _, frame_hashed = hash_series(data.frame, self.frame_hash_map, indexation=0)\n        else:\n            self.frame_hash_map, frame_hashed = hash_series(data.frame, indexation=0)\n            \n        if hasattr(self, \"verb_hash_map\"):\n            _, verb_hashed = hash_series(data.verb, self.verb_hash_map, indexation=0)\n        else:\n            self.verb_hash_map, verb_hashed = hash_series(data.verb, indexation=0)\n\n        if hasattr(self, \"subj_hash_map\"):\n            _, subj_hashed = hash_series(data.participant, self.subj_hash_map, indexation=0)\n        else:\n            self.subj_hash_map, subj_hashed = hash_series(data.participant, indexation=0)\n        \n        model_data = {\n            \"verb\": verb_hashed,\n            \"frame\": frame_hashed,\n            \"subj\": subj_hashed,\n            \"resp\": data.response.astype(int).values - 1\n        }\n        \n        return self.data_class(**model_data)\n    \n    def _initialize_model(self, data: pd.DataFrame):\n        model_parameters = self.construct_model_parameters(data)\n        \n        return self.model_class(model_parameters)\n    \n    def fit(\n        self, data: pd.DataFrame, batch_size=1000, n_epochs:int=1000, \n        lr: float = 1e-5, verbosity: int=100\n    ) -&gt; UnconstrainedSelectionModel:\n        # necessary for initializing hashes\n        self.model_data = self.construct_model_data(data)\n        self.model = self._initialize_model(data)\n        \n        optimizer = torch.optim.Adam(self.model.parameters(), lr=lr)\n        \n        for e in range(n_epochs):\n            data_shuffled = data.sample(frac=1.).reset_index(drop=True)\n            \n            n_batches = int(data_shuffled.shape[0]/batch_size)\n        \n            epoch_total_loss = 0.\n        \n            correlations = []\n            \n            for i in range(n_batches):\n                lower_bound = i*batch_size\n                \n                if i == (n_batches - 1):\n                    upper_bound = data_shuffled.shape[0]\n                else:\n                    upper_bound = (i+1)*batch_size\n\n                data_sub = self.construct_model_data(data_shuffled.iloc[lower_bound:upper_bound])\n                target = torch.tensor(data_sub.resp)\n\n                optimizer.zero_grad()\n\n                probs = self.model(data_sub)\n                logprobs = torch.log(probs)\n\n                loss = self.loss_function(logprobs, target)\n\n                # compute correlation between expected value and target\n                expected_value = torch.sum(\n                    torch.arange(1, probs.shape[1]+1)[None,:] * probs, \n                    axis=1\n                )\n                corr = torch.corrcoef(\n                    torch.cat([\n                        expected_value[None,:], \n                        target[None,:]\n                    ], axis=0)\n                )\n                correlations.append(corr[0,1].item())\n                \n                loss.backward()\n\n                optimizer.step()\n                \n                epoch_total_loss += loss.item()\n                \n            if verbosity and not e % verbosity:\n                print(f\"Epoch:       {e}\")\n                print(f\"Loss:        {np.round(epoch_total_loss, 2)}\")\n                print(f\"Mean corr.:  {np.round(np.mean(correlations), 2)}\")\n                print()\n                \n        \n        return self\n    \n    def expected_value(self, data: pd.DataFrame):\n        model_data = self.construct_model_data(data)\n        probs = self.model(model_data)\n        \n        expected_value = torch.sum(\n            torch.arange(1, 8)[None,:] * probs, \n            axis=1\n        )\n        \n        return expected_value\n    \n    def likelihood(self, data: pd.DataFrame):\n        model_data = self.construct_model_data(data)\n        probs = self.model(model_data)\n        \n        return probs[model_data.resp]\n    \n    def predict(self, data: pd.DataFrame):\n        model_data = self.construct_model_data(data)\n        probs = self.model(model_data)\n        \n        return probs[model_data.resp]\nclass UnconstrainedSelectionModelTrainer(SelectionModelTrainer):\n    parameter_class = UnconstrainedSelectionModelParameters\n    model_class = UnconstrainedSelectionModel\n    \n    def __init__(self, n_component: int):\n        self.n_component = n_component\n        \n        self.loss_function = torch.nn.CrossEntropyLoss(reduction=\"sum\")\n    \n    def construct_model_parameters(self, data: pd.DataFrame) -&gt; UnconstrainedSelectionModelParameters:\n        model_parameters = {\n            \"n_verb\": self.verb_hash_map.shape[0],\n            \"n_frame\": self.frame_hash_map.shape[0],\n            \"n_subj\": self.subj_hash_map.shape[0],\n            \"n_resp_levels\": 7,\n            \"n_component\": self.n_component\n        }\n        \n        return self.parameter_class(**model_parameters)\n    \nm = UnconstrainedSelectionModelTrainer(2)\nm.fit(data)\n\nEpoch:       0\nLoss:        1147684.59\nMean corr.:  0.03\n\nEpoch:       100\nLoss:        950132.16\nMean corr.:  0.19\n\nEpoch:       200\nLoss:        792799.86\nMean corr.:  0.28\n\n\n\nKeyboardInterrupt:\nfrom scipy.stats import spearmanr\n\ndata[\"expected_value\"] = m.expected_value(data).data\n\n_ = sns.boxplot(data, x=\"response\", y=\"expected_value\")\n\nspearmanr(data[[\"response\", \"expected_value\"]])\n\nSignificanceResult(statistic=0.42813175602327286, pvalue=0.0)\n#sns.clustermap(pd.DataFrame(m.model.frame_component_prob.data, index=m.frame_hash_map), cmap=\"vlag\", yticklabels=True)\nsns.clustermap(pd.DataFrame(m.model.verb_component_prob.data, index=m.verb_hash_map), cmap=\"vlag\", yticklabels=True)\n@dataclass\nclass ConstrainedSelectionModelParameters(SelectionModelParameters):\n    n_clause_component: int\n    n_nonclause_component: int\nimport torch\nfrom torch import Tensor\n\nclass ConstrainedSelectionModel(torch.nn.Module):\n    parameter_class = ConstrainedSelectionModelParameters\n    \n    def __init__(self, parameters: ConstrainedSelectionModelParameters):\n        super().__init__()\n        \n        self.model_parameters = parameters\n        \n        self.verb_clause_aux = torch.nn.Parameter(\n            torch.randn([parameters.n_verb]), \n            requires_grad=True\n        )\n        self.verb_nonclause_aux = torch.nn.Parameter(\n            torch.randn([\n                parameters.n_verb, parameters.n_nonclause_component\n            ]), \n            requires_grad=True\n        )\n        \n        self.frame_clause_aux = torch.nn.Parameter(\n            torch.randn([parameters.n_frame]), \n            requires_grad=True\n        )\n        self.frame_nonclause_aux = torch.nn.Parameter(\n            torch.randn([\n                parameters.n_frame, parameters.n_nonclause_component\n            ]), \n            requires_grad=True\n        )\n        \n        self.log_clause_jumps = torch.nn.Parameter(\n            torch.ones(parameters.n_clause_component-1), \n            requires_grad=True\n        )\n        \n        self.log_jumps = torch.nn.Parameter(\n            torch.ones([\n                parameters.n_subj, parameters.n_resp_levels-1\n            ]), \n            requires_grad=True\n        )\n        \n\n    def forward(self, data: SelectionData):\n        verb_frame_prob = self.verb_frame_prob(data.verb, data.frame)\n        verb_frame_logodds = torch.log(verb_frame_prob) - torch.log(1. - verb_frame_prob)\n        \n        jumps = self.jumps[data.subj]\n        \n        return ordered_logistic_likelihood(\n            verb_frame_logodds, jumps\n        )\n   \n    def verb_frame_prob(\n        self, \n        verb_idx: Optional[ndarray] = None, \n        frame_idx: Optional[ndarray] = None\n    ) -&gt; Tensor:\n        return self.verb_frame_clause_prob(verb_idx, frame_idx) *\\\n               self.verb_frame_nonclause_prob(verb_idx, frame_idx)\n\n    def verb_frame_clause_prob(\n        self, \n        verb_idx: Optional[ndarray] = None, \n        frame_idx: Optional[ndarray] = None\n    ) -&gt; Tensor:\n        if verb_idx is not None or frame_idx is not None:\n            return 1. - torch.prod(\n                1. - self.verb_clause_component_prob[verb_idx,:] * \n                     self.frame_clause_component_prob[frame_idx,:],\n                axis=1\n            )\n        elif verb_idx is None and frame_idx is not None:\n            return 1. - torch.prod(\n                1. - self.verb_clause_component_prob[:,None,:] * \n                     self.frame_clause_component_prob[:,frame_idx,:],\n                axis=2\n            )\n        elif verb_idx is not None and frame_idx is None:\n            return 1. - torch.prod(\n                1. - self.verb_clause_component_prob[verb_idx,None,:] * \n                     self.frame_clause_component_prob[None,:,:],\n                axis=2\n            )\n        else:\n            return 1. - torch.prod(\n                1. - self.verb_clause_component_prob[:,None,:] * \n                     self.frame_clause_component_prob[None,:,:],\n                axis=2\n            ) \n\n    def verb_frame_nonclause_prob(\n        self, \n        verb_idx: Optional[ndarray] = None, \n        frame_idx: Optional[ndarray] = None\n    ) -&gt; Tensor:\n        if verb_idx is not None or frame_idx is not None:\n            return 1. - torch.prod(\n                1. - self.verb_nonclause_component_prob[verb_idx,:] * \n                     self.frame_nonclause_component_prob[frame_idx,:],\n                axis=1\n            )\n        elif verb_idx is None and frame_idx is not None:\n            return 1. - torch.prod(\n                1. - self.verb_nonclause_component_prob[:,None,:] * \n                     self.frame_nonclause_component_prob[:,frame_idx,:],\n                axis=2\n            )\n        elif verb_idx is not None and frame_idx is None:\n            return 1. - torch.prod(\n                1. - self.verb_nonclause_component_prob[verb_idx,None,:] * \n                     self.frame_nonclause_component_prob[None,:,:],\n                axis=2\n            )\n        else:\n            return 1. - torch.prod(\n                1. - self.verb_nonclause_component_prob[:,None,:] * \n                     self.frame_nonclause_component_prob[None,:,:],\n                axis=2\n            )       \n    \n    @property\n    def verb_clause_component_prob(self) -&gt; Tensor:\n        return ordered_logistic_likelihood(\n            self.verb_clause_aux, self.clause_jumps[None,:]\n        )\n    \n    @property\n    def frame_clause_component_prob(self) -&gt; Tensor:\n        return ordered_logistic_likelihood(\n            self.frame_clause_aux, self.clause_jumps[None,:]\n        )\n    \n    @property\n    def verb_nonclause_component_prob(self) -&gt; Tensor:\n        return torch.sigmoid(self.verb_nonclause_aux)\n    \n    @property\n    def frame_nonclause_component_prob(self) -&gt; Tensor:\n        return torch.sigmoid(self.frame_nonclause_aux)\n\n    @property\n    def clause_jumps(self):\n        return torch.exp(self.log_clause_jumps)\n    \n    @property\n    def jumps(self):\n        return torch.exp(self.log_jumps)\nclass ConstrainedSelectionModelTrainer(SelectionModelTrainer):\n    parameter_class = ConstrainedSelectionModelParameters\n    model_class = ConstrainedSelectionModel\n    \n    def __init__(self, n_clause_component: int, n_nonclause_component: int):\n        self.n_clause_component = n_clause_component\n        self.n_nonclause_component = n_nonclause_component\n        \n        self.loss_function = torch.nn.CrossEntropyLoss(reduction=\"sum\")\n    \n    def construct_model_parameters(self, data: pd.DataFrame) -&gt; UnconstrainedSelectionModelParameters:\n        model_parameters = {\n            \"n_verb\": self.verb_hash_map.shape[0],\n            \"n_frame\": self.frame_hash_map.shape[0],\n            \"n_subj\": self.subj_hash_map.shape[0],\n            \"n_resp_levels\": 7,\n            \"n_clause_component\": self.n_clause_component,\n            \"n_nonclause_component\": self.n_nonclause_component\n        }\n        \n        return self.parameter_class(**model_parameters)\n    \nm = ConstrainedSelectionModelTrainer(3, 2)\nm.fit(data)\n\nEpoch:       0\nLoss:        1078181.55\nMean corr.:  0.02\n\n\n\nKeyboardInterrupt:\nsns.clustermap(pd.DataFrame(m.model.frame_clause_component_prob.data, index=m.frame_hash_map), yticklabels=True)\n#sns.clustermap(pd.DataFrame(m.model.verb_component_prob.data, index=m.verb_hash_map), cmap=\"vlag\", yticklabels=True)\n\nValueError: The condensed distance matrix must contain only finite values.\nordered_logistic_likelihood??\n\n\nSignature:\nordered_logistic_likelihood(\n    value: torch.Tensor,\n    jumps: torch.Tensor,\n    center: bool = True,\n) -&gt; torch.Tensor\nSource:   \ndef ordered_logistic_likelihood(value: Tensor, jumps: Tensor, center: bool = True) -&gt; Tensor:\n    \"\"\"Compute the ordered logistic likelihood given a value\n    \n    Parameters\n    ----------\n    value\n        The value to compute the likelihood for \n        (shape: batch_size)\n    jumps\n        The distance between cutpoints \n        (shape: batch_size x number of response levels - 1)\n    Returns\n    -------\n    log_likelihood\n        the ordered logistic log-likelihood\n    \"\"\"\n    cutpoints = torch.cumsum(jumps, 1) \n    \n    if center:\n        cutpoints = cutpoints - cutpoints.mean()\n    \n    cdfs = torch.sigmoid(cutpoints - value[:,None])\n    low_prob = torch.cat(\n        [torch.zeros([cdfs.shape[0], 1]), cdfs],\n        axis=1\n    )\n    high_prob = torch.cat(\n        [cdfs, torch.ones([cdfs.shape[0], 1])],\n        axis=1\n    )\n    \n    return high_prob - low_prob\nFile:      /tmp/ipykernel_31725/3045571987.py\nType:      function"
  },
  {
    "objectID": "selection/index.html#footnotes",
    "href": "selection/index.html#footnotes",
    "title": "Selection",
    "section": "Footnotes",
    "text": "Footnotes\n\n\nIn fact, not all predicates found in their sentences are necessarily verbs. Some–e.g. annoy–are likely to be (deverbal) adjectives in some frames. We’ll continue to just refer to these predicates as verbs.↩︎"
  },
  {
    "objectID": "thematic-roles/index.html",
    "href": "thematic-roles/index.html",
    "title": "Module 4: Thematic Roles",
    "section": "",
    "text": "Availability\n\n\n\nThis section will be available Thursday, 29 June 2023. Please complete the below reading prior to that date.\n\n\n\n\n\n\n\n\nReading\n\n\n\nData: Reisinger et al. (2015) and White et al. (2020) on collecting corpus annotations of the proto-role properties proposed by Dowty (1991). We will use the Universal Decompositional Semantics (UDS) dataset (v2.0 Gantt, Glass, and White 2022), which is packaged with the decomp toolkit, available here.\nTheory: Levin and Rappaport Hovav (2005, Ch. 2) on the explanatory role of generalized thematic roles.\n\n\n\n\n\n\nReferences\n\nDowty, David. 1991. “Thematic Proto-Roles and Argument Selection.” Language 67 (3): 547–619. https://doi.org/10.2307/415037.\n\n\nGantt, William, Lelia Glass, and Aaron Steven White. 2022. “Decomposing and Recomposing Event Structure.” Transactions of the Association for Computational Linguistics 10 (January): 17–34. https://doi.org/10.1162/tacl_a_00445.\n\n\nLevin, Beth, and Malka Rappaport Hovav. 2005. Argument Realization. Cambridge: Cambridge University Press.\n\n\nReisinger, Dee Ann, Rachel Rudinger, Francis Ferraro, Craig Harman, Kyle Rawlins, and Benjamin Van Durme. 2015. “Semantic Proto-Roles.” Transactions of the Association for Computational Linguistics 3: 475–88. https://doi.org/10.1162/tacl_a_00152.\n\n\nWhite, Aaron Steven, Elias Stengel-Eskin, Siddharth Vashishtha, Venkata Subrahmanyan Govindarajan, Dee Ann Reisinger, Tim Vieira, Keisuke Sakaguchi, et al. 2020. “The Universal Decompositional Semantics Dataset and Decomp Toolkit.” In Proceedings of the Twelfth Language Resources and Evaluation Conference, 5698–5707. Marseille, France: European Language Resources Association. https://aclanthology.org/2020.lrec-1.699."
  }
]